{"./":{"url":"./","title":"README","keywords":"","body":"README 这个GitBook主要包含 杂笔：知识笔记,心得体会等 技术：总结整理后的技术相关文章 记录：一些实践性方案经验记录 关于这个Blog的来源可以参看: Blog最佳实践markdown+gitbook+vscode Email： guobao.v@gmail.com guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-28 22:20:13 "},"posts/Blog最佳实践markdown+gitbook+vscode.html":{"url":"posts/Blog最佳实践markdown+gitbook+vscode.html","title":"Blog最佳实践markdown+gitbook+vscode","keywords":"","body":"Blog 最佳实践 markdown + gitbook + vscode [toc] 当前影响Blog持久维护的因素有哪些? 一个Blog的最佳实践是怎样的?或者说一个好的Blog实践最好应该满足哪些条件? 当前常见方案有哪些缺点? 原先建的基于wordpress的博客总觉得很臃肿,对markdown的支持有限,或者说写作体验一言难尽,所以现在已经废弃了. 随着阅历的增长,精力的分散,对事物的追求逐渐朝着极简的方向走去,另一方面自感当前自身的主要矛盾在于信息的大量输入与总结和深度思考之间的不平衡,本身有用onenote+xmind做知识库的习惯,一直没有时间整理输出,本质是拖延症导致的输出不力,所以希望能简单地及时地输出一些技术文章或心得总结,在此过程中满足好奇心,整理知识体系,有所进益. 对于一个严谨的技术宅来说,如何长期维护好一个Blog是一件值得好好研究的事情.想清楚以下2个问题,那么问题就解决了一半. 当前影响Blog持久维护的因素有哪些? 国内访问不良,如果自建站的云虚机在国外的服务商,容易导域名污染等问题.特别是往往同一个VPS还要挂载自己的代理服务，更容易被BAN。 VPS维护不良,每年的域名,HTTPS管理,还有大量脚本小子喜欢扫描漏洞,对小虚机来说跟DDOS一样,容易崩. 搜索引擎索引不良,流量可以产生正向反馈,如果没人看的话持续写作的积极性会受到影响, MSDN类博客占搜索引擎权重较高流量较好但是写作及阅读体验不够简洁. 写作体验不良,网页编辑器不友好,对markdown的支持不佳特别是md的高阶功能,流程图等等. 阅读体验不佳,自建站需要易用的md渲染器.Wordpress上有插件，但WP本身不够简洁. 图像资源管理麻烦,一般需要先上传到OSS再插入网络链接,为了方便迁移,转载,一般不放网站本地. 文章管理不方便,如果需要移动或者重新分类的话,点来点去实在不够方便. 一个Blog的最佳实践是怎样的?或者说一个好的Blog实践最好应该满足哪些条件? 省时省心省资源 一切不让人省时省心的方案都应该Pass掉,让Blog回归写作与分享 使用托管而非自建站 网页静态构建 良好的文本编辑体验 跨平台(迁移性) 富文本(描述性) 社群支持丰富(扩展性) 所见即所得 良好的可维护性 足够简洁,满足基础Blog功能 项目直接管理图像资源 良好的可阅读性 结构化书籍模式,文章分层分类,一目了然 代码高亮 搜索引擎索引良好 当前常见方案有哪些缺点? wordpress 臃肿,不适合技术写作 github project + issue 可迁移性差,issue放文章简直反人类 github jkeyll jkeyll学习成本相对较高 首先需要找个好的静态模板,挑个模板得调试半天 不够简洁 各博客网站 辅助传播可以,不够技术范 综上,经过一番探索,当前最好的方案是: 写作载体: markdown 内容载体: gitbook 编辑载体: vscode 这三者的搭配是一脉相承,全面且是更加md-style的. markdown 不必细说,除了原生语法,高阶语法/特性需要平台或编辑器能够支持:科学公式LaTeX,文章目录TOC,流程图,时序图,甘特图,思维导图(xmind支持使用markdown来写导图)等等. vscode 宇宙第一编辑器,安装扩展插件Markdown Preview Enhanced,支持大量功能特性，建议查看MPE官方文档。 gitbook 基于markdown,可以构建静态页面放到GitHub Pages中托管并且自动和Github仓库同步,支持社交分享评论,代码高亮等等各类丰富的插件,且插件及其容易集成配置,能够满足许多增强性扩展性的要求.关于gitbook的更多细节可以参看gitbook简明教程. Github pages和Gitbook设置完成后可以通过 https://mainvooid.github.io/ 或 https://ipanda.gitbook.io/blog 访问到同一个Blog. 事实上我首先考虑的是用jekyll做内容载体,更丰富的网站模板与功能,但是我发现在开始使用jekyll之前,我需要首先找到一个符合我风格的足够合适的模板,毕竟我不是前端,琳琅满目的模板实在没有让我满意的,我累了,这不够naive and simple,我放弃了,所以我选择另寻出路,直到我意识到gitbook可以完美担此重任. 而且使用gitbook还有一个好处是,可以像写书一样写Blog,更有层次感也更容易建立分类体系,对Blog结构和内容的控制是一体化的,不需要涉及HTML,而且构建出来的网页是左目录右内容的形式,更加有md-style的感觉,最重要的是——简洁. 影响Blog持久维护的本质其实就是写作以外的事情占用了过多的精力.比如设计调整Blog风格,需要过多考虑博文分类,甚至自建站需要考虑更多东西例如网站安全或SEO,写到后期会发现Blog越来越臃肿而难以管理,但凡写Blog的人多少有点完美主义,这种事情注定是难以持续的. 所以,如果你正好看见了我的这篇博文,正在考虑如何持久维护一个Blog,比如五年起步,那么,我给你的建议就是——\"越简单越好,回归写作本身\". gitbook和github pages(.github.io)想要建立关联的话,需要注意的是,gitbook通过读取SUMMARY.md来呈现页面,而后者由于只能使用master分支构建,所以需要将gitbook生成的_book目录下的文件拷贝到该master分支,也就是说.github.io仓库内应该有俩个分支,master分支保存最终的静态页面,用于github.io访问,另外新建一个分支保存gitbook源码,并且与gitbook.io同步。同步的意义在于,gitbook.io可以被搜索引擎良好索引。 关于什么叫md-style,我的个人理解是: 简洁但不简单 语法简单,同时支持大量高级特性与富文本扩展 左右对称 语法块大多是闭合体 编辑时,左编辑右预览 英文符号 标点符号使用英文字符,删除所有尾随空格,与md统一风格的话输入法可以设置中文时使用英文标点. guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:27 "},"posts/C++奇淫巧计.html":{"url":"posts/C++奇淫巧计.html","title":"C++奇淫巧计","keywords":"","body":"C++ 奇淫巧计 [toc] 泛型编程 其他非语言特性的技巧 第一眼看上去比较新鲜的各种C++实践。 收录内容比较主观,有些是现代C++的新特性，有些可能蛮常见的,但是回想第一次看见时还挺新鲜的,所以会一并收录。 取数组大小 int arr[]={1,2,3,4,5}; int size = sizeof(arr)/sizeof(arr[1]);//正常 int size = *(&arr+1)-arr; //不走寻常路 文件内扩栈(系统栈不够用的话) #pragma comment(linker,\"/STACK:102400000,102400000\") //g++中使用这种方法 int __size__ = 256 文件内指定链接静态库 #pragma message(\"link opencv libs in opencv.hpp.\")//链接库文件时可以编译提示 #pragma comment(lib,\"opencv_core410.lib\") 代码中开O3优化 #define fastcall __attribute__((optimize(\"-O3\"))) 大括号别名 { } 等价于 看起来像趋近于的while(i-->0)，实际上是: int i = 10; while((i--) > 0) {//＞0 打印后自减 cout 通过异或法原地交换整数a b int a = 1, b = 2; a ^= b ^= a ^= b;//显然a,b不能是同一个对象的引用 cout 最简洁也是效率最高的单例模式的实现 single& single::get_instance() { static single instance; return instance; } 等价读取,产生合并的唯一ID //给part成员赋值,以merge_id读取,只要保证内存匹配就可以互相转换 union msg_id { int merge_id;// = major_id | minor_id 2次幂枚举量 enum Days { None = 0, Sunday = 1, Monday = 2, Tuesday = 4, Wednesday = 8, Thursday = 16, Friday = 32, Saturday = 64 }; Days flag = Days::Monday; //添加条件: | flag = Days(flag | Days::Wednesday); //删除条件: &~ flag = Days(flag & ~ Wednesday); // \"flag\" 为 \"Monday\" if ((flag & Monday) == Monday) {cout delete this 当初知道类成员函数内可以这么写给我看懵了，有点反直觉，我杀我自己 确保对象是new出来的 确保delete完后不能访问对象的任何部分 确保delete完后this指针不会被访问 自定义字面量 // 通过重载双引号后缀运算符实现 // 字符串字面量自定义必须设置如下的参数列表 std::string operator\"\" _wow1(const char *wow1, size_t len) { return std::string(wow1)+\"def\"; } // 整形设置如下的参数列表 std::string operator\"\" _wow2 (unsigned long long i) { return std::to_string(i) + \"23456\"; } auto str = \"abc\"_wow1;//abcdef auto num = 1_wow2;//123456 结构化绑定 C++17 std::tuple f({1,2.0,\"a\"}) auto [x, y, z] = f(); 如何将lambda存在new出来的内存？ auto fn=new auto([]{}); delete fn; 如何检测某个类有某个名字的成员？ bool flag=std::is_member_pointer::value; main函数的类型名是什么? #include #include using namespace std; int main(){ cout 泛型编程 泛型编程比较特殊,单独列出.模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。 自动推断数组大小(一般的非类型模板) //(unsigned需要放在前面) template void arr(const T (&m)[n]) { std::cout 自动推导的非类型模板 C++17 enum e{a,b,c}; template void foo(){ cout (); //10 foo(); //0 } 不定长参数列表 标准但落后的递归法解包 // 用于结束递归的同名模板函数 template inline void delete_s(T& p){ if (p != nullptr) { delete(p); p = nullptr; } } // 用于递归不定长参数的同名模板函数 template inline void delete_s(T& p, Args&... args){ if (p != nullptr) { delete(p); p = nullptr; } delete_s(args...); } // 可以接受任意长参数 int main(){ auto* p1=new auto([]{}); auto* p2=new auto([]{}); auto* p3=new auto([]{}); cout 条件编译递归解包 C++17// 一个递归函数搞定 template void delete_s(T& p, Args&... args) { if (p != nullptr) { delete(p); p = nullptr; } if constexpr (sizeof...(args) > 0) delete_s(args...); } lambda表达式+逗号表达式(黑魔法) 非递归原地解包//(a, b)这个表达式的值就是b. 执行((lambda, value),...) //首先会执行前面的lambda,而后计算逗号表达式(值为0),接着继续展开 template auto delete_s(T& p, Args&... args){ if (p != nullptr) { delete(p); p = nullptr; } (([&args]{ if (args != nullptr) { delete(args); args = nullptr; } }(),0),...); } 折叠表达式 template auto sum(T ... t) { return (t + ...); } int main() { cout 泛型Lambda C++14 // 正常模板写法 template auto add(T t, U u) {return t+u;} // 新特性 auto add = [](auto x, auto y) {return x+y;}; cout 函数缓存 为了优化程序性能我们经常使用缓存,比如某个函数非常耗时,频繁调用的时候性能会很低,这时我们可以通过缓存来提高性能. namespace detail { //函数入参及结果缓存,缓存入参和函数的执行结果,若入参存在则从缓存返回结果 template std::function cache_fn(R(*func)(Args...)){ auto result_map = std::make_shared, R>>(); return ([=](Args... args) {//延迟执行 std::tuple _args(args...); if (result_map->find(_args) == result_map->end()) { (*result_map)[_args] = func(args...);//未找到相同入参,执行函数刷新缓存 } return (*result_map)[_args];//返回缓存的对应入参的结果 }); } } //函数对象缓存,若存在相同类型函数指针,则调用相应缓存函数获取缓存结果 template std::function cache_fn(R(*func)(Args...), bool flush = false){ using function_type = std::function; static std::unordered_map functor_map; if (flush) {//明确要求刷新缓存 return functor_map[func] = detail::cache_fn(func); } if (functor_map.find(func) == functor_map.end()) { functor_map[func] = detail::cache_fn(func);//未找到相同函数,执行函数刷新缓存 } return functor_map[func];//返回对应函数的缓存的结果 } //函数缓存可以提高类似重复计算类函数的性能 //以计算斐波那契数列为例: O(N^2) --> O(N) size_t fibonacci_1(size_t n) { return (n std::shared_ptr和boost::shared_ptr之间的转换. [Refer] // 通过按值捕获将原始ptr(及其引用计数)保留在删除器lambda中 // 可能有一定缺陷，例如无法来回转换 template std::shared_ptr to_std(const boost::shared_ptr &p) { return std::shared_ptr(p.get(), [p](...) mutable { p.reset(); }); } template boost::shared_ptr to_boost(const std::shared_ptr &p) { return boost::shared_ptr(p.get(), [p](...) mutable { p.reset(); }); } 其他非语言特性的技巧 abs移位运算 int abs(int x){ int y = x >> 31; return (x ^ y) - y; // or: (x+y)^y } guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 10:12:48 "},"posts/C++编码规范-实用增强细节版.html":{"url":"posts/C++编码规范-实用增强细节版.html","title":"C++编码规范-实用增强细节版","keywords":"","body":"C++编码规范(实用增强细节版) [toc] 背景 现象 观点 规范 扩展 基于google开源项目风格指南的实用增强细节版 包含C++风格建议：使用基于小写下划线的蛇形风格 背景 C++非常强大灵活并且包含大量高级特性, 但这种强大不可避免的导致它走向复杂, 使代码更容易产生 bug, 难以阅读和维护. 本规范通过限制甚至禁止使用某些特性. 保持代码清爽及良好的代码习惯,来避免这些特性可能导致的各种问题来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性. 规范包含通用性习惯, 编程注意事项, 编程模式倾向以及代码风格(文本格式化、可读性) 使代码易于管理的方法之一是加强代码一致性. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 现象 Google的C++开源规范问题很多, 没法拿来就用, 需要精简取其精华, 并且切合项目实际, 使得规范简单容易遵循. 从代码风格来讲, google表观的代码风格是一种紧凑型风格, 原则保证必要格式化下, 一页尽可能显示更多的内容, 但是会牺牲一定的可读性. Google规范内容很多, 主要面向开源, 有些规则有点过时了, 并且有自身的路径依赖, 没有考虑到编译器与编辑器的作用, 所以这个规范在google本身的项目的覆盖率都不高, 比如tensorflow大概60%的样子, gtest大概70% e.g.:tensorflow/graph.h googletest/gtest.cc , 这引申出来一个规范制定要点, 规范及代码风格要求应该简单好执行 C++标准特性近年有向类python风格发展的趋势, 比如auto,结构化绑定及解包, 列表初始化, foreach等等, 本质上是向简化及高效化发展的, 但是google规范中有些限制就有点因噎废食了, 比如限制重载运算符, 比如一方面限制流的使用然后另外一方面增加复杂的保证64位下的可移植性的规则, 实际上没有意义. 不要因噎废食, 或者多此一举 google规范有些规则限制不当, 比如大部分教科书推荐使用无符号类型表示非负数.但是它不建议使用无符号类型, 理由是有的人会很愚蠢地写出下面的代码： // 此循环永远不会退出 for (unsigned int i = foo.Length()-1; i >= 0; --i) ... 实际上, 这种行为是在试图兼容不正确的用法, 是没有必要也没有意义的, 无符号的正确用法如下, // 正确用法 for (unsigned int i = foo.Length()-1; i != 0; --i) ... 没有更完整考虑编译器行为 一个事实是, 同样的代码java生成的程序比原生C生成的程序要快. 因为java编译为字节码的过程中默认是开启优化的, 如果C程序不开优化实际上效率还不如java, 所以所有release版本的C程序都需要开O3优化(自动内联). 我们知道只有当函数小于 10 行才适合将其定义为内联函数, 如果有考虑编译器行为, 实际上完全不需要人为考虑给编译器建议内联, 完全交给编译器就完事了, 而且有的时候你即使声明为内联的也不一定会被编译器内联. 关于内联有2个点, 类内都是隐式内联的, inline声明非成员函数. 内联可以解决重定义的问题, 编译器在链接的时候会将他们链接到第一个找到的定义上. 规范中认为启用异常会增加二进制文件数据, 延长编译时间, 但是在现代编译器下, 开优化后这种影响已经非常小了. 对使用 C++ 异常处理应具有怎样的态度？按需正常使用即可. 没有考虑编辑器行为 比如google规范中成员变量后置下划线, 实际上应该前置下划线, 理由有2点： 统一语义：成员变量与私有函数全部前置下划线, 下划线一般代表私有/成员的意思和python的习惯也能统一 智能感知：编辑器中输入_, 大部分编辑器都有智能感知, 可以立马列出所有私有成员, 会很方便. google的紧凑型规范没有一个好的机制去格式化, 全手动控制, 特别容易失控且浪费精力. 我原先也比较喜欢紧凑型风格, 但是vscode的默认格式化行为是教材上的C++标准风格, CTRL+SHIFT+I就完事了, 所以google定义了大量缩进哪哪空格哪哪括号的规则直接没有实现的意义. 而且缩进规则在紧凑型风格指导下也很另类, 大部分编辑器包括飞书的都是默认缩进4空格的,但是它的缩进是1, 2, 4混搭. [不方便使用的东西没有市场] public cls{ public: // 缩进1空格 cls() // 缺省缩进2空格 :a_(0){} // 形参等缩进4空格 void func(){}; private: int a_ = 0; } public cls{ public: cls():a(0){}// 缺省缩进4空格 void func(){}; private: int a = 0; } 代码风格一致性很难控制, 因为只要引入了不同体系的第三方库就会受影响, 比如返回值体系依赖了使用异常的库比如opencv, 那么至少就需要对依赖库的异常进行处理转换. 所以一致性一般都会打折扣, 比如tf中很多文件已经是驼峰式下划线式大小写混杂的了, 从命名规范来说已经失去了控制, 但其实对可读性的影响也不是特别大. 观点 规范迁移, 代码规范应该吸取google规范的精华, 同时结合自身情况补充项目内部的规范要求. 所有的规范都有例外,除了特殊情况, 很少完全强制或者百分百禁用. 代码一致性包含全局一致性与局部一致性, 风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也打乱读者在阅读代码时的节奏, 所以要尽量避免. 规范需要靠自觉遵循, 因为没有实现标准化质量控制机制, 简单的规则可以让大家容易遵循但实践中可能会难以控制. 一致性要求需要进行体系控制, 一旦使用了某一个体系就不方便再引入另外一个体系, 但是实践上, 大部分时候会混用在一起, 变成主要地位与次要地位的局面：原生指针与智能指针, 异常体系与返回值体系, 引用体系与移动体系, 模板与非模板体系. 相较于紧凑型规范, 本规范倾向为简单且易于实施的标准型规范. 规范 最重要的： 代码尽可能使用简单的特性, 避免复杂的特性及操作. 尽可能一目了然, 段落分明. 尽可能采用标准库及通用化实施方式. 尽可能引入编译器检查及自动内存管理. 模式语义尽可能统一, 避免歧义. 尽可能进行文档化注释. 尽可能编写简短, 凝练的函数. 无论是否是脚本语言, 代码应尽可能进行函数式编程, 有利于代码解耦复用. 代码风格 同一文件内应该保持统一风格, 新项目采用新规范, 旧项目保持旧风格. 本规范主次关系应该为(前主后次)：智能指针>原生指针, 异常体系>返回值体系, 引用体系>移动体系, 非模板体系>模板体系. 尽可能以智能指针为主, 但智能指针不能完全代替原生指针,只能作为自动内存管理的补充 异常体系是缺省的更好的选择 引用体系较为简单, 移动体系及移动操作注意事项更多 非模板体系可读性可维护性更友好,除非是开源项目 #define保护 (C++20模块还未普及之前) 所有头文件都应该使用 #define 来防止头文件被多重包含 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径/命名空间中的全路径 #pragma once是依赖MSVC编译器的, 不必使用 从保持良好开发习惯的角度, 应该进行防御性编码,例如使用assert对入参进行校验. 编码应尽可能采用跨平台实现, 优先使用标准库提供的方法,比如文件读取使用std::ifstream替换fread fopen, 使用std::thread替换一般的Thread等等 目前C++20还不成熟, 语言标准指定到C++17即可, 需要注意有的嵌入式设备平台编译器只能支持到C++14. 除非必要, 尽量不要使用模板编程,模板编程有时候能够实现更简洁更易用的接口,但是容易引起维护灾难, 可读性容易崩塌. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间.类的静态方法应当和类的实例或静态数据紧密相关 //应当使用 namespace myproject { namespace foo_bar { void Function1(); void Function2(); } // namespace foo_bar } // namespace myproject //而非 namespace myproject { class FooBar { public: static void Function1(); static void Function2(); }; }// namespace myproject 使用#include包含需要的头文件即可,尽量避免前置声明那些定义在其他项目中的实体,因为前置声明隐藏了依赖关系, 编辑器也不好直接定位到定义. 函数内必要的水平留白可以增加可读性 回调在内部尽可能用std::function实现及接收, 如果是原始函数指针, 将难以接受其他函数类型对象．例如lambda,仿函数等等. 提交git前需要进行标准格式化, 使用vscode默认自动格式化方法即可(ctrl+shift+i全文件,ctrl+k+f格式化选中部分, ctrl+k+x去除尾随空格), android studio有Ctrl+Alt+L全文件等 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖, 构建会更快终止 路径尽可能采用全路径 头文件包含顺序应从最特殊到一般,如： #include \"通用头文件\" #include \"源文件同名头文件\" #include \"本模块其他头文件\" #include \"自定义工具头文件\" #include \"第三方头文件\" #include \"平台相关头文件\" #include \"C++库头文件\" #include \"C库头文件\" 命名空间 在命名空间的最后注释出命名空间的名字,宏也需要namespace mynamespace { } // namespace mynamespace 尽量不要使用内联命名空间inline namespace(违背唯一定义原则)// 这样可以通过a::c来调用,不建议 namespace a { inline namespace b { int c=0; }// namespace b } // namespace a 头文件内不要使用using 引入整个命名空间的标识符号,会污染命名空间, 源文件内可放松,// 头文件内不要这么使用 using namespace foo; // 头文件内应该完整引用命名空间 std::string str; 鼓励在 .cpp 文件内使用匿名命名空间或 static 声明,[作用域按需扩大], 对于不需要在其他地方引用的标识符使用内部链接性声明, 但是不要在 .h 中使用. 将函数变量尽可能置于[最小作用域]内, 离第一次使用越近越好, 并在变量声明时进行初始化. 构造与析构函数 构造函数只负责简单的初始化工作, 不在构造函数中做太多逻辑相关的初始化, 更多操作放在init()方法中,析构同理, 主要操作放到release()方法中,复杂初始化操作需要进行二段构造 隐式类型转换 对于转换运算符和单参数构造函数, 使用explicit关键字,以避免可能的歧义. class clsstr // 使用关键字explicit的类声明, 显示转换 { public: char *_pstr; int _size; explicit clsstr(int size) { _size = size; } clsstr(const char *p) { _pstr = p; } }; // 下面是调用: clsstr string1(24); // 这样是OK的 clsstr string4(\"aaaa\"); // 这样是OK的 clsstr string5 = \"bbb\"; // 这样也是OK的, 调用的是clsstr(const char *p) clsstr string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 clsstr string3; // 这样是不行的, 因为没有默认构造函数 clsstr string6 = 'c'; // 这样是不行的, 其实调用的是clsstr(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 结构体和类 所有结构体和类尽可能提供默认构造函数,特别的, 如果定义了有参构造, 就需要手动提供默认构造并提供初始化方法, 否则引用声明初始化时会带来各种不便. [代码健壮性更好] 组合和继承 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. is关系时继承, has关系时组合 如果基类有虚函数, 则析构函数也应为虚函数, 因为引入了虚函数表机制, 子类向上转型到父类, 调用析构如果父类的析构声明不是虚函数, 将析构不到子类本身. 对于子类重载的虚函数或虚析构函数, 使用 override, 或 (较不常用的) final 关键字显式地进行标记[引入编译器检查] 运算符重载 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 不会同时返回 true.重载同类运算符代码健壮性更好 存取控制 所有 数据成员声明为 private, [按需扩大作用域] 通过set/get方法访问(可以直接定义在头文件中)[单例模式, 读写访问控制] 声明顺序 在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 析构函数,重载运算符,set/get方法, 其它函数, 数据成员. 类定义可以采用多修饰符public: 将类似的声明分段, [有利于增强可读性] 参数及其顺序 入参在前, 出参在后 如果入参/出参参数很多, 多参数传递应该构造为结构体传入, 因为可以解耦, 未来扩展不需要一层层改API, 并且更方便按需和相关服务句柄绑定,[代码健壮性更好] 指针指向的对象如果含有结构应该进行结构化处理[一目了然] 所有按引用传递的参数必须加上const,缺省输出参数为指针,输出应该要允许传递nullptr, 表示不接收某个输出参数, 除非要求出参必须不能为nullptr(比如单个出参的情况）可以考虑使用非const引用 所有权与智能指针 动态分配出的对象最好有单一且固定的管理对象, 并通过智能指针传递所有权. 局部作用域中要求临时对象优先采用智能内存管理方式. [代码健壮性更好] // 可以移动, 不能复制 std::unique_ptr ptr(new cls()); // 可以自定义析构方法 std::unique_ptr> ptr(new cls(), [](cls* p){delete p;}); // 优先使用自动字符数组而不是原始指针 std::vector buffer(10); std::unique_ptr buffer(new char[10]); 运行时类型识别 普通项目除非必要,禁止使用RTTI. 不要使用较复杂的特性, 不利于协作 (开源项目随意) 在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类. 尽可能使用STL的类型转换, 如dynamic_cast<>()等 [引入编译器检查] const及constexpr [引入编译器检查] 强烈建议在任何可能的情况下都要使用const修饰函数变量. 此外有时改用 C++11 推出的 constexpr 更好. const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. const 的位置: 实际上int const *foo形式语义更标准, 但是也有很多人习惯const int* foo 编译时可以确定的常量用constexpr修饰 指针初始化 使用更安全不会引起歧义的nullptr而不是NULL [兼容性更好] 列表初始化 类型及对象的初始化尽可能使用{}进行初始化 [代码一致性更好且引入编译器检查] //列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误. int pi(3.14); // ok , pi == 3. int pi{3.14}; // 编译错误: 缩窄转换. 预处理宏 [尽可能缩小作用域] 使用宏时要非常谨慎,除非必要,尽量以内联函数, 枚举和常量代替之. 不要在 .h 文件中定义宏.因为宏作用于全局作用域 在马上要使用时才进行 #define, 使用后要立即 #undef. auto 可以绕过烦琐的类型名, 增强可读性, 但是别用在局部变量之外的地方. [可读性更好] Lambda 表达式 适当使用 lambda 表达式. 建议所有捕获都显式写出来, 并且显式指定返回类型. [一目了然]std::sort(v.begin(), v.end(), [](int x, int y) -> bool { return Weight(x) std::functions和std::bind可以搭配成通用回调机制[兼容性更好] 如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数 [可读性优化]： // 表达式拆开, 中间过程用具有意义的变量标识或者直接添加注释 int my_heuristic = scores[x] * y + bases[x]; bool retval = DoSomething(my_heuristic, x, y, z); 规范动态内存的管理, 统一为new delete组合 [代码一致性] 命名约定 根据上文所述, google命名规则较为复杂, 不合理且不利于实施, 故而总结使用基于小写下划线的蛇形风格,相较于驼峰式, 视觉一致性更佳,并且风格与标准库和谐统一. 虽然现代编译器都能悬停显示对象类型, 但是变量名如果能多一些类型描述符, 就不必经常悬停, 一目了然可读性更高一些, 所以有必要这么处理： 使用后缀标识来标识类类型 使用前缀+下划线标识私有变量 使用下划线+后缀标识文件名, 命名空间, 结构体, 类, 枚举等类型 使用下划线+方法标识私有方法(正常x_{}用于表变量，_{}表方法就有不可达的意思) 使用后置下划线标识临时变量(正常{}_x用于表类型，{}_表变量就有用完即弃的意思) 全小写下划线, 通过前后缀补充描述 各类文件的缩进全部缺省4空格 结构体的公开成员不使用前置下划线 宏命名 大写下划线 数组及指针相关需要明确类型 类型 前后缀 接口 {}_i interface 实现 {}_impl implementation 枚举 {}_e enumeration 结构体/类 {}_t class/struct/union 回调 {}_cb callback 组件 {}_cp component 组件实现/操作 {}_op opperation 函数指针 {}_fn function 命名空间 {}_ns namespace 临时变量 {}_ local 私有变量/方法 _{} private 成员 m_{} member 指针 p_{} pointer 注释及代码文档化 代码70%的时间是用来阅读的, 所以必要的文档化很有必要(对于非开源项目, 完整文档化需要做更多事情, 做到必要文档化即可) 我们推崇代码既文档+代码文档化, 代码既文档依然需要去细看代码, 而文档化之后, 其他人接手可以不必细看代码, 直接看注释辅助代码, 阅读速度可以提升几倍. 头文件都需要进行必要的文档化 文档化采用doxygen风格(支持主流语言), 参考doxygen文档 文档注释主要在头文件进行, 不要描述显而易见的现象 注释对齐有更好的可读性, 建议在行尾空两格进行注释 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显. 函数声明处的注释描述函数功能; 定义处的注释描述函数实现.通常, 注释不会描述函数如何工作. 那是函数定义部分的事情. 每个类数据成员（也叫实例变量或成员变量) 都应该用必要注释说明用途 特殊注释 标记一些未完成的或完成的不尽如人意的地方 使用TODO注释. 有问题的代码用FIXME注释 问题大或急的话直接提缺陷, 不急的先注释标记在代码里面,在vscode中会被高亮:// TODO(ipanda-2020.08.26) 更好的解决方案是 // FIXME(ipanda-2020.08.26) 有个什么bug 弃用注释 声明时未被弃用的名字可被重声明为deprecated,而声明为deprecated的名字不能通过重声明变为未弃用. 使用了标注为弃用的方法, 会有编译警告, 下列名字或实体的声明中允许使用这个属性: class/struct/union： struct [[deprecated(\"Replaced by bar\")]] S{}; typedef/using： [[deprecated]] typedef S PS; using PS [[deprecated]] = S; 变量,包括静态数据成员：[[deprecated]] int x; 非静态数据成员：union U { [[deprecated]] int n; }; 函数：[[deprecated]] void f(); 命名空间：namespace [[deprecated]] NS { int x; } 枚举：enum [[deprecated]] E {}; 枚举项：enum { A [[deprecated]], B [[deprecated]] = 42 }; 模板特化：template struct [[deprecated]] X{}; 扩展 自动化检查 可以借鉴Cpplint, 使用 cpplint.py 检查风格错误.但是目前它是不完善的, google本身很多规范都检查不了. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错. python cpplint.py motion_detector.h motion_detector.h:0: No copyright message found. You should have a line: \"Copyright [year] \" [legal/copyright] [5] motion_detector.h:1: #ifndef header guard has wrong style, please use: CPP_LIB_ALGO_SRC_MOTION_DETECTOR_H_ [build/header_guard] [5] motion_detector.h:160: #endif line should be \"#endif // CPP_LIB_ALGO_SRC_MOTION_DETECTOR_H_\" [build/header_guard] [5] motion_detector.h:4: is an unapproved C++11 header. [build/c++11] [5] motion_detector.h:5: Found C system header after C++ system header. Should be: motion_detector.h, c system, c++ system, other. [build/include_order] [4] motion_detector.h:72: At least two spaces is best between code and comments [whitespace/comments] [2] motion_detector.h:75: Lines should be for vector<> [build/include_what_you_use] [4] Done processing motion_detector.h Doxygen文档 /** * 多行注释 */ /**单行注释*/ 或 /// 或 //! (Doxygen认为注释是修饰接下来的程序代码的) /** guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:00 "},"posts/设计模式.html":{"url":"posts/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 Design patterns [toc] 面向对象设计原则 单一职责原则(Single Responsibility Principle)) 开闭原则(Open/closed Principle)) 里氏替换原则(Liskov Substitution Principle)) 接口隔离原则(Interface Segregation Principle)) 依赖倒置原则(Dependency Inversion Principle)) 合成复用原则(Composite Reuse Principle)) 迪米特法则(Law of Demeter)) 创建型模式 单例模式(Singleton)) 工厂方法模式(Factory Method)) 抽象工厂模式(Abstract Factory)) 生成器模式(Builder)) 原型模式(Prototype)) 结构型模式 适配器模式(Adapter)) 桥接模式(Bridge)) 组合模式(Composite)) 装饰模式(Decorator)) 外观模式(Facade)) 享元模式(Flyweight)) 代理模式(Proxy)) 行为型模式 责任链模式(Chain of Responsibility)) 命令模式(Command)) 迭代器模式(Iterator)) 中介者模式(Mediator)) 备忘录模式(Memento)) 观察者模式(Observer)) 状态模式(State)) 策略模式(Strategy)) 模板方法模式(Template Method)) 访问者模式(Vistor)) 模板编程特殊设计模式 奇异递归模板模式(Curiously Recurring Template Pattern)) 扩展 面向对象设计原则 单一职责原则(Single Responsibility Principle) 尽量让每个类只负责软件中的一个功能, 并将该功能完全封装在该类中. 开闭原则(Open/closed Principle) 对于扩展, 类应该是“开放”的；对于修改, 类则应是“封闭”的. 里氏替换原则(Liskov Substitution Principle) 扩展一个类时, 要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递. 这意味着子类必须保持与父类行为的兼容. 接口隔离原则(Interface Segregation Principle) 客户端不应被强迫依赖于其不使用的方法. 尽量缩小接口的范围, 使得客户端的类不必实现其不需要的行为. 依赖倒置原则(Dependency Inversion Principle) 高层次的类不应该依赖于低层次的类. 两者都应该依赖于抽象接口. 抽象接口不应依赖于具体实现. 具体实现应该依赖于抽象接口. 合成复用原则(Composite Reuse Principle) 尽量使用对象组合,而不是继承来达到复用的目的. 迪米特法则(Law of Demeter) 最少知识原则,一个类应当尽可能少的与其他类发生相互作用. 创建型模式 创建型模式隐藏了类的实例的创建细节, 通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的. 简单工厂：一个工厂, 通过产品类型创建不同产品 工厂方法：每个产品一个工厂 抽象工厂：每个产品族一个工厂 单例模式(Singleton) 保证一个类只有一个实例, 并提供一个访问该实例的全局节点. %accordion% 单例模式.cpp %accordion% // 最简单高效的单例模式模板类 template class singleton_t{ protected: singleton_t() = default; ~singleton_t() = default; private: singleton_t(const singleton_t &) = delete; singleton_t(singleton_t &&) = delete; singleton_t& operator=(const singleton_t &) = delete; singleton_t& operator=(singleton_t &&) =delete; public: static T& get_instance(){ static T _instance; // 默认静态变量初始化是线程安全的 return _instance; } }; namespace { class _work_t{ public: void set(std::string name){ m_name = name; } std::string& get(){ return m_name; } private: std::string m_name; }; } // namespace // 仅导出单例实现 using work_t = singleton_t; int main(){ work_t::get_instance().set(\"1\"); std::cout %/accordion% %accordion% 单例模式.go %accordion% package singleton type singleton map[string]string var ( once sync.Once instance singleton ) func New() singleton { once.Do(func() { instance = make(singleton) }) return instance } func main(){ s := singleton.New() s[\"this\"] = \"that\" s2 := singleton.New() fmt.Println(\"This is \", s2[\"this\"]) // This is that } %/accordion% 工厂方法模式(Factory Method) 在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型. %accordion% 工厂方法模式 %accordion% // 抽象工厂类 生产电影 class factory_i { public: virtual std::shared_ptr get_movie() = 0; }; // 具体工厂类 中国生产者 class chinese_producer_t : public factory_i { public: std::shared_ptr get_movie() override { return std::make_shared(); } }; // 抽象产品类 电影 class movie_i { public: virtual std::string get_a_movie() = 0; }; // 具体产品类 电影::国产电影 class chinese_movie_t : public movie_i { public: std::string get_a_movie() override { return \"《让子弹飞》\"; } }; int main() { std::shared_ptr factory; std::shared_ptr product; ​ // 选择创建者的类型 factory = std::make_shared(); product = factory->get_movie(); std::cout get_a_movie() %/accordion% 抽象工厂模式(Abstract Factory) 让你能创建一系列相关的对象, 而无需指定其具体类. %accordion% 抽象工厂模式 %accordion% // 抽象工厂类 生产电影和书籍类等 class factory_i { public: virtual std::shared_ptr product_movie() = 0; virtual std::shared_ptr product_book() = 0; }; // 具体工厂类 中国生产者 class chinese_producer_t : public factory_i { public: std::shared_ptr product_movie() override { return std::make_shared(); } ​ std::shared_ptr product_book() override { return std::make_shared(); } }; // 抽象产品类 电影 class movie_i { public: virtual std::string name() = 0; }; ​ // 抽象产品类 书籍 class book_i { public: virtual std::string name() = 0; }; // 具体产品类 电影::国产电影 class chinese_movie_t : public movie_i { std::string name() override { return \"《让子弹飞》\"; } }; // 具体产品类 书籍::国产书籍 class chinese_book_t : public book_i { std::string name() override { return \"《三国演义》\"; } }; ​ int main() { std::shared_ptr factory; // 选择创建者的类型 factory = std::make_shared(); std::shared_ptr movie; std::shared_ptr book; movie = factory->product_movie(); book = factory->product_book(); std::cout name() name() %/accordion% 生成器模式(Builder) 使你能够分步骤创建复杂对象. 该模式允许你使用相同的创建代码生成不同类型和形式的对象. %accordion% 生成器模式 %accordion% // 产品类 车 class car_t { public: void set_car_tire(std::string t) { m_tire = t; std::cout build_tire(); m_builder->build_engine(); return m_builder->get_car(); } private: car_builder_i* m_builder; }; int main() { // 抽象建造者(一般是动态确定的) car_builder_i* builder; // 指挥者 director_t* director = new director_t(); // 产品 car_t car; ​ // 建造奔驰 std::cout set_builder(builder); car = director->construct_car(); delete builder; std::cout %/accordion% 原型模式(Prototype) 让你能够复制已有对象, 而又无需使代码依赖它们所属的类. %accordion% 原型模式 %accordion% // 抽象原型类 class object_i { public: virtual object_i* clone() = 0; }; ​ // 邮件的附件 class attachment_t { public: void set_content(std::string content) { m_content = content; } std::string get_content() { return content; }​ private: std::string m_content; }; // 具体原型: 邮件类 class email_t : public object_i { public: email_t(){} email_t(std::string text, std::string attachment_content) : m_text(text), m_attachment(new attachment_t()) { m_attachment->set_content(attachment_content); } ~email_t() { delete m_attachment; } void display() { std::cout get_content() m_text, this->m_attachment->get_content()); } void set_text(std::string new_text) { m_text = new_text; } void set_attachment(std::string content) { m_attachment->set_content(content); } private: std::string m_text; attachment_t *m_attachment; }; int main() { email_t* email = new email_t(\"最初的文案\", \"最初的附件\"); email_t* copy_email = email->clone(); copy_email->set_text(\"新文案\"); copy_email->set_attachment(\"新附件\"); std::cout display(); std::cout display(); delete email; delete copy_email; } %/accordion% 结构型模式 结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构, 就像搭积木, 可以通过简单积木的组合形成复杂的、功能更为强大的结构. 结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式：关心类的组合, 由多个类可以组合成一个更大的系统, 在类结构型模式中一般只存在继承关系和实现关系. 对象结构型模式：关心类与对象的组合, 通过关联关系使得在一 个类中定义另一个类的实例对象, 然后通过该对象调用其方法. 根据“合成复用原则”, 在系统中尽量使用关联关系来替代继承关系, 因此大部分结构型模式都是对象结构型模式. 适配器模式(Adapter) 让接口不兼容的对象能够相互合作. %accordion% 适配器模式 %accordion% // 客户端接口 class target_i { public: virtual ~target_t() = default; virtual std::string request() const { return \"default target's behavior.\"; } }; // 适配者 class adaptee_t { public: std::string specific_request() const { return \".eetpadA eht fo roivaheb laiceps\"; } }; // 适配器 class adapter_t : public target_i { public: adapter_t(adaptee_t* adaptee) : adaptee_t(adaptee) {} std::string request() const override { std::string to_reverse = this->adaptee_->specific_request(); std::reverse(to_reverse.begin(), to_reverse.end()); return \"adapter: (TRANSLATED) \" + to_reverse; } private: adaptee_t* m_adaptee; }; // 客户端方法 void client_code(const target_i* target) { std::cout request() specific_request(); adapter_t* adapter = new adapter_t(adaptee); client_code(adapter); delete target; delete adaptee; delete adapter; } %/accordion% 桥接模式(Bridge) 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构, 从而能在开发时分别使用. %accordion% 桥接模式 %accordion% // 抽象类 class pen_i { public: virtual void draw(std::string name) = 0; void set_color(color_t* color) { m_color = color; } ​protected: color_t* m_color; }; // 实现类 class big_pen_t : public pen_i { public: void draw(std::string name) { std::string pen_type = \"大号钢笔绘制\"; m_color->bepaint(pen_type, name); } }; // 抽象类 class color_i { public: virtual void bepaint(std::string pen_type, std::string name) = 0; }; // 实现类 class red_t : public color_i { public: void bepaint(std::string pen_type, std::string name) override { std::cout set_color(color); pen->draw(\"太阳\"); ​ delete color; delete pen; } %/accordion% 组合模式(Composite) 你可以使用它将对象组合成树状结构, 并且能像使用独立对象一样使用它们. %accordion% 组合模式 %accordion% // 抽象基类声明组合中的通用操作 class graphic_i { public: virtual void move(int x, int y) = 0; virtual void draw() = 0; }; // 点 class dot_t : public graphic_i { public: dot_t(int x, int y) : m_x(x), m_y(y) {} void move(int x, int y) override { m_x += x; m_y += y; } void draw() override { printf(\"在(%d,%d)处绘制点\\n\", m_x, m_y); } private: int m_x,m_y; }; // 圆 class circle_t : public graphic_i { public: explicit circle_t(int r, int x, int y) : m_radius(r), m_x(x), m_y(y) {} void move(int x, int y) override { m_x += x; m_y += y; } void draw() override { printf(\"以(%d,%d)为圆心绘制半径为%d的圆\\n\",m_x,m_y,m_radius); } ​private: int m_x,m_y,m_radius; }; // 组件操作 class graphic_cp : public graphic_i { public: void add(int id, graphic_i* child) { m_map[id] = child; } void remove(int id) { m_map.erase(id); } void move(int x, int y) override { for (auto [k,v] : m_map){ v->move(x, y); } } void draw() override { for (auto [k,v] : m_map){ v->draw(x, y); } } ​private: // key是图表id, value是图表指针 std::map m_map; }; int main() { // 组合图 graphic_cp* all = new graphic_cp(); ​ // 添加子图 dot_t* dot1 = new dot_t(1, 2); circle_t *circle = new circle_t(5, 2, 2); graphic_cp* child_graph = new graphic_cp(); dot_t* dot2 = new dot_t(4, 7); dot_t* dot3 = new dot_t(3, 2); child_graph->add(0, dot2); child_graph->add(1, dot3); ​ // 将所有图添加到组合图中 all->add(0, dot1); all->add(1, circle); all->add(2, child_graph); // 绘制 all->draw(); ​ delete all; delete dot1; delete dot2; delete dot3; delete circle; } %/accordion% 装饰模式(Decorator) 允许你将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为. %accordion% 装饰模式 %accordion% // 具体组件和装饰类的共同基类 class data_source_i { public: virtual void write(std::string data) = 0; }; // 具体组件 ​class file_source_t : public data_source_i { public: explicit file_source_t(std::string file_name) : m_fname(file_name) {} void write(std::string data) override { printf(\"写入文件%s中: %s\\n\", m_fname.c_str(), data.c_str()); } ​private: std::string m_fname; }; // 装饰类 class data_source_decorator_cp : public data_source_i { public: explicit data_source_decorator_cp(data_source_i* ds) : m_ds(ds) {} void write(std::string data) override { m_ds->write(data); } ​protected: data_source_i* m_ds; // component }; // 加密装饰器 class encryption_decorator_op : public data_source_decorator_cp { public: using data_source_decorator_cp::data_source_decorator_cp; void write(std::string data) override { data = \"已加密(\" + data + \")\"; m_ds->write(data); } }; // 压缩装饰器 class compression_decorator_op : public data_source_decorator_cp { public: using data_source_decorator_cp::data_source_decorator_cp; void write(std::string data) override { data = \"已压缩(\" + data + \")\"; m_ds->write(data); } }; int main() { file_source_t* source1 = new file_source_t(\"stdout\"); // 将明码数据写入目标文件 source1->write(\"testdata\"); ​ // 将压缩数据写入目标文件 compression_decorator_op* source2 = new compression_decorator_op(source1); source2->write(\"testdata\"); ​ // 将压缩且加密数据写入目标文件 encryption_decorator_op* source3 = new encryption_decorator_op(source2); source3->write(\"testdata\"); ​ delete source1; delete source2; delete source3; } %/accordion% 外观模式(Facade) 能为程序库、框架或其他复杂类提供一个简单的接口. %accordion% 外观模式 %accordion% class computer_t { public: computer_t() { m_mem = new memory_t(); m_proc = new processor_t(); m_hd = new hard_disk_t(); m_os = new os_t(); } ~computer_t() { delete m_mem; delete m_proc; delete m_hd; delete m_os; m_mem = nullptr; m_proc = nullptr; m_hd = nullptr; m_os = nullptr; } ​ void power_on() { std::cout self_check(); m_proc->run(); m_hd->read(); m_os->load(); std::cout power_on(); delete c; } %/accordion% 享元模式(Flyweight) 摒弃了在每个对象中保存所有数据的方式, 通过共享多个对象所共有的相同状态, 让你能在优先的内存容量中载入更多对象. %accordion% 享元模式 %accordion% // 享元类 树木类型是固定的可以通过指针共享给大量树 class tree_type_t { public: tree_type_t(std::string n, std::string c, std::string t) : m_name(n), m_color(c), m_texture(t) {} void draw(std::string canvas, double x, double y) { // 创建特定类型、颜色和纹理的位图 // 在画布坐标(x,y)处绘制位图 } ​private: std::string m_name; std::string m_color; std::string m_texture; }; // 享者 坐标随机独有, 但引用树的类型数据会大量重复 class tree_t { public: tree_t(double x, double y, tree_type_t* t) : m_x(x), m_y(y), m_t(t) {} void draw(std::string canvas) { return m_t->draw(canvas, m_x, m_y); } ​private: double m_x; double m_y; tree_type_t* m_t; }; // 享元工厂: 共享数据缓存, 应该是单例类 namespace detail_ns{ class tree_factory_t { public: tree_type_t* get_tree_type(std::string name, std::string color, std::string texture) { std::string key = name + \"_\" + color + \"_\" + texture; auto iter = mp_tree_type.find(key); if (iter == mp_tree_type.end()) { // 新的tree type tree_type_t* new_tree_type = new tree_type_t(name, color, texture); mp_tree_type[key] = new_tree_type; return new_tree_type; } else { // 已存在的tree type return iter->second; } } ​private: // 共享池, 其中key格式为name_color_texture std::map mp_tree_type; }; } // namespace detail_ns // 包装为单例类(见模板单例类) using tree_factory_t = singleton_t; // forest_t包含数量及其庞大的tree_t class forest_t { public: void plan_tree(double x, double y, std::string name, std::string color, std::string texture) { tree_type_t* type = tree_factory_t::get_instance().get_tree_type(name, color, texture); tree_t tree = tree_t(x, y, type); m_trees.push_back(tree); } void draw() { for (auto tree : m_trees) { tree.draw(\"canvas\"); } } ​private: std::vector m_trees; }; int main() { forest_t* forest = new forest_t(); // 在forest中种植很多棵树 for (int i = 0; i plan_tree(x, y, \"杉树\", \"红色\", \"\"); // 树类型2: 绿色的榕树 forest->plan_tree(x, y, \"榕树\", \"绿色\", \"\"); // 树类型3: 白色的桦树 forest->plan_tree(x, y, \"桦树\", \"白色\", \"\"); } } forest->draw(); delete forest; } %/accordion% 代理模式(Proxy) 让你能够提供对象的替代品或其占位符. 代理控制着对于原对象的访问, 并允许在将请求提交给对象前后进行一些处理. %accordion% 代理模式 %accordion% // 远程服务接口 class video_lib_i { public: virtual std::string get_video_list() = 0;//略缩图列表 virtual std::string get_video_info(int id) = 0;//视频页面 }; // 服务类(请求) class pull_video_t : public video_lib_i { public: std::string get_video_list() override { // 向远程视频后端服务发送一个API请求 return \"video list\"; } ​ std::string get_video_info(int id) override { // 向远程视频后端服务发送一个API请求 return \"video info\"; } }; // 代理类(缓存) ​class video_cache_t : public video_lib_i { public: explicit video_cache_t(video_lib_i* service) : mp_service(service), m_need_reset(false), m_list_cache(\"\"), m_video_cache(\"\") {} void reset() { m_need_reset = true; } ​ std::string get_video_list() override { if (m_list_cache == \"\" || m_need_reset) { m_list_cache = mp_service->get_video_list(); } return m_list_cache; } ​ std::string get_video_info(int id) override { if (m_video_cache == \"\" || m_need_reset) { m_video_cache = mp_service->get_video_info(id); } return m_video_cache; } ​private: video_lib_i* mp_service; std::string m_list_cache; std::string m_video_cache; bool m_need_reset; }; // 管理代理类(渲染) class video_manager_t { public: explicit video_manager_t(video_lib_i* s) : mp_service(s) {} void render_video_page(int id) { std::string video_info = mp_service->get_video_info(id); // 渲染视频页面, 这里忽略实现 printf(\"渲染视频页面: %s\\n\", video_info.c_str()); } void render_list_panel() { std::string video_list = mp_service->get_video_list(); // 渲染视频缩略图列表, 这里忽略实现 printf(\"渲染视频缩略图列表: %s\\n\", videos.c_str()); } ​private: video_lib_i* mp_service; }; int main() { pull_video_t* p_service = new pull_video_t(); video_cache_t* p_cache_proxy = new video_cache_t(p_service); video_manager_t* p_manager = new video_manager_t(p_cache_proxy); ​ p_manager->render_video_page(1); p_manager->render_list_panel(); ​ delete p_service; delete p_cache_proxy; delete p_manager; } %/accordion% 行为型模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化. 行为型模式不仅仅关注类和对象的结构, 而且重点关注它们之间的相互作用. 行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为, 类行为型模式主要通过多态等方式来分配父类与子类的职责. 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为, 对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责. 根据“合成复用原则”, 系统中要尽量使用关联关系来取代继承关系, 因此大部分行为型设计模式都属于对象行为型设计模式. 责任链模式(Chain of Responsibility) 允许你将请求沿着处理者链进行发送. 收到请求后, 每个处理者可对请求进行处理, 或将其传递给链上的下个处理者. %accordion% 责任链模式 %accordion% // 员工申请处理票据需要上报给上级, 如果上级无权处理就上报给更高的上级 // 抽象处理者 class handler_i { public: // 添加上级 virtual void set_superior(handler_i* superior) = 0; // 处理票据申请, 参数是票据面额 virtual void handle_request(double amount) = 0; }; class base_handler_t : public handler_i { public: base_handler_t(double mpa, std::string n) : m_max_processible_amount(mpa), m_name(n), mp_superior(nullptr) {} // 设置上级 void set_superior(handler_i* superior) override { m_superior = superior; } // 处理票据 void handle_request(double amount) { // 可处理时直接处理即可 if (amount handle_request(amount); return; } // 最上级依然无法处理时报错 printf(\"无人有权限处理该票据, 票据金额:%f\\n\", m_name.c_str(), amount); } ​private: double m_max_processible_amount; // 可处理的最大面额 std::string m_name; handler_i* mp_superior; }; // 具体处理者: 组长(仅处理面额set_superior(p_manager); p_manager->setSuperior(p_boss); ​ // 不同面额的票据统一先交给组长审批（ p_group_leader->handle_request(8); p_group_leader->handle_request(88); p_group_leader->handle_request(888); p_group_leader->handle_request(8888); ​ delete p_group_leader; delete p_manager; delete p_boss; } %/accordion% 命令模式(Command) 它可将请求转换为一个包含与请求相关的所有信息的独立对象. 该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中, 且能实现可撤销操作. %accordion% 命令模式 %accordion% // 用遥控器(Controller)控制电视(TV) // 命令接口 class command_t { public: virtual void execute() = 0; }; // 触发者: 遥控器 class controller_t{ public: // 设置命令 void set_command(std::shared_ptr cmd) { m_cmd = cmd; } // 执行命令 void execute_command() { m_cmd->execute(); } ​private: std::shared_ptr m_cmd; }; ​// 具体命令类: 打开电视 class cmd_tv_open_t : public command_t{ public: explicit cmd_tv_open_t(std::shared_ptr tv) : m_tv(tv) {} void execute() override { tv_->open(); } ​private: std::shared_ptr m_tv; }; // 接受者: 电视 class tv_t{ public: void open() { std::cout tv = std::make_shared(); std::shared_ptr controller = std::make_shared(); std::shared_ptr open_cmd = std::make_shared(tv); ​ controller->setCommand(open_cmd); controller->executeCommand(); } %/accordion% 迭代器模式(Iterator) 让你能在不暴露集合底层表现形式(列表、栈和树等)的情况下遍历集合中所有的元素. %accordion% 迭代器模式 %accordion% // 抽象迭代器 class tv_iterator_i{ public: virtual void set_channel(int i) = 0; virtual void next() = 0; virtual void prev() = 0; virtual bool is_end() = 0; virtual std::string cur() = 0; virtual bool is_begin() = 0; }; ​ // 具体迭代器 class abc_iter_t : public tv_iterator_i{ public: explicit abc_iter_t(std::vector &tvs) : m_tvs(tvs) {} void next() override { if (m_cur 0) { m_cur--; } } void set_channel(int i) override { m_cur = i; } std::string cur() override { return m_tvs[m_cur]; } bool is_end() override { return m_cur == m_tvs.size(); } bool is_begin() override { return m_cur == 0; } ​private: std::vector &m_tvs; int m_cur = 0; }; // 抽象电视机 class tv_i { public: virtual std::shared_ptr create_iterator() = 0; }; // 具体电视机 class abc_tv_t : public tv_i { public: std::shared_ptr create_iterator() override{ return std::make_shared(m_tvs); } void add(std::string item) { m_tvs.push_back(item); } private: std::vector m_tvs; }; int main() { abc_tv_t abc; abc.add(\"CCTV-1\"); abc.add(\"CCTV-2\"); abc.add(\"CCTV-3\"); abc.add(\"CCTV-4\"); abc.add(\"CCTV-5\"); ​ auto iter = abc.create_iterator(); while (!iter->is_end()) { std::cout cur() next(); } } %/accordion% 中介者模式(Mediator) 能让你减少对象之间混乱无序的依赖关系. 该模式会限制对象之间的直接交互, 迫使它们通过一个中介者对象进行合作. %accordion% 中介者模式 %accordion% enum person_e { unknown, landlord, tenant, }; // 组件基类 class colleague_i { public: void set_mediator(mediator_t *m) { mp_mediator = m; } mediator_t* get_mediator() { return mp_mediator; } void set_person_type(person_e pt) { me_person_type = pt; } person_e get_person_type() { return me_person_type; } virtual void ask()=0; virtual void answer()=0; private: mediator_t* mp_mediator; person_e me_person_type; }; ​ // 具体组件1: 房东 class landlord_t : public colleague_i { public: landlord_t() { m_name = \"unknown\"; m_price = -1; m_address = \"unknown\"; m_phone_number = \"unknown\"; set_person_type(person_e::unknown); } landlord_t(std::string name, int price, std::string address, std::string phone_number) { m_name = name; m_price = price; m_address = address; m_phone_number = phone_number; set_person_type(person_e::landlord); } void answer() override { printf(\"房东姓名:%s 房租:%d 地址:%s 电话:%s\\n\", m_name.c_str(), m_price, m_address.c_str(), m_phone_number.c_str()); } void ask() override { printf(\"房东%s查看租客信息: \\n\", m_name.c_str()); this->get_mediator()->operation(this); } private: std::string m_name; int m_price; std::string m_address; std::string m_phone_number; }; ​ // 具体组件2: 租客 class tenant_t : public colleague_i { public: tenant_t():m_name(\"unknown\") {} explicit tenant_t(std::string name) { m_name = name; set_person_type(person_e::tenant); } void ask() { printf(\"租客%s询问房东信息:\\n\", m_name.c_str()); this->get_mediator()->operation(this); } void answer() { printf(\"租客姓名: %s\\n\", m_name.c_str()); } private: std::string m_name; }; // 抽象中介者 class mediator_i { public: // 声明抽象方法 virtual void register_method(colleague_i*) = 0; // 声明抽象方法 virtual void operation(colleague_i*) = 0; }; // 具体中介类: 房产中介 class agency_t : public mediator_i { public: void register_method(colleague_i* person) override { switch (person->get_person_type()) { case person_e::landlord: m_landlords.push_back(reinterpret_cast(person)); break; case person_e::tenant: m_tenants.push_back(reinterpret_cast(person)); break; default: printf(\"wrong person\\n\"); } } ​ void operation(colleague_i* person) { switch (person->get_person_type()) { case person_e::landlord: for (auto iter : m_tenants){ iter->answer(); } break; case person_e::tenant: for (auto iter : m_landlords){ iter->answer(); } break; default: break; } } ​ private: std::vector m_landlords; std::vector m_tenants; }; int main() { // 房产中介 agency_t* p_mediator = new agency_t(); ​ landlord_t *p_l1 = new landlord_t(\"张三\", 1820, \"天津\", \"1333\"); tenant_t *p_t1 = new tenant_t(\"Zhang\"); p_mediator->register_method(p_l1); ​ p_mediator->register_method(p_t1); l1->set_mediator(p_mediator); t1->set_mediator(p_mediator); // 业务逻辑 t1->ask(); std::cout ask(); ​ delete p_mediator; delete p_l1; delete p_t1; } %/accordion% 备忘录模式(Memento) 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态. %accordion% 备忘录模式 %accordion% // 备忘录类保存编辑器的过往状态 class snapshot_t { public: snapshot_t(std::string text, int x, int y, double width) : m_text(text), m_cur_x(x), m_cur_y(y), m_selection_width(width) {} std::string& get_text() { return m_text; } int get_cur_x() { return m_cur_x; } int get_cur_y() { return m_cur_y; } double get_selection_width() { return m_selection_width; } private: const std::string m_text; const int m_cur_x; const int m_cur_y; const double m_selection_width; }; ​ // 原发器中包含了一些可能会随时间变化的重要数据 // 它还定义了在备忘录中保存自身状态的方法, 以及从备忘录中恢复状态的方法 class editor_t { public: void set_text(std::string text) { m_text = text; } void set_cursor(int x, int y) { m_cur_x = x; m_cur_y = y; } void set_selection_width(double width) { m_selection_width = width; } // 在备忘录中保存当前的状态 std::shared_ptr create_snapshot() { // 备忘录是不可变的对象, 因此原发器会将自身状态作为参数传递给备忘录的构造函数 auto res = std::make_shared(m_text, m_cur_x, m_cur_y, m_selection_width); printf(\"创建编辑器快照成功, text:%s x:%d y:%d width:%.2f\\n\", m_text.c_str(), m_cur_x, m_cur_y, m_selection_width); return res; } void resotre(std::shared_ptr p_snapshot) { m_text = p_snapshot->get_text(); m_cur_x = p_snapshot->get_cur_x(); m_cur_y = p_snapshot->get_cur_y(); m_selection_width = p_snapshot->get_selection_width(); printf(\"恢复编辑器状态成功, text:%s x:%d y:%d width:%.2f\\n\", m_text.c_str(), m_cur_x, m_cur_y, m_selection_width); } private: // 文本 std::string m_text; // 光标位置 int m_cur_x; int m_cur_y; // 当前滚动条位置 double m_selection_width; }; class command_t { public: explicit command_t(editor_t* e) : mp_editor(e) {} void make_backup() { mp_backup = mp_editor->create_snapshot(); } void undo() { if (mp_backup) { mp_editor->resotre(mp_backup); } } ​private: editor_t* mp_editor; std::shared_ptr mp_backup; }; int main() { // 创建原发器和负责人 editor_t editor; command_t command(&editor); ​ // 定义初始状态 editor.set_text(\"text1\"); editor.set_cursor(21, 34); editor.set_selection_width(3.4); ​ // 保存状态 command.make_backup(); ​ // 更改编辑器状态 editor.set_text(\"text2\"); editor.set_cursor(111, 222); editor.set_selection_width(111.222); ​ // 撤销 command.undo(); } %/accordion% 观察者模式(Observer) 允许你定义一种订阅机制, 可在对象事件发生时通知多个“观察”该对象的其他对象. %accordion% 观察者模式 %accordion% // 抽象观察者 class observer_i { public: virtual void response() = 0; }; ​ // 具体观察者: 狗 class dog_t : public observer_i { public: void response() override { std::cout response(); } } ​private: std::vector m_observers; }; int main() { // 发布者 cat_t cat; // 观察者 dog_t dog; // 添加订阅关系 cat.attach(&dog); // 发布消息 cat.cry(); } %/accordion% 状态模式(State) 让你能在一个对象的内部状态变化时改变其行为, 使其看上去就像改变了自身所属的类一样. %accordion% 状态模式 %accordion% // 论坛账号 class forum_account_t { public: explicit forum_account_t(std::string name):m_name(name),mp_state(std::make_shared(this)){}; void set_state(std::shared_ptr state) { mp_state = state; } std::shared_ptr get_state() { return mp_state; } std::string& get_name() { return m_name; } void download_file(int score){ mp_state->download_file(score); } void write_note(int score){ mp_state->write_note(score); } void reply_note(int score){ mp_state->write_note(score); } ​private: std::shared_ptr mp_state; std::string m_name; }; // 等级状态 class state_i { public: virtual void check_state() = 0; ​ void set_point(int point) { point_ = point; } int get_point() { return point_; } void set_state_name(std::string name) { m_state_name = name; } std::string get_state_name() { return m_state_name; } forum_account_t* get_account() { return mp_account; } ​ virtual void download_file(int score) { m_point -= score; check_state(); } ​ virtual void write_note(int score) { m_point += score; check_state(); } ​ virtual void reply_note(int score) { m_point += score; check_state(); } ​protected: forum_account_t* mp_account; int m_point; std::string m_state_name; }; ​ // 具体状态类: 新手 class primary_state_t : public state_i { public: explicit primary_state_t(state_i* state) { mp_account = state->get_account(); m_point = state->get_point(); m_state_name = \"新手\"; } explicit primary_state_t(forum_account_t *account) { mp_account = account; m_point = 0; m_state_name = \"新手\"; } void download_file(int score) override { printf(\"对不起, %s没有下载文件的权限!\\n\", mp_account->get_name().c_str()); } void check_state() override{ if (m_point >= 1000){ mp_account->set_state(std::make_shared(this)); } else if (m_point >= 100){ mp_account->set_state(std::make_shared(this)); } }; }; // 具体状态类: 高手 // 具体状态类: 专家 ​int main() { forum_account_t account(\"test\"); account.write_note(20); account.download_file(20); account.reply_note(100); } %/accordion% 策略模式(Strategy) 能让你定义一系列算法, 并将每种算法分别放入独立的类中, 以使算法的对象能够相互替换. %accordion% 策略模式 %accordion% // 抽象策略类: 排序 class sort_i { public: virtual void sort_vector(std::vector &arr) = 0; }; // 具体策略类: 冒泡排序 class bubble_sort_t : public sort_i { public: void sort_vector(std::vector &vi) override { // sort } }; class array_handler_t { public: void sort_vector(std::vector &arr) { return mp_sort->sort_vector(arr); } void set_sort_strategy(sort_i* sort) { mp_sort = sort; } ​private: sort_i* mp_sort; }; int main() { std::vector arr; array_handler_t ah; bubble_sort_t* p_bs = new bubble_sort_t(); ah.set_sort_strategy(p_bs); ah.sort_vector(arr); delete p_bs; } %/accordion% 模板方法模式(Template Method) 在超类中定义一个算法的框架, 允许子类在不修改结构的情况下重写算法的特定步骤. %accordion% 模板方法模式 %accordion% // 抽象类: 银行业务办理流程 class bank_op_i { public: void take_number() { std::cout process(); delete deposit; ​ // 取款 bank_op_i* withdraw = new withdraw_t(); withdraw->process(); delete withdraw; ​ // 转账 bank_op_i* transfer = new transfer_t(); transfer->process(); delete transfer; } %/accordion% 访问者模式(Vistor) 将算法与其所作用的对象隔离开来. %accordion% 访问者模式 %accordion% // 抽象访问者 class vistor_i { public: void set_name(std::string name) { m_name = name; } virtual void visit(apple_t *apple) = 0; virtual void visit(book_t *book) = 0; protected: std::string m_name; }; // 具体访问者类: 顾客 class customer_t : public vistor_i { public: void visit(apple_t *apple) { std::cout visit(this); } }; // 具体产品类: 书籍 class book_t : public product_i { public: void accept(vistor_i *vistor) override { vistor->visit(this); } }; ​// 购物车 class shopping_cart_t { public: void accept(vistor_i *vistor) { for (auto prd : m_product_list) { prd->accept(vistor); } } void add_product(product_i *product) { m_product_list.push_back(product); } void remove_product(product_i *product) { m_product_list.remove(product); } ​private: std::list m_product_list; }; int main() { book_t book; apple_t apple; shopping_cart_t basket; ​ basket.add_product(&book); basket.add_product(&apple); ​ customer_t customer; customer.set_name(\"小张\"); basket.accept(&customer); ​ saler_t saler; saler.set_name(\"小杨\"); basket.accept(&saler); } %/accordion% 模板编程特殊设计模式 奇异递归模板模式(Curiously Recurring Template Pattern) CRTP 的主要作用往往是基类需要获取一些派生类信息，或许是成员，或许是方法，或许是类型本身，再通过在基类中实现方法继承来扩展派生类本身，而且可以避免虚函数、动态分派带来的额外运行时代价的问题。比如 std::enable_shared_from_this 就是获取派生类类型本身来给派生类生成 shared_from_this 方法；而 boost::less_than_comparable 就是获取一个派生类方法 operator 来给派生类生成其它的比较运算符。 %accordion% 奇异递归模板模式 %accordion% template class ...base_i> struct cat_cp: public base_i>... { cat_cp(std::string name) : m_name{std::move(name)}, base_i>{*this}... { } std::string m_name; }; template struct eat_op { eat_op(const derive_tn &self) : m_self{self} { } void eat() { std::cout struct sleep_op { sleep_op(const derive_tn &self) : m_self{self} { } void sleep() { std::cout cat1(\"cat1\"); cat1.eat(); cat1.sleep(); } %/accordion% 扩展 awesome-design-patterns C++ CRTP简介 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-28 17:12:22 "},"posts/GitBook简明教程.html":{"url":"posts/GitBook简明教程.html","title":"GitBook简明教程","keywords":"","body":"GitBook简明教程 [toc] 安装 使用 编辑器建议 GitBook.com) Git管理 配置书籍 绑定域名 个性化配置 插件 发布到 GitHub Pages 使用actions workflow自动部署 Gitbook文档 安装 下载安装node.js 安装gitbook命令行工具 npm install gitbook-cli -g 使用 gitbook init 初始化目录 生成两个必要的文件README.md(介绍)和SUMMARY.md(结构) 编辑SUMMARY.md后可以再次执行该命令生成文件结构(2级) gitbook build编译为HTML 生成一个_book文件夹,包含静态HTML文件 文件名不能包含括号不然无法识别解析 gitbook serve启动本地web服务器 http://localhost:4000 预览电子书效果 SUMMARY.md可以通过使用 标题 或者 水平分割线 将 GitBook 分为几个不同的部分,如下所示： # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) --- * [Last part without title](part3/title.md) 编辑器建议 vscode 中安装插件Markdown Preview Enhanced所见即所得 GitBook.com GitBook.com 是一个围绕 gitbook 发行书籍的社区,于 2014 年初创,GitBook.com 提供免费和付费的服务,而且免费账户就可以享受诸多服务,包括： 1 本私有书籍 托管不限数量的公开书籍 售卖不限数量的书籍,并分享 80% 的书籍收入 不限数量的协作者 免费的在线书籍编辑器 Git管理 GitBook.com 上的每本书都使用Git来管理,使用Git提交到书籍的远程项目,当然,提交前,最好在本地使用 gitbook 预览效果. git clone https://git.gitbook.com/testuser/test.git 克隆 git commit -m \"..\" 提交 git push 推送发布 书籍地址https://git.gitbook.com/test_user/test 配置书籍 GitBook.com上的书籍,进入书籍的属性页面 可以设置,书籍主题,GitHub集成,绑定域名. GitHub上创建项目 书籍导入到GitHub上的项目 书籍目录下git remote add github https://github.com/testuser/test.git git push -u github master git push 命令中的 -u 表示将本地 master 分支的上游分支设置为github/master. git push 将推送到 github 上,而非原来的 https://git.gitbook.com/testuser/test.git 与此同时原来gitbook上的项目应该会同步拉取/显示github上的更新. 绑定域名 除了可以使用类似http://test_user.gitbooks.io/test/content/index.html地址访问用户的书籍外,还可以为每本书另外绑定域名. 只能绑定一个合法的域名,不能是域名下的某个地址. 域名服务商处为域名添加CNAME记录,指向到该书籍地址. 可以使用nslookup test.testuser.cn来验证是否解析成功. 书籍内容类似http://content.test.test_user.cn 个性化配置 gitbook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json. %accordion%本站的book.json可供参考%accordion% {\r \"title\": \"iPanda\",\r \"author\": \"Mainvooid\",\r \"description\": \"万古长空，一朝风月\",\r \"language\": \"zh-hans\",\r \"gitbook\": \"3.2.3\",\r \"styles\": {\r \"website\": \"styles/website.css\",\r \"ebook\": \"styles/ebook.css\",\r \"pdf\": \"styles/pdf.css\",\r \"mobi\": \"styles/mobi.css\",\r \"epub\": \"styles/epub.css\"\r },\r \"structure\": {\r \"readme\": \"README.md\"\r },\r \"links\": {\r \"sidebar\": {\r \"Github\": \"https://github.com/Mainvooid\"\r }\r },\r \"plugins\": [\r \"-sharing\",\r \"-search\",\r \"-lunr\",\r \"search-pro\",\r \"highlight\",\r \"livereload\",\r \"splitter\",\r \"expandable-chapters-small\",\r \"anchors\",\r \"github\",\r \"github-buttons\",\r \"donate\",\r \"sharing-plus\",\r \"anchor-navigation-ex\",\r \"favicon\",\r \"toc\",\r \"tbfed-pagefooter\",\r \"disqus\",\r \"code\",\r \"checkbox\",\r \"advanced-emoji\",\r \"klipse\",\r \"flexible-alerts\",\r \"pageview-count\",\r \"accordion\",\r \"hide-element\",\r \"codesnippet\"\r ],\r \"pluginsConfig\": {\r \"hide-element\": {\r \"elements\": [\".gitbook-link\"]\r },\r \"flexible-alerts\": {\r \"style\": \"flat\",\r \"note\": {\r \"label\": \"Note\"\r },\r \"tip\": {\r \"label\": \"Tip\"\r },\r \"warning\": {\r \"label\": \"Warning\"\r },\r \"danger\": {\r \"label\": \"Attention\"\r }\r },\r \"code\": {\r \"copyButtons\": true\r },\r \"github\": {\r \"url\": \"https://github.com/Mainvooid\"\r },\r \"github-buttons\": {\r \"buttons\": [\r {\r \"user\": \"Mainvooid\",\r \"repo\": \"Mainvooid.github.io\",\r \"type\": \"star\",\r \"size\": \"small\",\r \"count\": true\r }\r ]\r },\r \"donate\": {\r \"wechat\": \"./assets/donate-wechat.png\",\r \"alipay\": \"./assets/donate-alipay.jpg\",\r \"title\": \"\",\r \"button\": \"赞赏\",\r \"alipayText\": \"支付宝打赏\",\r \"wechatText\": \"微信打赏\"\r },\r \"disqus\": {\r \"shortName\": \"ipandar\"\r },\r \"sharing\": {\r \"douban\": false,\r \"facebook\": false,\r \"google\": false,\r \"hatenaBookmark\": false,\r \"instapaper\": false,\r \"line\": false,\r \"linkedin\": false,\r \"messenger\": false,\r \"pocket\": false,\r \"qq\": false,\r \"qzone\": false,\r \"stumbleupon\": false,\r \"twitter\": true,\r \"viber\": false,\r \"vk\": false,\r \"weibo\": true,\r \"whatsapp\": false,\r \"all\": [\r \"douban\",\r \"facebook\",\r \"google\",\r \"hatenaBookmark\",\r \"instapaper\",\r \"line\",\r \"linkedin\",\r \"messenger\",\r \"qq\",\r \"qzone\",\r \"stumbleupon\",\r \"twitter\",\r \"viber\",\r \"vk\",\r \"weibo\",\r \"whatsapp\"\r ]\r },\r \"anchor-navigation-ex\": {\r \"showLevel\": false\r },\r \"favicon\": {\r \"shortcut\": \"./assets/favicon.jpg\",\r \"bookmark\": \"./assets/favicon.jpg\",\r \"appleTouch\": \"./assets/favicon.jpg\",\r \"appleTouchMore\": {\r \"120x120\": \"./assets/favicon.jpg\",\r \"180x180\": \"./assets/favicon.jpg\"\r }\r },\r \"tbfed-pagefooter\": {\r \"copyright\":\"guobao.v@gmail.com \",\r \"modify_label\": \"最后编辑时间:\",\r \"modify_format\": \"YYYY-MM-DD HH:mm:ss\"\r }\r }\r } %/accordion% (插件accordion+codesnippet可以实现上面那样从文件读取代码并折叠) 插件 可以在npmjs.com 上搜索gitbook-plugin来查找插件 GitBook默认带有 5 个插件,highlight、search、sharing、font-settings、livereload,如果要去除自带的插件, 可以在插件名称前面加\"-\",比如： \"plugins\": [ \"-search\" ] 如果要配置使用的插件可以在book.json文件中加入即可,比如我们添加plugin-github,我们在book.json中加入配置如下即可： { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/your/repo\" } } } 然后在终端输入 gitbook install ./ 安装配置中的插件. 手动安装方式为npm install gitbook-plugin-插件名 livereload 自带实时重载 ComScore 是一个彩色主题,默认的 gitbook 主题是黑白的,也就是标题和正文都是黑色的,而 ComScore 可以为各级标题添加不同的颜色,更容易区分各级标题. Disqus 是一个非常流行的为网站集成评论系统的工具,同样,gitbook 也可以集成 disqus 以便可以和读者交流. 首先,需要在 disqus 上注册一个账号,然后添加一个 website,这会获得一个关键字,然后在集成时配置这个关键字即可. npm install gitbook-plugin-disqus -g 修改 book.json 配置文件,添加插件的配置内容：{ \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"获取的唯一key\" } } } gitbook不支持 [toc],好在有插件可以曲线救国。 在book.json中添加插件\"toc\",运行gitbook install 安装完成后，在使用[toc]命令的地方使用代替(XXX替换为toc)。即可自动生成文档目录。 另外一种方式是安装anchor-navigation-ex添加Toc到侧边悬浮导航以及回到顶部按钮. \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false } } expandable-chapters-small可扩展导航章节 search-pro 高级搜索(支持中文) 在使用此插件之前，需要将默认的search和lunr插件去掉. splitter 侧边栏宽度可调节 sharing-plus分享当前页面，比默认的 sharing 插件多了一些分享方式. \"all\"中代表点击分享符号可以显示出来的. tbfed-pagefooter 页面添加页脚(简单的) page-copyright 页面页脚版权(内容多) klipse 嵌入类似IDE的功能,嵌入一块功能，可在代码段中实时交互,即输入代码 > 执行结果 donate 打赏插件 文章最下面的按钮，点击可弹出图片 change_girls 可自动切换的背景图片，time单位秒,url只能使用绝对地址 { \"plugins\":[\"change_girls\"], \"pluginsConfig\": { \"change_girls\" : { \"time\" : 10, \"urls\" : [ \"girlUrl1\", \"girlUrl2\",...\"\" ] } } } code 为代码块添加行号和复制按钮 \"pluginsConfig\": { \"code\": { \"copyButtons\": true } } codesnippet 从文件导入代码并显示 //@换成% 指定语言 指定显示的文件行数 {@ codesnippet \"./assets/test.cpp\", lines=\"2:5\",language=\"cpp\" @}{@ endcodesnippet @} #include \r using namespace std;\r int main(){\r return 0;\r } checkbox添加checkbox功能 [ ] write some articles [x] drink a cup of tea advanced-emoji支持Emoji表情 Emoji表情列表 klipse 嵌入一块功能，可在代码段中实时交互，即输入代码 > 执行结果 %accordion% klipse详情 %accordion% klipse源码 , klipse插件地址 插件支持的语言eval-js for javascript eval-clojure for clojurescript eval-scheme for scheme eval-ruby for ruby eval-python for python ctrl+enter执行```eval-python print [x + 1 for x in range(10)] ``` eval-pythonprint [x + 1 for x in range(10)] eval-js var x = 1; x + Math.random(); eval-sql CREATE TABLE play (game, points, day); INSERT INTO play VALUES (\"go\", 500, \"monday\"), (\"go\", 300, \"tuesday\"), (\"chess\", 1250, \"tuesday\"); SELECT * FROM play; %/accordion% flexible-alerts 块增强，4级提示卡片 %accordion% flexible-alerts卡片详情 %accordion% [!NOTE|style:flat] [!NOTE|style:flat] 测试 [!TIP|style:flat] [!TIP|style:flat] 测试 [!WARNING|style:flat] [!WARNING|style:flat] 测试 [!DANGER|style:flat] [!DANGER|style:flat] 测试 [!NOTE|style:callout] [!NOTE|style:callout] 测试 [!TIP|style:callout] [!TIP|style:callout] 测试 [!WARNING|style:callout] [!WARNING|style:callout] 测试 [!DANGER|style:callout] [!DANGER|style:callout] 测试 %/accordion% pageview-count 文章左上角显示阅读量计数 accordion 折叠模块,放最外层不可缩进。可嵌套，内部可以加代码块，引用，标题等 %accordion%标题%accordion% //需要空一行 任意内容 //需要空一行 %/accordion% spoiler 给片段覆盖一层黑色蒙版 刮刮乐 {@s%}Hello World.{@ends%} //@改为% hide-element可以隐藏不想看到的元素，比如导航栏中Published by GitBook \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } 参考：GitBook插件整理 发布到 GitHub Pages 由于 gitbook 书籍可以本地构建出静态HTML格式,所以可以直接将构建好的书籍直接放到GitHub Pages中托管,之后可以通过如下地址访问书籍： .github.io/ 只需要4步即可将静态HTML文件发布到gh-pages: gitbook build 在_book子目录下生成静态文件 git subtree split --rejoin --prefix=_book --branch gh-pages拆分子目录到新的分支gh-pages git subtree push --squash --prefix=_book origin gh-pages 推送到远程仓库 在该github仓库的settings->pages中做下图所示修改然后直接通过.github.io访问就可以访问到gh-pages,即_book目录下构建的静态文件 使用actions workflow自动部署 github pages的默认构建方式是jekyll,使用某些gitbook插件时可能会构建失败，从而导致无法继续部署.比如使用codesnippet时无法成功构建.这个时候可以通过自定义静态文件构建的方式完成部署. 在master分支下新建.github/workflows/static.yml(gitbook build后会被自动打包到_book目录下,并在gh-pages分支的push事件触发时执行静态文件部署工作流.) %accordion% 在gp-pages分支下新建.github/workflows/static.yml %accordion% # Simple workflow for deploying static content to GitHub Pages\r name: Deploy static content to Pages\r \r on:\r # Runs on pushes targeting the default branch\r push:\r branches: [\"gh-pages\"]\r \r # Allows you to run this workflow manually from the Actions tab\r workflow_dispatch:\r \r # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\r permissions:\r contents: read\r pages: write\r id-token: write\r \r # Allow one concurrent deployment\r concurrency:\r group: \"pages\"\r cancel-in-progress: true\r \r jobs:\r # Single deploy job since we're just deploying\r deploy:\r environment:\r name: github-pages\r url: ${{ steps.deployment.outputs.page_url }}\r runs-on: ubuntu-latest\r steps:\r - name: Checkout\r uses: actions/checkout@v3\r - name: Setup Pages\r uses: actions/configure-pages@v2\r - name: Upload artifact\r uses: actions/upload-pages-artifact@v1\r with:\r # Upload entire repository\r path: '.'\r - name: Deploy to GitHub Pages\r id: deployment\r uses: actions/deploy-pages@v1 %/accordion% 维护这个库的所有命令都在仓库根目录的Makefile里面定义了，可以参考 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-28 22:35:13 "},"posts/基于Windows文本服务框架TSF的输入法实现.html":{"url":"posts/基于Windows文本服务框架TSF的输入法实现.html","title":"基于Windows文本服务框架TSF的输入法实现","keywords":"","body":"基于Windows文本服务框架TSF的输入法实现 [toc] 背景 TSF的构成和基本工作过程 基本概念 什么是TSF? TSF 体系结构 与应用程序的交互 输入法的设计与具体实现 主要接口函数的实现 输入法的基本实现步骤 创建空白的动态链接库项目 文本服务模块的设计 完成按键的映射 输入组合与候选列表的处理 把文本服务注册为标准COM进程服务项 输入法的安装要点 总结 背景 输入法是指为将各种按键序列转化为字符,输入计算机或其他设备(如手机,平板)而采用的编码方案,因此输入法的研究是信息处理的一个重要课题.Windows提供了两套输入法框架: 在Windows XP及之前,是IMM(Input Method Manager),即输入法引擎,基于纯函数API; Windows XP及以后,提供了新的输入法框架TSF(Text Service Framework),是基于COM(组件对象 模型)的. 目前现有的各个版本输入法大多采用输入法管理器-输入法生成器(IMM-IME)框架进行开发,然而在 Windows 8 系统中 Metro 风格的应用是不支持该框架的,在这些应用下进行输入,需要使用文本服务框架(TSF)开发的输入法. 本文将主要介绍TSF框架的基本构成,输入法的设计以及安装要点. TSF的构成和基本工作过程 基本概念 什么是TSF? TSF为高级文本和自然语言输入技术提供了一个简单,可扩展的框架,是一项从 Windows XP 开始提供的设备无关,语言无关的系统服务.TSF与传统 IME 相比虽然对键盘输入法的作用没有太大区别,但是支持 TSF 的应用程序可以从任何支持TSF的文本服务中接收文本输入(例如手写,语音输入),而不用考虑有关文本来源的具体细节. TSF 体系结构 TSF 主要由应用程序,文本服务和TSF管理器三个部分组成,其结构如图所示: 应用程序(Applications):应用程序的任务一般包括显示, 直接编辑以及文本存储,通过实现 COM 服务来提供文本访问的能力. TSF管理器(TSF Manager):作为文本服务与应用程序之间中间层,TSF管理器支持一个应用程序同时建立多个与文本服务之间的联系,共享文本内容.其功能是由操作系统实现的. 文本服务(Text Services):向应用程序提供文本,同样用COM实现,内置了注册为TSF的服务过程.多个文本服务允许同时被注册,可以包含文本的输入与输出,还可以作为一段文本的数据和属性的关联体.也可以称为TIP(Text Input Processor),比如输入法提供语音,手写,键盘,翻译输入,那就是4个Tip. 与应用程序的交互 TSF的优点在于其设备无关,语言无关,并且可扩展的特性,同时能够给用户提供一致的输入体验.任何 TSF-enabled 的应用程序都能从任何 Text Service 接收文本,同时可以输出文本,而不需要知道文本来源的详细信息.同时,文本服务也不需要考虑各种不同应用之间的差别.TSF是应用与IME之间的中介,TSF将输入事件传递给IME并在用户选择字符后接收从IME返回的输入字符. 输入法的设计与具体实现 主要接口函数的实现 与传统 IME 必须要实现的 ImeInquire,ImeConfigure, ImeProcessKey,ImeToAsciiEx等接口函数不同,文本服务框架包含了一组新的接口函数,具体实现方法也有所不同.其中一些重要的接口如下: 文本输入处理(ITfTextInputProcessor):是创建文本服务需要实现的第一个接口,继承自 IUnknown 接口,由TSF管理器调用来实现文本服务的Activate与Deactivate. 线程管理器事件接收器(ITfThreadMgrEventSink):该接口允许文本服务来接收与响应事件焦点的变化.在 TSF 中,事件通知由被称之为事件接收器的 COM 对象收取,因此,客户端需要实现一个 ITfThreadMgrEventSink 对象,并安装事件接收器, 从而获得线程管理器发送的事件通知.在TSF中,应用程序和文本服务被定义为客户端. 文档管理器(ITfDocumentMgr):文档管理器的作用是管理编辑的内容,每个文档管理器都维护着一个后进先出的缓冲区,通常称之为内容栈,用来存储对应的文档管理器所管理的编辑内容列表. 语言栏按钮项目信息(ITfLangBarItemButton):该接口也继承自 IUnknown 接口,实现一些语言栏上按钮项的信息,例如图标,文本,点击弹出的菜单项等. 编辑会话(ITfEditSession):编辑会话由文本服务实现并由TSF管理器调用来读取或者修改文本和属性的上下文. 输入组合(ITfComposition):输入组合接口由TSF管理器实现,同样继承自IUnknown接口.应用程序显示什么样的文本,以及是否显示文本,需要获取输入组合的显示属性信息,通过判断输入组合是否存在,将其状态显示给用户. 编辑内容查看对象(ITfContextView):文本服务为候选列表创建新的内容后,ITfContextView接口的GetTextExt方法可返回文本边界框的屏幕坐标.除了以上接口,TSF还有线程管理器(ITfThreadMgr),客户端标识符(ITfClientId),键盘事件接收器(ITfKeyEventSink),属性设置(ITfProperty)等一些重要接口需要实现,此处不再一一赘述. 输入法的基本实现步骤 创建空白的动态链接库项目 输入法程序实际上就是一个动态链接库程序 ,只是这个动态链接库较特殊,文件名的后缀是.ime而不是.dll. 在DLL_PROCESS_ATTACH事件中,使用RegisterClass注册用户界面窗口类.可根据个人喜好设计的状态窗口,编码窗口以及候选窗口的属性. 在DLL_PROCESS_DETACH事件中,注销上述注册的窗口对象并释放该对象使用的所有系统资源. 文本服务模块的设计 用户可使用语言栏或键盘来与文本服务进行交互,因此首先要创建一个文本服务并将其注册.要使文本服务被应用程序所使用,需要将其注册为标准COM嵌入进程服务项,即注册到文本服务框架中.TSF通过ITfInputProcessorProfiles与 ITfCategoryMgr两个接口来提供简单的注册过程支持. 线程管理器(ITfThreadMgr)是TSF Manager的基本组成部分,完成应用程序与客户端之间进行联系的公共任务,包括跟踪输入焦点的改变.同时线程管理器还负责向客户端发送事件通知,客户端通过实现ITfThreadMgrEventSink对象,并使用 ITfSource::AdviseSink方法安装事件接收器,获得事件通知. 文本服务使用文档管理器获取编辑内容,ITfTextEditSink接口允许文本服务接收与响应焦点变化事件,对于一个文本服务或者应用程序来说,这个接口的实现是可选的. 需要注意的是,IME必须与系统任务栏兼容.任务栏仅为兼容的IME显示其图标,对于不兼容的则无法显示.我们需要将IME图标存储在DLL或EXE文件中,而不是独立的.ico文件中. 完成按键的映射 除了语言,手写识别,最常用的仍然是键盘的识别.按键的映射是输入法设计的一个重要部分,顾名思义,也是我们最熟悉的一个部分,这里通过虚键实现对一般按键与功能按键的响应,来完成输入过程. 首先需要使用Windows宏MAKELANGID创建语言标识符,它包含一个主要语言标识符与一个从语言标识符,返回值同样也是语言标识符,通过 ITfInputProcessorProfileMgr的RegisterProfile方法来实现注册.对于拼音输入法,使用MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED) 即可. 按键事件的处理受到几个因素的影响:键盘可用状态,键盘开启状态,输入状态,空闲状态,中英文状态等等,在TSF中, 公共缓冲池为数据共享提供了数据存储和消息处理的机制,以支持客户端程序之间的数据共享.对于键盘来说,公共缓冲池 GUID_COMPARTMENT_KEYBOARD_DISABLED针对的是编辑内容,是预定义的,如果它的值为非零值,那么键盘不可用;而GUID_COMPARTMENT_KEYBOARD_OPENCLOSE针对 的是线程管理器,如果它为非零值,那么键盘处于开启状态. 我们通过 ITfCompartmentMgr接口的GetCompartment方法来检查键盘是否可用. 关于按键的处理如图所示: 接下来实现ITfKeyEventSink接口来处理击键事件,该接口包含了OnKeyDowm,OnKeyUp,OnSetFocus等方法分别处理按键按下,按键弹起与一个TSF文本服务接收或者失去键盘焦点时的事件.同时,ITfKeystrokeMgr接口也同样重要,它允许文本服务与键盘管理器的交互. 输入组合与候选列表的处理 文本服务通过调用ITfContextComposition::StartComposition方法创建输入组合,并通过创建ITfCompositionSink对象接收输入组合的事件消息,使用 ITfContextComposition::EndComposition方法来结束输入组合. 在创建输入组合的同时,文本服务需要提供在应用程序中区别组合输入文本与常规文本的显示属性支持,通过在TF_DISPLAYATTRIBUTE结构中定义文本前景色,背景色,下 划线的样式,色彩,粗细等,来实现显示属性的提供.首先需要调用 ITfCategoryMgr::RegisterCategory方法,把文本服务注册为服务提供者,然后实现ITfDisplayAttributeProvider与IEumTfDisplayAttributeInfo接口并使它们可用,最后为文本服务提供的每种显示属性实现一个 ITfDisplayAttributeInfo对象. 接下来是关于候选列表的处理,用户输入字符后,输入法需要提供一个合适的候选列表以便用户从中选择结果串.创建一个候选列表首先要实现候选窗口的创建与注册,然后完成事件的处理部分,如翻页,选择等,最后实现窗口的销毁和隐藏.需要通过ITfTextLayoutSink,ITfIntegratableCandidtateListUIElement等接口一一实现. 把文本服务注册为标准COM进程服务项 基于TSF框架的输入法实际上是一个COM程序,也就是说微软为我们提供了很多的虚基类,然后我们需要实现一个COM程序.CClassFactory类需要能够创建实现ITfTextInputProcessor接口的对象,所有进程内COM服务器(InProcess COM Server)输出四个标准函数: DllRegisterServer : 用Windows注册表来注册COM对象 DllUnRegisterServer : 解注册 DllGetClassObject : 返回CClassFactory类的实例 DllCanUnloadNow : COM调用,检查是否可以从内存中卸载COM服务器. 我们需要在模块定义文件.def中导出这四个接口函数,这样才能够将输入法在系统中注册. 输入法的安装要点 关于输入法ime有两种安装方式: 使用第三方安装程序,导入自己的词库与所生成的ime文件,创建一个 Setup.exe文件,从而可以让用户安装自己编写的IME. 使用Regsvr32命令.Regsvr32命令用于注册COM组件,是Windows系统提供的用来向系统注册或者卸载控件的命令,以命令行方式运行.具体步骤是将所生成的输入法.ime文件拷贝到系统System文件夹下,然后在cmd下运行Regsvr32 输入法.ime即可.但是这种方式会有一些问题,输入法的图标无法使用,不过不影响测试. 检查是否注册成功.win10系统下,设置->语言->选项->添加键盘,可以查看是否功能正常 总结 作为新一代输入法框架,TSF是一个允许进行高级的,来源无关的文本输入的应用编程接口,它为高级文本和自然语言输入技术提供了一个简单和可扩展的框架.关于图标不能显示的问题还有待解决,另外, 对于一个完整的输入法来说还有软键盘,鼠标输入,系统图标, 菜单设置,输入法皮肤等方面需要一一实现,同时,输入效率也是一个不容忽视的部分,有关输入转换算法还需要进一步的研究. Github上有一些开源输入法例如跨平台的RIME可做参考. guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:52 "},"posts/Android-NDK-Camera双摄接入方案.html":{"url":"posts/Android-NDK-Camera双摄接入方案.html","title":"Android-NDK-Camera双摄接入方案","keywords":"","body":"Android-NDK-Camera双摄接入方案 官方文档: Camera 官方NDK 相机示例：ndk-samples 官方示例里面有俩个module可以参考，主要为单摄，包含preview与snapshot： basic suface 表面对象为ANativeWindow 使用了android_app_glue, 在android_main中循环调用DrawFrame绘制从camera2取到的image CameraEngine 类 处理android_app，相机对象与UI交互 //主要API ANativeWindow_setBuffersGeometry //DrawFrame ANativeWindow_acquire // window surface ANativeWindow_Buffer ANativeWindow_lock //Aimage对象数据处理后输出到buf ANativeWindow_unlockAndPost ANativeWindow_release NDKCamera类 相机管理 //主要API ACameraManager //相机管理 ACaptureRequest //请求对象 ACameraCaptureSession //请求的会话 ACaptureSessionOutputContainer ACameraManager_create // 创建ACameraManager ACameraManager_getCameraIdList//获逻辑相机ID列表 ACameraManager_getCameraCharacteristics//由ACameraMetadata接收属性 ACameraMetadata_getAllTags//获取相机标签 ACameraMetadata_getConstEntry//解析属性 获知前摄还是背摄，旋转状态等等 ACameraManager_openCamera //打开一个相机 ACameraManager_registerAvailabilityCallback //注册相机状态回调 CameraDevice_createCaptureSession //创建会话 ACameraCaptureSession_setRepeatingRequest//设置会话请求，会被循环处理 ACameraCaptureSession_stopRepeating//暂停会话请求 ACameraCaptureSession_capture//截屏 ACaptureRequest_setEntry_...//设置相机参数 通过请求传递 //从ANativeWindow创建会话输出容器与目标 ANativeWindow_acquire ACaptureSessionOutputContainer_create ACaptureSessionOutputContainer_add ACameraOutputTarget_create ACameraDevice_createCaptureRequest ACaptureRequest_addTarget ImageReader类 控制转码，旋转，获取底层数据帧，获取显示到ANativeWindow //主要API AImageReader AImage AImageCropRect AImageReader_new //创建 AImageReader_setImageListener //设置监听器 AImageReader_getFormat //获取图片格式 AImageReader_getWindow //get ANativeWindow AImageReader_acquireNextImage //获取下一帧 没有帧会被跳过 AImageReader_acquireLatestImage //获取最新帧 获取后删除 更实时一些 AImage_getNumberOfPlanes //yuv格式获取plane数 AImage_getPlaneRowStride //用于解析YUV格式 AImage_getPlanePixelStride //用于解析YUV格式 AImage_getPlaneData // 获取plane数据 转码 写文件需要 AImage_getWidth AImage_getHeight AImage_getCropRect 对象基本都要手动调用相应方法析构/解注册 // 析构/解注册方法 ACaptureRequest_free ACameraOutputTarget_free ACaptureSessionOutput_free ACaptureSessionOutputContainer_free ACameraMetadata_free ACameraManager_deleteCameraIdList ANativeWindow_release ACameraManager_unregisterAvailabilityCallback ACameraManager_delete ACameraCaptureSession_close 包装了请求结构体 struct CaptureRequestInfo { ANativeWindow* outputNativeWindow_;//示例项目的输出窗口对象 ACaptureSessionOutput* sessionOutput_; ACameraOutputTarget* target_; ACaptureRequest* request_; ACameraDevice_request_template template_;//请求flag int sessionSequenceId_; }; 包装了相机结构体 // helper classes to hold enumerated camera class CameraId { public: ACameraDevice* device_; std::string id_; acamera_metadata_enum_android_lens_facing_t facing_; bool available_; // free to use ( no other apps are using bool owner_; // we are the owner of the camera explicit CameraId(const char* id) : device_(nullptr), facing_(ACAMERA_LENS_FACING_FRONT), available_(false), owner_(false) { id_ = id; } explicit CameraId(void) { CameraId(\"\"); } }; 其他 有2个ImageReader，分别处理yuv(preview)和jpg(capture)数据,在初始化时需要分别获取各自的ANativeWindow并各自在创建会话时绑定到会话的输出容器与目标中 texture-view 结构类似basic //主要API ANativeWindow_fromSurface //从Surface获取ANativeWindow 总结： 主要流程: 添加权限 指定draw与buffer对象 preview应用于ANativeWindow 可以从Surface或者ANativeWindow_Buffer获取buffer对象 获取相机ID列表 初始化并打开指定相机 初始化会话并开启请求 取下层图像帧输出到buf显示 帧率： 下层BufferQueueProducer显示的帧率为30FPS左右， 应用层循环取数据draw，频率大概50FPS AImageReader_acquireLatestImage//实时 AImageReader_acquireNextImage//低端机上会导致preview的fps低 上层消费者取buf的速度比生产者快，所以帧率是同步的 格式： 当前preview格式为AIMAGE_FORMAT_YUV_420_888 snapshot格式为AIMAGE_FORMAT_JPEG 应该能支持其他格式，这边以示例为准并未进一步测试 preview保存的YUV数据以NV21方式可以解 YUV2RGB之后才会输出到buf里面再显示，具体YUV2RGB转换可以参考 ImageReader::PresentImage 分辨率： // 参考 CameraEngine::CreateCamera NDKCamera::MatchCaptureSizeRequest struct ImageFormat { int32_t width; int32_t height; int32_t format; // Through out this demo, the format is fixed to // YUV_420 format }; ImageFormat view{0, 0, 0}, capture{0, 0, 0}; //传输给函数处理进行初始值判断设置 //获取相机支持的分辨率 ACameraMetadata_getConstEntry(metadata, ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS, &entry)); //手动设置分辨率 e.g. view.width=3584; view.height=2240; //同步设置接收窗口大小 ANativeWindow_setBuffersGeometry //ImageFormat初始化后传递给ImageReader构造 AImageReader_new //创建相应分辨率的reader，也可以在此手动指定分辨率但要符合相机支持 双摄目测流程: 分别准备好buffer对象 分别打开相机并初始化 2个ImageReader分别处理相机数据流 创建一个会话并一系列初始化后开启请求 注意事项： ACameraCaptureSession 这个对象似乎只能创建一个，新建的会close掉前面的 测试结果 晋兴微 (1280,800) queueBuffer 显示fps=20左右 (3584,2240) queueBuffer 显示fps=9.75左右 也就是说由于此设备硬件性能原因，分辨率大，内存CPU等跟不上，HAL生产数据帧的帧率就会降低 java api 和C++ api性能 前端窗口显示的大小也会影响实际性能，测试需要控制变量，目前C++ api测试程序前端窗口是满屏的，JAVA api测试程序窗口略小一些。 总体上来看 关于java和C++ api 的性能——并没有显著区别 扩展 关于Camera2有人总结的比较好 Android NDK Camera2小结 google基于Camera2封装了一层更友好的相机接口CameraX CameraX 官方文档 对理解框架有帮助 Android Camera2 HAL3 学习文档 %accordion% 设备存在问题：消费者消费速度跟不上生产者 %accordion% (3584,2240) 分辨率下 JAVA api queueBuffer显示帧率20FPS 而应用层显示只有10FPS左右 初步怀疑: 系统性能瓶颈，对高分辨率图像处理不过来，2边API应用层调用的都是acquireLatestImage，实时性是比较好的，如果还有性能瓶颈，主要原因是设备性能太差。 应用层回调while循环做的事情较多,导致循环/回调的FPS小于下层生产者的速度，成为应用层FPS制约的瓶颈之一. 考虑数据出HAL层到应用层之间有没有可能在晋兴微的设备的中间层被衰减处理了，但是小分辨率图测试下，queueBuffer和应用层显示的FPS是同步的，所以，基本可以排除这种情况。 那么更有可能是应用层消费者吃饭速度太慢，太慢的原因可能是上述说的在大分辨率图的情况下回调的FPS跟不上生产者，处理太耗时之类的，或者系统性能瓶颈导致确实处理不过来,后者的可能性更大一些。但是前者需要进行测试排除或优化，检查处理大分辨率图时的耗时情况，或者另起线程处理，回调中不做耗时操作。 queueBufferProducer作为安卓底层,它发出的log,数据是可信的,它生产速度是多少就是多少. 关于为什么queueBufferProducer显示的FPS和应用层实际不一致的情况，很显然原因是因为应用层处理过慢.至于过慢的原因，上面也已经做了说明. 目前cpp api测试正常性能的设备，只要消费者速度能跟上生产者，大分辨率下应用层和底层的preview帧率也是同步的。 综上所述，主要晋兴微的设备自身的性能问题导致FPS上不去 %/accordion% guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:31 "},"posts/CI&CD相关模块的共享方案.html":{"url":"posts/CI&CD相关模块的共享方案.html","title":"CI&CD相关模块的共享方案","keywords":"","body":"CI&CD相关模块的共享方案 [toc] 需求： 满足不同成员与不同项目对公共配置/构建文件等的代码复用 情景1 统一各类配置库管理 情景： 用于不同项目的build.py的公共逻辑/函数方法,及一系列用于构建的其他python辅助方法 用于*.cmake的公共函数function macro 未来兼容其他配置，统一管理的扩展性 作为构建代码也需要版本管理 为便于管理应该组织在一个库中 此库包含一般通用方法，也包含项目内部可能特有的公共方法 这些公共辅助方法应该能较方便按文件/目录拉取到项目目录下 为了避免对依赖方的影响，接口/函数命名同样需要前向兼容保持稳定 此情景下有以下方式： 基于git的sparse clone 在项目中配置此库需要拉取的文件，本地使用，而不加入项目的版本管理. 实现方案： 初始化# 创建用于本地仓库的文件夹 mkdir localdir # 进入文件夹 cd localdir # 在本地指定文件夹内执行此命令设置为git仓库 git init 拉取remote all objects信息# 添加远程仓库地址，实现拉取remote的all objects信息 git remote add -f origin https://.../.git 开启sparse clone # 用于控制是否允许设置pull指定文件/夹，适用于Git1.7.0以后版本，本质是开启sparse git config core.sparsecheckout true # 本地目录的.git文件夹下，如果没有sparse-checkout文件则创建，在其中添加指定的文件/夹fileName，就是需要拉取的那个特定文件/夹。*表示所有，！表示匹配相反 echo \"build.py\" >> .git/info/sparse-checkout # 查看 cat .git/info/sparse-chechout 拉取指定目录/文件 # 拉取命令是一样的，只是已经通过配置文件sparse-chechout指定了目标文件/夹 git pull origin master 这样就只拉取了\"build.py\"下来,这样拉取下来会保留有原来的目录结构. 优点： 可以支持仅拉取需要的文件/目录 缺点： 每个项目都得本地配置一遍上述流程 2.通过git的submodule 优点： 直接的子模块依赖，子模块的版本控制与当前项目是分离的 与项目直接依赖，在git初始化时自动拉取该依赖 子模块更新时拉取更新也很方便 缺点： 会拉取子项目所有文件 情景2 仅python情景,通过Python脚本控制全流程配置 希望依赖的时候基于package版本，而不是源码（事实上保证接口前向兼容，完全可以基于最新源码） 通过pypi 源代码仓库结构： /src README.md requirement.txt setup.py 其中setup.py: from setuptools import find_packages, setup setup( name='build_utils', version='1.0.0', description='utils for build', author='xxx', author_email='XXX@xxx', url='https://github.com/build_utils/', #packages=find_packages(), packages=['src'], #install_requires=['requests'], ) 自定义pypi源 用户目录$HOME/.pypirc 下添加 : [distutils] index-servers = [] repository: username: password: MacOS / Linux 在 $HOME/.pip/pip.conf 文件添加以下配置。 [global] index-url = https:///script/simple #推送 twine upload -r dist/* #拉取 pip3 install -i pypi.org源 [distutils] index-servers=pypi [pypi] repository = https://upload.pypi.org/legacy/ username: 注册的pypi账号 password: 注册的pypi密码 上传仓库到github上 执行 python setup.py sdist #setup.py 同级目录生成一个dist文件夹,里面是 sdk1.0.tar.gz 解压安装: python setup.py install # 注:使用 setup.py没有卸载功能,如果需要卸载则要手动删除 # 也可使用: -- record 记录安装文件的目录 python setup.py install --record file.txt # 卸载时可以使用脚本去实现自动安装和卸载 #推送 twine upload dist/* #拉取 pip3 install guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:14 "},"posts/嵌入式设备调试总结.html":{"url":"posts/嵌入式设备调试总结.html","title":"嵌入式设备调试总结.md","keywords":"","body":"嵌入式设备调试总结 [toc] 包含常用命令及调试工具 工具 网络测试工具 wiresharke Wireshark网络抓包(一)——数据包、着色规则和提示 tcpdump chmod 777 ./tcpdump # -w写入文件cap用于分析 ,-C指定文件大小100MB,host过滤主机url ./tcpdump -w /sdcard/test.cap -C 100 host 串口调试 picocom sudo apt-get install picocom sudo picocom -b 115200 /dev/ttyUSB0 #进入Picocom终端模式 # Ctrl+a进入转义模式，然后Ctrl+h 可以获取当前版本支持的命令 查看依赖库 objdump objdump -x libxxx.so | grep NEEDED NEEDED libcurl.so.4 NEEDED libz.so.1 NEEDED libssl.so.1.0.0 NEEDED libcrypto.so.1.0.0 NEEDED libopencv_core.so.3.2 NEEDED libopencv_imgproc.so.3.2 NEEDED libopencv_imgcodecs.so.3.2 NEEDED libturbojpeg.so.0 NEEDED libstdc++.so.6 NEEDED libm.so.6 NEEDED libgcc_s.so.1 NEEDED libc.so.6 刷机工具 pkgburn 选择好固件，关机状态，按住串口线的按钮,电源数据线接入电脑,识别成功后就会自动烧录 刷完需要重新配置一遍设备环境 文件传输 通过TF卡拷贝 cp /mnt/ /tmp 通过smb smb://192.168.1.100/... 通过adb # 支持通配符 adb push adb pull 通过nfs 1. 设备是NFS的客户端，PC作为Server端，PC需要先安装nts-server。 # 安装nfs-server sudo apt install nfs-kernel-server 2. 创建PC共享文件夹(以/home/dell/ez为例)。 sudo mkdir -p /home/dell/ez sudo chown nobody:nogroup /home/dell/ez sudo chmod 777 /home/dell/ez 3. 设备连接局域网，查看设备的IP。 # 使用picocom打开串口，进入设备shell环境 sudo picocom -b 115200 /dev/ttyUSB0 # 设备环境下查看设备IP ifconfig 4. PC添加设备IP访问权限(替换下面命令中的实际IP)。 sudo nano /etc/exports /home/dell/ez IP(rw,sync,no_subtree_check) # Ctrl+X, entering Y, and then hitting Enter. 5. 启动nts-server。 sudo exportfs -a sudo systemctl restart nfs-kernel-server 6. 关闭PC防火墙。 # 查看防火墙状态 sudo ufw status # 如果是active状态，使用以下命令关闭，否则跳过。 sudo ufw disable 7. remount设备rootfs分区。 # 使用picocom打开串口，进入设备shell环境 sudo picocom -b 115200 /dev/ttyUSB0 # remount rootfs mount -o remount, rw / # 同步PC文件夹/home/dell/ez至设备的/mnt/nfs文件夹, 这里的IP为PC的IP地址。如果mount出现问题，可以ping PC的IP地址查看是否能访问 mount -t nfs -o nolock 192.168.1.31:/home/dell/ez /mnt/nfs export LD_LIBRARY_PATH=.:$PATH 8. 将文件拷贝至PC的/home/dell/ez下，可以同步到设备的/mnt/nfs目录，反之同理 一般命令 时间同步 # 指定时间源 ntpd -p ntp.ntsc.ac.cn # 检测是否更新ok date # 或者手动更新, 把系统软件时间同步到硬件,防止系统重启后时间被还原(ntpd不需要) date -s \"2020-07-01 11:25:00\" && hwclock -w 修改权限 chmod 777 /dir adb adb shell exit adb reboot 若程序执行错误打印返回值 echo './run_cmd echo $?'|sh 网络模拟测试 Linux模拟复杂网络环境下的传输(netem和tc) 基于TC和netem实现网络异常情况的模拟 # 第一次调用change改为add，后面都change # 设置wlan0端口的丢包率为30% tc qdisc change dev wlan0 root netem loss 30% # 发送的报文有 0.3% ~ 25% 的丢包率 tc qdisc change dev wlan0 root netem loss 0.3% 25% # 随机产生 2% 损坏的报文（在报文的随机位置造成一个比特的错误） tc qdisc add dev wlan0 root netem corrupt 2% # 网卡延迟增加100ms tc qdisc change dev wlan0 root netem delay 100ms # 报文延迟的时间在 100ms ± 20ms 之间（90ms - 110ms） tc qdisc change dev wlan0 root netem delay 100ms 20ms # 因为网络状况是平滑变化的，短时间里相邻报文的延迟应该是近似的而不是完全随机的。这个值是个百分比，如果为 100%，就退化到固定延迟的情况；如果是 0% 则退化到随机延迟的情况 tc qdisc change dev wlan0 root netem delay 100ms 20ms 50% # distribution 参数来限制它的延迟分布模型。比如让报文延迟时间满足正态分布 tc qdisc change dev wlan0 root netem delay 100ms 20ms distribution normal # 清除wlan0端口的模拟状态 tc qdisc del dev wlan0 root # 查看端口的限制状态 tc qdisc show WIFI配置 # 修改/查看wifi配置 /home/conf/wpa_supplicant.conf /etc/wpa_supplicant.conf ##### wpa_supplicant configuration file template update_config=1 ctrl_interface=/var/run/wpa_supplicant eapol_version=1 ap_scan=1 fast_reauth=1 wowlan_triggers=any network={ ssid=\"ssid\" psk=\"password\" key_mgmt=WPA-PSK } # 关闭 killall wpa_supplicant # -D驱动程序名称(可以是多个驱动程序：nl80211，wext) # -i接口名称 -c配置文件 -B在后台运行守护进程 wpa_supplicant -D nl80211 -i wlan0 -c /home/conf/wpa_supplicant.conf -B # 动态主机配置(可省略) udhcpc -i wlan0 -s /etc/udhcpc.script wpa_cli -i wlan0 scan #搜索附件wifi热点 wpa_cli -i wlan0 scan_result 　#显示搜索wifi热点 wpa_cli -i wlan0 status #当前WPA/EAPOL/EAP通讯状态 wpa_cli -i wlan0 ping #pings wpa_supplicant wpa_cli -i wlan0 add_network #添加一个网络连接,会返回 wpa_cli set_network 11 ssid '\"iPanda-mi8\"' #ssid名称 wpa_cli set_network 11 psk '\"123456\"'　　 #密码 wpa_cli set_network 11 scan_ssid 1 wpa_cli set_network 11 priority 1 #优先级 wpa_cli -i wlan0 list_network #列举保存过的连接 wpa_cli -i wlan0 select_network #连接指定的ssid wpa_cli -i wlan0 enable_network #使能制定的ssid #保存连接 wpa_cli -i wlan0 save_config #信息保存到默认的配置文件中 #断开连接 wpa_cli -i wlan0 disable_network 网卡配置 1. 设置开发板的IP(配置IP地址、网络掩码、广播地址的同时，激活网卡eth0) ifconfig eth0 192.168.1.37 broadcast 192.168.1.255 netmask 255.255.255.0 up 2. 配置网关 route add default gw 192.168.1.1 3. 配置DNS解析 echo \"nameserver 114.114.114.114\" > /etc/resolv.conf 4. 设置一下系统时间 date -s \"2020-08-05 17:40:00\" (当前时间，这里是示例) guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:36 "}}