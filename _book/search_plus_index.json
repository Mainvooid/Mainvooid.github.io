{"./":{"url":"./","title":"README","keywords":"","body":"README 这个GitBook主要包含 如何构建自己的被动收入(记录理论与实践过程,待填坑) 杂文：知识笔记,心得体会等 技术：总结整理后的技术相关文章 记录：一些实践性方案经验记录 关于这个Blog的来源可以参看: Blog实践markdown+gitbook+vscode Email： guobao.v@gmail.com guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-01 21:52:27 "},"posts/长期主义与成长思维.html":{"url":"posts/长期主义与成长思维.html","title":"长期主义与成长思维","keywords":"","body":"长期主义与成长思维 [toc] 长期主义与终生学习 保持好奇心 保持好奇心是主动大量阅读的基础. 知识可以让我们更细粒度解构世界. 数理哲学可以让我们思考得更远. 真正享受结构化知识和分享的过程. 常开上帝视角 从量子涨落到宏观实体 从海森堡的不确定性原理我们可以知道,虚空之中每时每刻都会有大量正负虚粒子对凭空生成并且在碰撞时重新湮灭,简单理解为 你向虚空借了点正能量,虚空同时生成负能量,正负得0,仿佛什么都没有生成,这个系统的总能量依然是0. 正常的年景,好借好还再借不难.而在不完美的年景,借出去的能量一时半会儿还不回去会发生什么. 延伸到宇宙的诞生, 或许在某一个十分短暂的时间内, 虚空中突然发生了量子涨落, 导致瞬间能量暴增, 炸出了我们的宇宙, 同时也炸出了一个\"负宇宙\", 正负得0, 看似什么也没有改变, 但是我们的宇宙就这样神奇地出现了. 从大爆炸到可视宇宙到多维时间线 宇宙曲率结构是平坦的,并且在暗能量加持下还在加速膨胀,在某个边界,连光都追不上空间膨胀的速度.这个边界内就是地球视角下的可视宇宙.可视宇宙之外的东西对人类而言将永远不可知. 光锥之内即是命运,所有人都逃不出自己的光锥.想象一下从你出生的那一刻起,一个以你为中心的球便以光速扩散,你此生之内能靠主观去改变的世界便永远被禁锢在这个球之内. 人生80多光年,不过3万多天,随着时间的流逝,每个人的时间线可以分叉的机会将会越来越少. 从原始汤到星球文明到星际文明 对能量的不同的掌控规模决定了一个文明的发展水平. 对人类文明真正有推进作用的其实还是科学/思想理论的发展.人类文明所做的一切活动99%是后勤维护性质的,维护系统稳定和种群繁衍,无论政治经济文化如何折腾跳跃,它都是那99%,都是为了酝酿那1%的开创性事务. 香农定理->信息传输的极限; 超导+托卡马克->可控核聚变; 深度神经网络->人工智能; 去中心化思想->区块链,web3; 无工质推进技术(太阳帆)->星际旅行. 初级宇宙时代只需要三大技术和一项新的法理基础:强人工智能,可控核聚变,无工质推进技术,星际资源共同所有制(人类命运共同体). 从古代到近代到现代到近未来 跳脱出时代去思考问题. 人类进入工业时代不过200多年,从莱特兄弟到阿姆斯特朗不到70年,进入信息时代也不过近几十年.对这个时代的大部分人来说,这是个进步的时代,跳过了刀耕火种与黑暗封建,进入到一个发展中的不稳定的初级地球文明时期,冲突与浪潮此起彼伏,精彩纷呈,人工智能和量子计算才刚刚起步.这也是个技术爆炸的时代,创新在许多领域攻城拔寨迅速饱和.许多厉害的人能够为推动文明的进化与发展贡献自己的一丝智慧与力量,对他们来说这是个能够实现个人理想的好时代.而与此同时,对大部分人来说,这也是个生不逢时的早期时代.私有制是行星有限资源下的最优解,地区之间和社会层级间的资源分配问题也尤为突出,同时也会导致以人为本的人文主义的普遍欠缺.虽然从奴隶制到封建制,共和制,文艺复兴等一步步的思想解放,可依然还差点味道,还差至少一次思想解放运动,但这又依赖于生产力和生产关系的进一步提高. 从行星空间发展到星际空间才是人类真正的未来,社会制度和所有制形式必然会发生结构性改变以适应新的星际资源分配形势.这一切仰赖于受过高等教育的人的自我觉醒. 跳脱出国家,文化,传统,道德...去思考真正的本质和对的事情. 除了宏观叙事奠定基调之外,还要结合对社会和现实的洞察,一切社会规范只是适合当下时代,称之为适应决不能称为真理. 人类的痛苦大都是由故事和价值观带来的,宗教故事引发宗教战争,足球故事引发足球战争,传统故事引发社会压迫,伟大复兴引发自我压迫. 种群基因只需要社会面延续,人类社会曾经过无数次天灾人祸,击毁和重建.一块土地上的人早已不是最初的那批人的子嗣,一群有同一个共同祖先的人到今天也是形同陌路的.为家族撰取的利益只能维持几代人罢了.家庭/家族制是社会自发产生的局部最优模式.基于血缘关系的组织结构短期来看可以增加生存优势,长期来看,和领养孩子并无区别.(人类命运共同体) 从芯片到主机到程序到非中心化网络 从二进制到用户界面,中间的一切层级都是对服务,数据和设备的层层抽象和建模. 人本主义将会催生非中心化网络格局的形成,从你的数据由服务提供商管理并提供服务转变到你的数据由自身管理,不同服务提供商获取你的授权和数据,为你提供服务. 从血泪劳工到王侯将相 世界历史由特权阶级的恩怨史定义. 特权阶级的软弱性在于,只会想方设法维持阶级稳定从而忽略全局优化解. 生产性劳动是风险最大的劳动方式.因为所要付出的代价在这个时代一文不值,在另一个时代又弥足珍贵. 从局部空间到全局空间 地球诞生高等生命有着及其苛刻的条件:需要处在恒星系统宜居带上;需要一个长期稳定的恒星;需要有个合适的卫星引发潮汐作用;需要地轴偏转22度左右以免永冬;需要是岩石星球能够产生地磁力;需要木星一样的守护吸引陨石;需要液态水和稳定的大气层等等.是幸存者也是天选之地. 相比于黄金白银,生命才是宇宙中最稀缺的资源,是对抗熵增的艺术奇迹.生命在地球的局部空间上富集从而显得廉价无比,而在全局空间中又是最稀缺的资源. ... 简化生活 追求自身人格平稳运作的最低成本,将精力放到更重要的事情上. 生命短暂,生活中有大量无关紧要鸡毛蒜皮的小事,有无数半斤八两的选择, 学会不给予过多关注, 迅速从中脱身, 是很重要的技能. 中有个情节是,明明已经付过早餐店老板钱了,老板没看到又让你付了一次,主角选择了再付一次,而不是跟早餐店老板争执,因为比起争执的时间和一天的好心情,一点早餐钱反而是无关紧要的. 减少多巴胺带来的上瘾和渴望,享受痛苦和内啡肽带来的愉悦感,兴奋感及成就感. 顺势而为 顺势而为的前提是持续提升综合能力及认知水平. 富在术数不在劳身,利在势局不在力耕. 保持钝感力,关注感知\"势\",而非无关紧要的细节. 扩展生命的长度以及宽度 每个人都有自己不同的人生节奏,际遇以及寿命. 拥抱不稳定性. 不要让自己在一件事情上重复10年. 科学的尽头是玄学,脱虚向实是我们唯一能做的事情. 一期一会.退休可能多了时间,但也会丧失年轻时的热血和心态. 最重要的是以自己的方式度过自己的一生. 长期主义 经济危机总会过去,不要为一时的得失停滞不前. 将一件事情放到10年,20年,30年的长度去思考.摒弃狭隘的悲观与乐观. 腾出时间做自己真正热爱的事情. 事物的发展总是曲折前进的,能伸能屈,无论需要妥协还是曲线救国,都别忘了你的目标. 终生学习 大脑是人体老化最慢,可塑性最强的器官,用进废退. 一以贯之的努力,不得懈怠的人生,才是适用于任何时代的不二法门. 任何时候行动起来都不算晚. 被动收入 被动收入是需要最少劳动力来赚取和维持的收入 被动收入是自由的保障,如果你没找到一个当你睡觉时还能赚钱的方法,你将工作到死 有意识的准备/开始构建自己的被动收入,越早越好 从自己擅长的事情入手,以长期主义的思想去打磨变现. 思维的标准 清晰性 能进一步详细描述吗？ 能举个例子吗？ 能阐明要表达的含义吗？ 准确性 怎样进行核实？ 怎样查明是真的？ 怎样查证或证实？ 精确性 可以更精细一点吗？ 能有更多细节吗？ 能更精确吗？ 相关性 它如何与问题相联系？ 它如何支持这个问题？ 它如何在这个问题上对我们有益？ 深度 哪些因素提升问题的深度？ 这个问题的复杂性是什么？ 哪些困难是我们需要着手解决的？ 广度 需要从另一个视角看问题吗？ 需要考虑另一种观点吗？ 需要从其他方式看待问题吗？ 逻辑性 所有这些组合起来有意义吗？ 起初的观点符合最后的论述吗？ 你所说的有据可依吗？ 重要性 这是需要考虑的重要问题吗？ 这是需要聚焦的中心观点吗？ 这些因素哪些是最重要的？ 公正性 我的想法在情境中合理吗？ 我考虑到别人的想法了吗？ 我的目的在该情境下公平吗？ 我使用概念的方法合理吗？ 我是否扭曲了观点来谋取自己的私利？ 七个习惯概论 习惯的定义: 知识、技巧、意愿的结合体 知识: 指点\"做什么\" \"为何做\" 技巧: 告诉\"如何做\" 意愿: 促使\"想要做\" 三者共同作用, 缺一不可, 从而合为习惯: 知道要做啥, 还要知道该怎么做, 更重要的是愿意去做. 成熟模式图(思维成长的三阶段) 依赖: 依赖别人达成愿望与目的——不成熟 独立: 单枪匹马打天下——成熟 互赖: 群策群力达成更高成就——更高层次的成熟 三者依次渐进, 摆脱依赖变得独立是进入互赖模式的基础 个人领域与公共领域的关系 个人领域的完善意味着进入成熟模式的独立期, 你需要培养前三个习惯 公共领域的完善意味着进入成熟模式的高级互赖阶段, 你需要培养后四个习惯. 效能平衡原则 效能在于产能与产出的平衡 产能为生金蛋的资产或能力,产出即金蛋. 三类资产的产能与产出平衡 物质资产 金融资产 人力资产 团体产能也需要满足产能与产出平衡的原则 效能原则是七个习惯的基础 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-05 21:58:13 "},"posts/目标规划与管理.html":{"url":"posts/目标规划与管理.html","title":"目标规划与管理","keywords":"","body":"目标管理与规划 准备篇 四大象限 职业路线图 自己的定位 撰写你的人生基本法 问题 知易行难 归根结底,我们根本没有认清楚行动带来的意义,就导致我们的动机是远远不够强烈的. 容易迷失 荒度时光或重复工作是最常见的迷失现象,没有大纲规划,就会不清楚自己所处的阶段,不知道自己在全景视野里的位置,时间一长,时间线分叉的机会就会越来越少. 意义 看起来虚无缥缈却主导着我们人生的大方向,尤其是在我们出现疲倦,陷入低谷时,它会支撑着我们在这个大框架下,重新启动. 前提 人生基本法不是一天形成的,它需要你不断去思考,打磨,更新和修正. 人生基本法在不同的人生阶段,必然会出现变化.它会随着你的认知和阅历的变化而变化,青年时期和成年时期断然是不一样的. 人生基本法即包括远景使命,目标,也包括近景原则,策略.不要过于纠结它的形式,最重要的是,你开始用以终为始的理念来思考全景,完成这个思考过程,对于大多数人来说,都已经是一次认知上的巨大突破. 如何撰写人生基本法 四个重要支柱 确定你的人生使命(梦想) 最高阶内容,核心中的核心,其余三个步骤都要围绕它进行思考和调整. 所谓人生使命,就是你来到这个世界后,最终为之奋斗的东西,它是你和这个世界产生链接的方式,它能够让你在这个世界上产生的独特的意义与价值.它会成为我们以不变应万变的力量源泉. 它对应着马斯洛需求理论中的最高层次--自我实现需求.只不过因为各种原因被你隐藏起来了,尤其是当下快节奏和焦虑化的时代,逼迫着你去做一些内心并不认可的事情,这就是背离我们人生使命的事情,也只会让你更加的痛苦. 需要你不断思考,尝试,实践,再推翻,再思考,再尝试,再实践,不断去追求它,直到发现或者确定自己的人生使命. 我这一生,百年之后,能否给文明留下哪怕一点点活过的痕迹? 全球著名公司的企业使命: 三星: 为人类社会作出贡献 苹果: 让每个人拥有一台计算机 迪士尼: 使人们过得快活 华为: 构建万物互联的智能世界 京东: 让生活变得简单快乐 阿里巴巴: 让天下没有难做的生意 谷歌: 整合全球信息，使人人皆可访问并从中受益 确定你的人生目标 身体 保持精力旺盛的基础,精神力量和行动力的依托. 智力 扩展认知边界,给自己设定阶段性学习任务,每年设定新的研究课题. 情感 亲情,爱情,友情以及各种人际关系,马克思讲人的本质是一切社会关系的总和,你希望可以达成什么样的目标状态. 财富 让财富积累到能够支持你专注地去完成自己的人生使命.物质财富生不带来死不带去,它应该是为你的远景目标服务的.财富不够时以财富为目标,财富足够时以使命为目标. 人生意义 和使命相互关联但又不完全相同,人生使命一句话可以概括,人生意义则可以从多个维度来进行思考.比如根据你的人生角色,来找到你在不同角色下的人生意义.比如儿女,学生,职场人,创业者,夫妻,父母. 灯塔参照法 为你的某些维度或目标对标一个形象角色特质塑造鲜明的影视剧人物.因为影视剧人物的人设是稳定发挥的,可以给你一个鲜明的灯塔般的模板,当你还没有养成相应习惯特质的时候,一想到形象鲜明的人物就知道自己应该保持什么样的状态.比如美剧中的霍华德给人的印象就是内力深厚,思维语速敏捷,非常精干.比如中的哈罗德芬奇,和善温柔的高智商技术宅形象之下对人性又有着最深邃的洞察. 确定你的价值观或原则 哪些是应该做的,哪些是不应该做的,哪些是重要的,哪些是不重要的 当你需要决定是否坚持,妥协或者放弃的时候,这些原则将会决定你愿意付出多大的代价去做对的事情. 不用顾虑太多逻辑结构,只需要把你觉得自己最希望坚持的价值观写下来即可,同时这个人生原则也需要不断去补充更新. 确定你的人生策略 想达到以上的目标需要做些什么.需要完成哪些前置条件,达成哪些成就,如何达成. 自律,高效能,深度工作,主题阅读等等 SMART原则 定目标时要定一个具体的,实际的,有时间限制的,可以分阶段审查进度的目标. 具体的(Specifit) 可度量(Measurable) 可实现(Attainable) 有相关性(Relevant) 有时限的(Time-based) 目标拆解 开拓视野和认知 构建个人影响力 被动收入的目标 一切的生意 三件事 切入细分垂直领域 时间管理 重要且紧急 重要不紧急 紧急不重要 不重要不紧急 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-07 17:21:29 "},"posts/知识体系管理与构建.html":{"url":"posts/知识体系管理与构建.html","title":"知识体系管理与构建","keywords":"","body":"知识体系管理与构建 [toc] 个人知识库和个人搜索引擎 碎片信息收集 个人知识/资料库 个人私有云盘 全局搜索 写作输出 以终为始 创作分享呈现 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-02 14:10:42 "},"posts/项目实施与运营.html":{"url":"posts/项目实施与运营.html","title":"项目实施与运营","keywords":"","body":"项目实施与运营 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-02 14:03:50 "},"posts/C++奇淫巧计.html":{"url":"posts/C++奇淫巧计.html","title":"C++奇淫巧计","keywords":"","body":"C++ 奇淫巧计 [toc] 泛型编程 其他非语言特性的技巧 第一眼看上去比较新鲜的各种C++实践。 收录内容比较主观,有些是现代C++的新特性，有些可能蛮常见的,但是回想第一次看见时还挺新鲜的,所以会一并收录。 取数组大小 int arr[]={1,2,3,4,5}; int size = sizeof(arr)/sizeof(arr[1]);//正常 int size = *(&arr+1)-arr; //不走寻常路 文件内扩栈(系统栈不够用的话) #pragma comment(linker,\"/STACK:102400000,102400000\") //g++中使用这种方法 int __size__ = 256 文件内指定链接静态库 #pragma message(\"link opencv libs in opencv.hpp.\")//链接库文件时可以编译提示 #pragma comment(lib,\"opencv_core410.lib\") 代码中开O3优化 #define fastcall __attribute__((optimize(\"-O3\"))) 大括号别名 { } 等价于 看起来像趋近于的while(i-->0)，实际上是: int i = 10; while((i--) > 0) {//＞0 打印后自减 cout 通过异或法原地交换整数a b int a = 1, b = 2; a ^= b ^= a ^= b;//显然a,b不能是同一个对象的引用 cout 最简洁也是效率最高的单例模式的实现 single& single::get_instance() { static single instance; return instance; } 等价读取,产生合并的唯一ID //给part成员赋值,以merge_id读取,只要保证内存匹配就可以互相转换 union msg_id { int merge_id;// = major_id | minor_id 2次幂枚举量 enum Days { None = 0, Sunday = 1, Monday = 2, Tuesday = 4, Wednesday = 8, Thursday = 16, Friday = 32, Saturday = 64 }; Days flag = Days::Monday; //添加条件: | flag = Days(flag | Days::Wednesday); //删除条件: &~ flag = Days(flag & ~ Wednesday); // \"flag\" 为 \"Monday\" if ((flag & Monday) == Monday) {cout delete this 有点反直觉，我杀我自己 确保对象是new出来的 确保delete完后不能访问对象的任何部分 确保delete完后this指针不会被访问 自定义字面量 // 通过重载双引号后缀运算符实现 // 字符串字面量自定义必须设置如下的参数列表 std::string operator\"\" _wow1(const char *wow1, size_t len) { return std::string(wow1)+\"def\"; } // 整形设置如下的参数列表 std::string operator\"\" _wow2 (unsigned long long i) { return std::to_string(i) + \"23456\"; } auto str = \"abc\"_wow1;//abcdef auto num = 1_wow2;//123456 结构化绑定 C++17 std::tuple f({1,2.0,\"a\"}) auto [x, y, z] = f(); 如何将lambda存在new出来的内存？ auto fn=new auto([]{}); delete fn; 如何检测某个类有某个名字的成员？ bool flag=std::is_member_pointer::value; main函数的类型名是什么? #include #include using namespace std; int main(){ cout 泛型编程 泛型编程比较特殊,单独列出.模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。 自动推断数组大小(一般的非类型模板) //(unsigned需要放在前面) template void arr(const T (&m)[n]) { std::cout 自动推导的非类型模板 C++17 enum e{a,b,c}; template void foo(){ cout (); //10 foo(); //0 } 不定长参数列表 标准但落后的递归法解包 // 用于结束递归的同名模板函数 template inline void delete_s(T& p){ if (p != nullptr) { delete(p); p = nullptr; } } // 用于递归不定长参数的同名模板函数 template inline void delete_s(T& p, Args&... args){ if (p != nullptr) { delete(p); p = nullptr; } delete_s(args...); } // 可以接受任意长参数 int main(){ auto* p1=new auto([]{}); auto* p2=new auto([]{}); auto* p3=new auto([]{}); cout 条件编译递归解包 C++17// 一个递归函数搞定 template void delete_s(T& p, Args&... args) { if (p != nullptr) { delete(p); p = nullptr; } if constexpr (sizeof...(args) > 0) delete_s(args...); } lambda表达式+逗号表达式(黑魔法) 非递归原地解包//(a, b)这个表达式的值就是b. 执行((lambda, value),...) //首先会执行前面的lambda,而后计算逗号表达式(值为0),接着继续展开 template auto delete_s(T& p, Args&... args){ if (p != nullptr) { delete(p); p = nullptr; } (([&args]{ if (args != nullptr) { delete(args); args = nullptr; } }(),0),...); } 折叠表达式 template auto sum(T ... t) { return (t + ...); } int main() { cout 泛型Lambda C++14 // 正常模板写法 template auto add(T t, U u) {return t+u;} // 新特性 auto add = [](auto x, auto y) {return x+y;}; cout 函数缓存 为了优化程序性能我们经常使用缓存,比如某个函数非常耗时,频繁调用的时候性能会很低,这时我们可以通过缓存来提高性能. namespace detail { //函数入参及结果缓存,缓存入参和函数的执行结果,若入参存在则从缓存返回结果 template std::function cache_fn(R(*func)(Args...)){ auto result_map = std::make_shared, R>>(); return ([=](Args... args) {//延迟执行 std::tuple _args(args...); if (result_map->find(_args) == result_map->end()) { (*result_map)[_args] = func(args...);//未找到相同入参,执行函数刷新缓存 } return (*result_map)[_args];//返回缓存的对应入参的结果 }); } } //函数对象缓存,若存在相同类型函数指针,则调用相应缓存函数获取缓存结果 template std::function cache_fn(R(*func)(Args...), bool flush = false){ using function_type = std::function; static std::unordered_map functor_map; if (flush) {//明确要求刷新缓存 return functor_map[func] = detail::cache_fn(func); } if (functor_map.find(func) == functor_map.end()) { functor_map[func] = detail::cache_fn(func);//未找到相同函数,执行函数刷新缓存 } return functor_map[func];//返回对应函数的缓存的结果 } //函数缓存可以提高类似重复计算类函数的性能 //以计算斐波那契数列为例: O(N^2) --> O(N) size_t fibonacci_1(size_t n) { return (n std::shared_ptr和boost::shared_ptr之间的转换. [Refer] // 通过按值捕获将原始ptr(及其引用计数)保留在删除器lambda中 // 可能有一定缺陷，例如无法来回转换 template std::shared_ptr to_std(const boost::shared_ptr &p) { return std::shared_ptr(p.get(), [p](...) mutable { p.reset(); }); } template boost::shared_ptr to_boost(const std::shared_ptr &p) { return boost::shared_ptr(p.get(), [p](...) mutable { p.reset(); }); } 其他非语言特性的技巧 abs移位运算 int abs(int x){ int y = x >> 31; return (x ^ y) - y; // or: (x+y)^y } guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-06 01:11:45 "},"posts/C++编码规范-实用增强细节版.html":{"url":"posts/C++编码规范-实用增强细节版.html","title":"C++编码规范-实用增强细节版","keywords":"","body":"C++编码规范(实用增强细节版) [toc] 背景 现象 观点 规范 扩展 基于google开源项目风格指南的实用增强细节版 包含C++风格建议：使用基于小写下划线的蛇形风格 背景 C++非常强大灵活并且包含大量高级特性, 但这种强大不可避免的导致它走向复杂, 使代码更容易产生 bug, 难以阅读和维护. 本规范通过限制甚至禁止使用某些特性. 保持代码清爽及良好的代码习惯,来避免这些特性可能导致的各种问题来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性. 规范包含通用性习惯, 编程注意事项, 编程模式倾向以及代码风格(文本格式化、可读性) 使代码易于管理的方法之一是加强代码一致性. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 现象 Google的C++开源规范问题很多, 没法拿来就用, 需要精简取其精华, 并且切合项目实际, 使得规范简单容易遵循. 从代码风格来讲, google表观的代码风格是一种紧凑型风格, 原则保证必要格式化下, 一页尽可能显示更多的内容, 但是会牺牲一定的可读性. Google规范内容很多, 主要面向开源, 有些规则有点过时了, 并且有自身的路径依赖, 没有考虑到编译器与编辑器的作用, 所以这个规范在google本身的项目的覆盖率都不高, 比如tensorflow大概60%的样子, gtest大概70% e.g.:tensorflow/graph.h googletest/gtest.cc , 这引申出来一个规范制定要点, 规范及代码风格要求应该简单好执行 C++标准特性近年有向类python风格发展的趋势, 比如auto,结构化绑定及解包, 列表初始化, foreach等等, 本质上是向简化及高效化发展的, 但是google规范中有些限制就有点因噎废食了, 比如限制重载运算符, 比如一方面限制流的使用然后另外一方面增加复杂的保证64位下的可移植性的规则, 实际上没有意义. 不要因噎废食, 或者多此一举 google规范有些规则限制不当, 比如大部分教科书推荐使用无符号类型表示非负数.但是它不建议使用无符号类型, 理由是有的人会很愚蠢地写出下面的代码： // 此循环永远不会退出 for (unsigned int i = foo.Length()-1; i >= 0; --i) ... 实际上, 这种行为是在试图兼容不正确的用法, 是没有必要也没有意义的, 无符号的正确用法如下, // 正确用法 for (unsigned int i = foo.Length()-1; i != 0; --i) ... 没有更完整考虑编译器行为 一个事实是, 同样的代码java生成的程序比原生C生成的程序要快. 因为java编译为字节码的过程中默认是开启优化的, 如果C程序不开优化实际上效率还不如java, 所以所有release版本的C程序都需要开O3优化(自动内联). 我们知道只有当函数小于 10 行才适合将其定义为内联函数, 如果有考虑编译器行为, 实际上完全不需要人为考虑给编译器建议内联, 完全交给编译器就完事了, 而且有的时候你即使声明为内联的也不一定会被编译器内联. 关于内联有2个点, 类内都是隐式内联的, inline声明非成员函数. 内联可以解决重定义的问题, 编译器在链接的时候会将他们链接到第一个找到的定义上. 规范中认为启用异常会增加二进制文件数据, 延长编译时间, 但是在现代编译器下, 开优化后这种影响已经非常小了. 对使用 C++ 异常处理应具有怎样的态度？按需正常使用即可. 没有考虑编辑器行为 比如google规范中成员变量后置下划线, 实际上应该前置下划线, 理由有2点： 统一语义：成员变量与私有函数全部前置下划线, 下划线一般代表私有/成员的意思和python的习惯也能统一 智能感知：编辑器中输入_, 大部分编辑器都有智能感知, 可以立马列出所有私有成员, 会很方便. google的紧凑型规范没有一个好的机制去格式化, 全手动控制, 特别容易失控且浪费精力. 我原先也比较喜欢紧凑型风格, 但是vscode的默认格式化行为是教材上的C++标准风格, CTRL+SHIFT+I就完事了, 所以google定义了大量缩进哪哪空格哪哪括号的规则直接没有实现的意义. 而且缩进规则在紧凑型风格指导下也很另类, 大部分编辑器包括飞书的都是默认缩进4空格的,但是它的缩进是1, 2, 4混搭. [不方便使用的东西没有市场] public cls{ public: // 缩进1空格 cls() // 缺省缩进2空格 :a_(0){} // 形参等缩进4空格 void func(){}; private: int a_ = 0; } public cls{ public: cls():a(0){}// 缺省缩进4空格 void func(){}; private: int a = 0; } 代码风格一致性很难控制, 因为只要引入了不同体系的第三方库就会受影响, 比如返回值体系依赖了使用异常的库比如opencv, 那么至少就需要对依赖库的异常进行处理转换. 所以一致性一般都会打折扣, 比如tf中很多文件已经是驼峰式下划线式大小写混杂的了, 从命名规范来说已经失去了控制, 但其实对可读性的影响也不是特别大. 观点 规范迁移, 代码规范应该吸取google规范的精华, 同时结合自身情况补充项目内部的规范要求. 所有的规范都有例外,除了特殊情况, 很少完全强制或者百分百禁用. 代码一致性包含全局一致性与局部一致性, 风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也打乱读者在阅读代码时的节奏, 所以要尽量避免. 规范需要靠自觉遵循, 因为没有实现标准化质量控制机制, 简单的规则可以让大家容易遵循但实践中可能会难以控制. 一致性要求需要进行体系控制, 一旦使用了某一个体系就不方便再引入另外一个体系, 但是实践上, 大部分时候会混用在一起, 变成主要地位与次要地位的局面：原生指针与智能指针, 异常体系与返回值体系, 引用体系与移动体系, 模板与非模板体系. 相较于紧凑型规范, 本规范倾向为简单且易于实施的标准型规范. 规范 最重要的： 代码尽可能使用简单的特性, 避免复杂的特性及操作. 尽可能一目了然, 段落分明. 尽可能采用标准库及通用化实施方式. 尽可能引入编译器检查及自动内存管理. 模式语义尽可能统一, 避免歧义. 尽可能进行文档化注释. 尽可能编写简短, 凝练的函数. 无论是否是脚本语言, 代码应尽可能进行函数式编程, 有利于代码解耦复用. 代码风格 同一文件内应该保持统一风格, 新项目采用新规范, 旧项目保持旧风格. 本规范主次关系应该为(前主后次)：智能指针>原生指针, 异常体系>返回值体系, 引用体系>移动体系, 非模板体系>模板体系. 尽可能以智能指针为主, 但智能指针不能完全代替原生指针,只能作为自动内存管理的补充 异常体系是缺省的更好的选择 引用体系较为简单, 移动体系及移动操作注意事项更多 非模板体系可读性可维护性更友好,除非是开源项目 #define保护 (C++20模块还未普及之前) 所有头文件都应该使用 #define 来防止头文件被多重包含 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径/命名空间中的全路径 #pragma once是依赖MSVC编译器的, 不必使用 从保持良好开发习惯的角度, 应该进行防御性编码,例如使用assert对入参进行校验. 编码应尽可能采用跨平台实现, 优先使用标准库提供的方法,比如文件读取使用std::ifstream替换fread fopen, 使用std::thread替换一般的Thread等等 目前C++20还不成熟, 语言标准指定到C++17即可, 需要注意有的嵌入式设备平台编译器只能支持到C++14. 除非必要, 尽量不要使用模板编程,模板编程有时候能够实现更简洁更易用的接口,但是容易引起维护灾难, 可读性容易崩塌. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间.类的静态方法应当和类的实例或静态数据紧密相关 //应当使用 namespace myproject { namespace foo_bar { void Function1(); void Function2(); } // namespace foo_bar } // namespace myproject //而非 namespace myproject { class FooBar { public: static void Function1(); static void Function2(); }; }// namespace myproject 使用#include包含需要的头文件即可,尽量避免前置声明那些定义在其他项目中的实体,因为前置声明隐藏了依赖关系, 编辑器也不好直接定位到定义. 函数内必要的水平留白可以增加可读性 回调在内部尽可能用std::function实现及接收, 如果是原始函数指针, 将难以接受其他函数类型对象．例如lambda,仿函数等等. 提交git前需要进行标准格式化, 使用vscode默认自动格式化方法即可(ctrl+shift+i全文件,ctrl+k+f格式化选中部分, ctrl+k+x去除尾随空格), android studio有Ctrl+Alt+L全文件等 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖, 构建会更快终止 路径尽可能采用全路径 头文件包含顺序应从最特殊到一般,如： #include \"通用头文件\" #include \"源文件同名头文件\" #include \"本模块其他头文件\" #include \"自定义工具头文件\" #include \"第三方头文件\" #include \"平台相关头文件\" #include \"C++库头文件\" #include \"C库头文件\" 命名空间 在命名空间的最后注释出命名空间的名字,宏也需要namespace mynamespace { } // namespace mynamespace 尽量不要使用内联命名空间inline namespace(违背唯一定义原则)// 这样可以通过a::c来调用,不建议 namespace a { inline namespace b { int c=0; }// namespace b } // namespace a 头文件内不要使用using 引入整个命名空间的标识符号,会污染命名空间, 源文件内可放松,// 头文件内不要这么使用 using namespace foo; // 头文件内应该完整引用命名空间 std::string str; 鼓励在 .cpp 文件内使用匿名命名空间或 static 声明,[作用域按需扩大], 对于不需要在其他地方引用的标识符使用内部链接性声明, 但是不要在 .h 中使用. 将函数变量尽可能置于[最小作用域]内, 离第一次使用越近越好, 并在变量声明时进行初始化. 构造与析构函数 构造函数只负责简单的初始化工作, 不在构造函数中做太多逻辑相关的初始化, 更多操作放在init()方法中,析构同理, 主要操作放到release()方法中,复杂初始化操作需要进行二段构造 隐式类型转换 对于转换运算符和单参数构造函数, 使用explicit关键字,以避免可能的歧义. class clsstr // 使用关键字explicit的类声明, 显示转换 { public: char *_pstr; int _size; explicit clsstr(int size) { _size = size; } clsstr(const char *p) { _pstr = p; } }; // 下面是调用: clsstr string1(24); // 这样是OK的 clsstr string4(\"aaaa\"); // 这样是OK的 clsstr string5 = \"bbb\"; // 这样也是OK的, 调用的是clsstr(const char *p) clsstr string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 clsstr string3; // 这样是不行的, 因为没有默认构造函数 clsstr string6 = 'c'; // 这样是不行的, 其实调用的是clsstr(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 结构体和类 所有结构体和类尽可能提供默认构造函数,特别的, 如果定义了有参构造, 就需要手动提供默认构造并提供初始化方法, 否则引用声明初始化时会带来各种不便. [代码健壮性更好] 组合和继承 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. is关系时继承, has关系时组合 如果基类有虚函数, 则析构函数也应为虚函数, 因为引入了虚函数表机制, 子类向上转型到父类, 调用析构如果父类的析构声明不是虚函数, 将析构不到子类本身. 对于子类重载的虚函数或虚析构函数, 使用 override, 或 (较不常用的) final 关键字显式地进行标记[引入编译器检查] 运算符重载 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 不会同时返回 true.重载同类运算符代码健壮性更好 存取控制 所有 数据成员声明为 private, [按需扩大作用域] 通过set/get方法访问(可以直接定义在头文件中)[单例模式, 读写访问控制] 声明顺序 在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 析构函数,重载运算符,set/get方法, 其它函数, 数据成员. 类定义可以采用多修饰符public: 将类似的声明分段, [有利于增强可读性] 参数及其顺序 入参在前, 出参在后 如果入参/出参参数很多, 多参数传递应该构造为结构体传入, 因为可以解耦, 未来扩展不需要一层层改API, 并且更方便按需和相关服务句柄绑定,[代码健壮性更好] 指针指向的对象如果含有结构应该进行结构化处理[一目了然] 所有按引用传递的参数必须加上const,缺省输出参数为指针,输出应该要允许传递nullptr, 表示不接收某个输出参数, 除非要求出参必须不能为nullptr(比如单个出参的情况）可以考虑使用非const引用 所有权与智能指针 动态分配出的对象最好有单一且固定的管理对象, 并通过智能指针传递所有权. 局部作用域中要求临时对象优先采用智能内存管理方式. [代码健壮性更好] // 可以移动, 不能复制 std::unique_ptr ptr(new cls()); // 可以自定义析构方法 std::unique_ptr> ptr(new cls(), [](cls* p){delete p;}); // 优先使用自动字符数组而不是原始指针 std::vector buffer(10); std::unique_ptr buffer(new char[10]); 运行时类型识别 普通项目除非必要,禁止使用RTTI. 不要使用较复杂的特性, 不利于协作 (开源项目随意) 在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类. 尽可能使用STL的类型转换, 如dynamic_cast<>()等 [引入编译器检查] const及constexpr [引入编译器检查] 强烈建议在任何可能的情况下都要使用const修饰函数变量. 此外有时改用 C++11 推出的 constexpr 更好. const 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. const 的位置: 实际上int const *foo形式语义更标准, 但是也有很多人习惯const int* foo 编译时可以确定的常量用constexpr修饰 指针初始化 使用更安全不会引起歧义的nullptr而不是NULL [兼容性更好] 列表初始化 类型及对象的初始化尽可能使用{}进行初始化 [代码一致性更好且引入编译器检查] //列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误. int pi(3.14); // ok , pi == 3. int pi{3.14}; // 编译错误: 缩窄转换. 预处理宏 [尽可能缩小作用域] 使用宏时要非常谨慎,除非必要,尽量以内联函数, 枚举和常量代替之. 不要在 .h 文件中定义宏.因为宏作用于全局作用域 在马上要使用时才进行 #define, 使用后要立即 #undef. auto 可以绕过烦琐的类型名, 增强可读性, 但是别用在局部变量之外的地方. [可读性更好] Lambda 表达式 适当使用 lambda 表达式. 建议所有捕获都显式写出来, 并且显式指定返回类型. [一目了然]std::sort(v.begin(), v.end(), [](int x, int y) -> bool { return Weight(x) std::functions和std::bind可以搭配成通用回调机制[兼容性更好] 如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数 [可读性优化]： // 表达式拆开, 中间过程用具有意义的变量标识或者直接添加注释 int my_heuristic = scores[x] * y + bases[x]; bool retval = DoSomething(my_heuristic, x, y, z); 规范动态内存的管理, 统一为new delete组合 [代码一致性] 命名约定 根据上文所述, google命名规则较为复杂, 不合理且不利于实施, 故而总结使用基于小写下划线的蛇形风格,相较于驼峰式, 视觉一致性更佳,并且此风格与标准库以及扁平化的风格趋势和谐统一. 简易型命名约定 命名全小写下划线 成员变量用前缀/后缀下划线. 宏命名 大写下划线 增强型命名约定, 建议用在库内部的编码 虽然现代编译器都能悬停显示对象类型, 但是变量名如果能多一些类型描述符, 就不必经常悬停, 一目了然可读性更高一些, 所以可以这么处理： 使用后缀标识来标识类类型 使用前缀+下划线标识私有变量 使用下划线+后缀标识文件名, 命名空间, 结构体, 类, 枚举等类型 使用下划线+方法标识私有方法(正常x_{}用于表变量，_{}表方法就有不可达的意思) 使用后置下划线标识临时变量(正常{}_x用于表类型，{}_表变量就有用完即弃的意思) 全小写下划线, 通过前后缀补充描述 各类文件的缩进全部缺省4空格 结构体的公开成员不使用前置下划线 宏命名 大写下划线 数组及指针相关需要明确类型 类型 前后缀 接口 {}_i interface 实现 {}_impl implementation 枚举 {}_e enumeration 结构体/类 {}_t class/struct/union 回调 {}_cb callback 组件 {}_cp component 组件实现/操作 {}_op opperation 函数对象 {}_fn function 命名空间 {}_ns namespace 临时变量 {}_ local 私有变量/方法 _{} private 成员 m_{} member 指针 p_{} pointer 注释及代码文档化 代码70%的时间是用来阅读的, 所以必要的文档化很有必要(对于非开源项目, 完整文档化需要做更多事情, 做到必要文档化即可) 我们推崇代码既文档+代码文档化, 代码既文档依然需要去细看代码, 而文档化之后, 其他人接手可以不必细看代码, 直接看注释辅助代码, 阅读速度可以提升几倍. 头文件都需要进行必要的文档化 文档化采用doxygen风格(支持主流语言), 参考doxygen文档 文档注释主要在头文件进行, 不要描述显而易见的现象 注释对齐有更好的可读性, 建议在行尾空两格进行注释 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显. 函数声明处的注释描述函数功能; 定义处的注释描述函数实现.通常, 注释不会描述函数如何工作. 那是函数定义部分的事情. 每个类数据成员（也叫实例变量或成员变量) 都应该用必要注释说明用途 特殊注释 标记一些未完成的或完成的不尽如人意的地方 使用TODO注释. 有问题的代码用FIXME注释 问题大或急的话直接提缺陷, 不急的先注释标记在代码里面,在vscode中会被高亮:// TODO(ipanda-2020.08.26) 更好的解决方案是 // FIXME(ipanda-2020.08.26) 有个什么bug 弃用注释 声明时未被弃用的名字可被重声明为deprecated,而声明为deprecated的名字不能通过重声明变为未弃用. 使用了标注为弃用的方法, 会有编译警告, 下列名字或实体的声明中允许使用这个属性: class/struct/union： struct [[deprecated(\"Replaced by bar\")]] S{}; typedef/using： [[deprecated]] typedef S PS; using PS [[deprecated]] = S; 变量,包括静态数据成员：[[deprecated]] int x; 非静态数据成员：union U { [[deprecated]] int n; }; 函数：[[deprecated]] void f(); 命名空间：namespace [[deprecated]] NS { int x; } 枚举：enum [[deprecated]] E {}; 枚举项：enum { A [[deprecated]], B [[deprecated]] = 42 }; 模板特化：template struct [[deprecated]] X{}; 扩展 自动化检查 可以借鉴Cpplint, 使用 cpplint.py 检查风格错误.但是目前它是不完善的, google本身很多规范都检查不了. 在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错. python cpplint.py motion_detector.h motion_detector.h:0: No copyright message found. You should have a line: \"Copyright [year] \" [legal/copyright] [5] motion_detector.h:1: #ifndef header guard has wrong style, please use: CPP_LIB_ALGO_SRC_MOTION_DETECTOR_H_ [build/header_guard] [5] motion_detector.h:160: #endif line should be \"#endif // CPP_LIB_ALGO_SRC_MOTION_DETECTOR_H_\" [build/header_guard] [5] motion_detector.h:4: is an unapproved C++11 header. [build/c++11] [5] motion_detector.h:5: Found C system header after C++ system header. Should be: motion_detector.h, c system, c++ system, other. [build/include_order] [4] motion_detector.h:72: At least two spaces is best between code and comments [whitespace/comments] [2] motion_detector.h:75: Lines should be for vector<> [build/include_what_you_use] [4] Done processing motion_detector.h Doxygen文档 /** * 多行注释 */ /**单行注释*/ 或 /// 或 //! (Doxygen认为注释是修饰接下来的程序代码的) /** guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-29 23:17:11 "},"posts/设计模式.html":{"url":"posts/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 Design patterns [toc] 面向对象设计原则 单一职责原则(Single Responsibility Principle) 开闭原则(Open/closed Principle) 里氏替换原则(Liskov Substitution Principle) 接口隔离原则(Interface Segregation Principle) 依赖倒置原则(Dependency Inversion Principle) 合成复用原则(Composite Reuse Principle) 迪米特法则(Law of Demeter) 创建型模式 单例模式(Singleton) 工厂方法模式(Factory Method) 抽象工厂模式(Abstract Factory) 生成器模式(Builder) 原型模式(Prototype) 结构型模式 适配器模式(Adapter) 桥接模式(Bridge) 组合模式(Composite) 装饰模式(Decorator) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 行为型模式 责任链模式(Chain of Responsibility) 命令模式(Command) 迭代器模式(Iterator) 中介者模式(Mediator) 备忘录模式(Memento) 观察者模式(Observer) 状态模式(State) 策略模式(Strategy) 模板方法模式(Template Method) 访问者模式(Vistor) 模板编程特殊设计模式 奇异递归模板模式(Curiously Recurring Template Pattern) 扩展 面向对象设计原则 单一职责原则(Single Responsibility Principle) 尽量让每个类只负责软件中的一个功能, 并将该功能完全封装在该类中. 开闭原则(Open/closed Principle) 对于扩展, 类应该是“开放”的；对于修改, 类则应是“封闭”的. 里氏替换原则(Liskov Substitution Principle) 扩展一个类时, 要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递. 这意味着子类必须保持与父类行为的兼容. 接口隔离原则(Interface Segregation Principle) 客户端不应被强迫依赖于其不使用的方法. 尽量缩小接口的范围, 使得客户端的类不必实现其不需要的行为. 依赖倒置原则(Dependency Inversion Principle) 高层次的类不应该依赖于低层次的类. 两者都应该依赖于抽象接口. 抽象接口不应依赖于具体实现. 具体实现应该依赖于抽象接口. 合成复用原则(Composite Reuse Principle) 尽量使用对象组合,而不是继承来达到复用的目的. 迪米特法则(Law of Demeter) 最少知识原则,一个类应当尽可能少的与其他类发生相互作用. 创建型模式 创建型模式隐藏了类的实例的创建细节, 通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的. 简单工厂：一个工厂, 通过产品类型创建不同产品 工厂方法：每个产品一个工厂 抽象工厂：每个产品族一个工厂 单例模式(Singleton) 保证一个类只有一个实例, 并提供一个访问该实例的全局节点. %accordion% 单例模式.cpp %accordion% // 最简单高效的单例模式模板类 template class singleton_t{ protected: singleton_t() = default; ~singleton_t() = default; private: singleton_t(const singleton_t &) = delete; singleton_t(singleton_t &&) = delete; singleton_t& operator=(const singleton_t &) = delete; singleton_t& operator=(singleton_t &&) =delete; public: static T& get_instance(){ static T _instance; // 默认静态变量初始化是线程安全的 return _instance; } }; namespace { class _work_t{ public: void set(std::string name){ m_name = name; } std::string& get(){ return m_name; } private: std::string m_name; }; } // namespace // 仅导出单例实现 using work_t = singleton_t; int main(){ work_t::get_instance().set(\"1\"); std::cout %/accordion% %accordion% 单例模式.go %accordion% package singleton import \"sync\" // Singleton 是单例模式接口，导出的 // 通过该接口可以避免 GetInstance 返回一个包私有类型的指针 type Singleton interface { foo() } // singleton 是单例模式类，包私有的 type singleton struct{} func (s singleton) foo() {} var ( instance *singleton once sync.Once ) // GetInstance 用于获取单例模式对象 func GetInstance() Singleton { once.Do(func() { instance = &singleton{} }) return instance } func main(){ ins1 := GetInstance() ins2 := GetInstance() if ins1 != ins2 { t.Fatal(\"instance is not equal\") } } %/accordion% 工厂方法模式(Factory Method) 在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型. %accordion% 工厂方法模式 %accordion% // 抽象工厂类 生产电影 class factory_i { public: virtual std::shared_ptr get_movie() = 0; }; // 具体工厂类 中国生产者 class chinese_producer_t : public factory_i { public: std::shared_ptr get_movie() override { return std::make_shared(); } }; // 抽象产品类 电影 class movie_i { public: virtual std::string get_a_movie() = 0; }; // 具体产品类 电影::国产电影 class chinese_movie_t : public movie_i { public: std::string get_a_movie() override { return \"《让子弹飞》\"; } }; int main() { std::shared_ptr factory; std::shared_ptr product; ​ // 选择创建者的类型 factory = std::make_shared(); product = factory->get_movie(); std::cout get_a_movie() %/accordion% 抽象工厂模式(Abstract Factory) 让你能创建一系列相关的对象, 而无需指定其具体类. %accordion% 抽象工厂模式 %accordion% // 抽象工厂类 生产电影和书籍类等 class factory_i { public: virtual std::shared_ptr product_movie() = 0; virtual std::shared_ptr product_book() = 0; }; // 具体工厂类 中国生产者 class chinese_producer_t : public factory_i { public: std::shared_ptr product_movie() override { return std::make_shared(); } ​ std::shared_ptr product_book() override { return std::make_shared(); } }; // 抽象产品类 电影 class movie_i { public: virtual std::string name() = 0; }; ​ // 抽象产品类 书籍 class book_i { public: virtual std::string name() = 0; }; // 具体产品类 电影::国产电影 class chinese_movie_t : public movie_i { std::string name() override { return \"《让子弹飞》\"; } }; // 具体产品类 书籍::国产书籍 class chinese_book_t : public book_i { std::string name() override { return \"《三国演义》\"; } }; ​ int main() { std::shared_ptr factory; // 选择创建者的类型 factory = std::make_shared(); std::shared_ptr movie; std::shared_ptr book; movie = factory->product_movie(); book = factory->product_book(); std::cout name() name() %/accordion% 生成器模式(Builder) 使你能够分步骤创建复杂对象. 该模式允许你使用相同的创建代码生成不同类型和形式的对象. %accordion% 生成器模式 %accordion% // 产品类 车 class car_t { public: void set_car_tire(std::string t) { m_tire = t; std::cout build_tire(); m_builder->build_engine(); return m_builder->get_car(); } private: car_builder_i* m_builder; }; int main() { // 抽象建造者(一般是动态确定的) car_builder_i* builder; // 指挥者 director_t* director = new director_t(); // 产品 car_t car; ​ // 建造奔驰 std::cout set_builder(builder); car = director->construct_car(); delete builder; std::cout %/accordion% 原型模式(Prototype) 让你能够复制已有对象, 而又无需使代码依赖它们所属的类. %accordion% 原型模式 %accordion% // 抽象原型类 class object_i { public: virtual object_i* clone() = 0; }; ​ // 邮件的附件 class attachment_t { public: void set_content(std::string content) { m_content = content; } std::string get_content() { return content; }​ private: std::string m_content; }; // 具体原型: 邮件类 class email_t : public object_i { public: email_t(){} email_t(std::string text, std::string attachment_content) : m_text(text), m_attachment(new attachment_t()) { m_attachment->set_content(attachment_content); } ~email_t() { delete m_attachment; } void display() { std::cout get_content() m_text, this->m_attachment->get_content()); } void set_text(std::string new_text) { m_text = new_text; } void set_attachment(std::string content) { m_attachment->set_content(content); } private: std::string m_text; attachment_t *m_attachment; }; int main() { email_t* email = new email_t(\"最初的文案\", \"最初的附件\"); email_t* copy_email = email->clone(); copy_email->set_text(\"新文案\"); copy_email->set_attachment(\"新附件\"); std::cout display(); std::cout display(); delete email; delete copy_email; } %/accordion% 结构型模式 结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构, 就像搭积木, 可以通过简单积木的组合形成复杂的、功能更为强大的结构. 结构型模式可以分为类结构型模式和对象结构型模式： 类结构型模式：关心类的组合, 由多个类可以组合成一个更大的系统, 在类结构型模式中一般只存在继承关系和实现关系. 对象结构型模式：关心类与对象的组合, 通过关联关系使得在一 个类中定义另一个类的实例对象, 然后通过该对象调用其方法. 根据“合成复用原则”, 在系统中尽量使用关联关系来替代继承关系, 因此大部分结构型模式都是对象结构型模式. 适配器模式(Adapter) 让接口不兼容的对象能够相互合作. %accordion% 适配器模式 %accordion% // 客户端接口 class target_i { public: virtual ~target_t() = default; virtual std::string request() const { return \"default target's behavior.\"; } }; // 适配者 class adaptee_t { public: std::string specific_request() const { return \".eetpadA eht fo roivaheb laiceps\"; } }; // 适配器 class adapter_t : public target_i { public: adapter_t(adaptee_t* adaptee) : adaptee_t(adaptee) {} std::string request() const override { std::string to_reverse = this->adaptee_->specific_request(); std::reverse(to_reverse.begin(), to_reverse.end()); return \"adapter: (TRANSLATED) \" + to_reverse; } private: adaptee_t* m_adaptee; }; // 客户端方法 void client_code(const target_i* target) { std::cout request() specific_request(); adapter_t* adapter = new adapter_t(adaptee); client_code(adapter); delete target; delete adaptee; delete adapter; } %/accordion% 桥接模式(Bridge) 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构, 从而能在开发时分别使用. %accordion% 桥接模式 %accordion% // 抽象类 class pen_i { public: virtual void draw(std::string name) = 0; void set_color(color_t* color) { m_color = color; } ​protected: color_t* m_color; }; // 实现类 class big_pen_t : public pen_i { public: void draw(std::string name) { std::string pen_type = \"大号钢笔绘制\"; m_color->bepaint(pen_type, name); } }; // 抽象类 class color_i { public: virtual void bepaint(std::string pen_type, std::string name) = 0; }; // 实现类 class red_t : public color_i { public: void bepaint(std::string pen_type, std::string name) override { std::cout set_color(color); pen->draw(\"太阳\"); ​ delete color; delete pen; } %/accordion% 组合模式(Composite) 你可以使用它将对象组合成树状结构, 并且能像使用独立对象一样使用它们. %accordion% 组合模式 %accordion% // 抽象基类声明组合中的通用操作 class graphic_i { public: virtual void move(int x, int y) = 0; virtual void draw() = 0; }; // 点 class dot_t : public graphic_i { public: dot_t(int x, int y) : m_x(x), m_y(y) {} void move(int x, int y) override { m_x += x; m_y += y; } void draw() override { printf(\"在(%d,%d)处绘制点\\n\", m_x, m_y); } private: int m_x,m_y; }; // 圆 class circle_t : public graphic_i { public: explicit circle_t(int r, int x, int y) : m_radius(r), m_x(x), m_y(y) {} void move(int x, int y) override { m_x += x; m_y += y; } void draw() override { printf(\"以(%d,%d)为圆心绘制半径为%d的圆\\n\",m_x,m_y,m_radius); } ​private: int m_x,m_y,m_radius; }; // 组件操作 class graphic_cp : public graphic_i { public: void add(int id, graphic_i* child) { m_map[id] = child; } void remove(int id) { m_map.erase(id); } void move(int x, int y) override { for (auto [k,v] : m_map){ v->move(x, y); } } void draw() override { for (auto [k,v] : m_map){ v->draw(x, y); } } ​private: // key是图表id, value是图表指针 std::map m_map; }; int main() { // 组合图 graphic_cp* all = new graphic_cp(); ​ // 添加子图 dot_t* dot1 = new dot_t(1, 2); circle_t *circle = new circle_t(5, 2, 2); graphic_cp* child_graph = new graphic_cp(); dot_t* dot2 = new dot_t(4, 7); dot_t* dot3 = new dot_t(3, 2); child_graph->add(0, dot2); child_graph->add(1, dot3); ​ // 将所有图添加到组合图中 all->add(0, dot1); all->add(1, circle); all->add(2, child_graph); // 绘制 all->draw(); ​ delete all; delete dot1; delete dot2; delete dot3; delete circle; } %/accordion% 装饰模式(Decorator) 允许你将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为. %accordion% 装饰模式 %accordion% // 具体组件和装饰类的共同基类 class data_source_i { public: virtual void write(std::string data) = 0; }; // 具体组件 ​class file_source_t : public data_source_i { public: explicit file_source_t(std::string file_name) : m_fname(file_name) {} void write(std::string data) override { printf(\"写入文件%s中: %s\\n\", m_fname.c_str(), data.c_str()); } ​private: std::string m_fname; }; // 装饰类 class data_source_decorator_cp : public data_source_i { public: explicit data_source_decorator_cp(data_source_i* ds) : m_ds(ds) {} void write(std::string data) override { m_ds->write(data); } ​protected: data_source_i* m_ds; // component }; // 加密装饰器 class encryption_decorator_op : public data_source_decorator_cp { public: using data_source_decorator_cp::data_source_decorator_cp; void write(std::string data) override { data = \"已加密(\" + data + \")\"; m_ds->write(data); } }; // 压缩装饰器 class compression_decorator_op : public data_source_decorator_cp { public: using data_source_decorator_cp::data_source_decorator_cp; void write(std::string data) override { data = \"已压缩(\" + data + \")\"; m_ds->write(data); } }; int main() { file_source_t* source1 = new file_source_t(\"stdout\"); // 将明码数据写入目标文件 source1->write(\"testdata\"); ​ // 将压缩数据写入目标文件 compression_decorator_op* source2 = new compression_decorator_op(source1); source2->write(\"testdata\"); ​ // 将压缩且加密数据写入目标文件 encryption_decorator_op* source3 = new encryption_decorator_op(source2); source3->write(\"testdata\"); ​ delete source1; delete source2; delete source3; } %/accordion% 外观模式(Facade) 能为程序库、框架或其他复杂类提供一个简单的接口. %accordion% 外观模式 %accordion% class computer_t { public: computer_t() { m_mem = new memory_t(); m_proc = new processor_t(); m_hd = new hard_disk_t(); m_os = new os_t(); } ~computer_t() { delete m_mem; delete m_proc; delete m_hd; delete m_os; m_mem = nullptr; m_proc = nullptr; m_hd = nullptr; m_os = nullptr; } ​ void power_on() { std::cout self_check(); m_proc->run(); m_hd->read(); m_os->load(); std::cout power_on(); delete c; } %/accordion% 享元模式(Flyweight) 摒弃了在每个对象中保存所有数据的方式, 通过共享多个对象所共有的相同状态, 让你能在优先的内存容量中载入更多对象. %accordion% 享元模式 %accordion% // 享元类 树木类型是固定的可以通过指针共享给大量树 class tree_type_t { public: tree_type_t(std::string n, std::string c, std::string t) : m_name(n), m_color(c), m_texture(t) {} void draw(std::string canvas, double x, double y) { // 创建特定类型、颜色和纹理的位图 // 在画布坐标(x,y)处绘制位图 } ​private: std::string m_name; std::string m_color; std::string m_texture; }; // 享者 坐标随机独有, 但引用树的类型数据会大量重复 class tree_t { public: tree_t(double x, double y, tree_type_t* t) : m_x(x), m_y(y), m_t(t) {} void draw(std::string canvas) { return m_t->draw(canvas, m_x, m_y); } ​private: double m_x; double m_y; tree_type_t* m_t; }; // 享元工厂: 共享数据缓存, 应该是单例类 namespace detail_ns{ class tree_factory_t { public: tree_type_t* get_tree_type(std::string name, std::string color, std::string texture) { std::string key = name + \"_\" + color + \"_\" + texture; auto iter = mp_tree_type.find(key); if (iter == mp_tree_type.end()) { // 新的tree type tree_type_t* new_tree_type = new tree_type_t(name, color, texture); mp_tree_type[key] = new_tree_type; return new_tree_type; } else { // 已存在的tree type return iter->second; } } ​private: // 共享池, 其中key格式为name_color_texture std::map mp_tree_type; }; } // namespace detail_ns // 包装为单例类(见模板单例类) using tree_factory_t = singleton_t; // forest_t包含数量及其庞大的tree_t class forest_t { public: void plan_tree(double x, double y, std::string name, std::string color, std::string texture) { tree_type_t* type = tree_factory_t::get_instance().get_tree_type(name, color, texture); tree_t tree = tree_t(x, y, type); m_trees.push_back(tree); } void draw() { for (auto tree : m_trees) { tree.draw(\"canvas\"); } } ​private: std::vector m_trees; }; int main() { forest_t* forest = new forest_t(); // 在forest中种植很多棵树 for (int i = 0; i plan_tree(x, y, \"杉树\", \"红色\", \"\"); // 树类型2: 绿色的榕树 forest->plan_tree(x, y, \"榕树\", \"绿色\", \"\"); // 树类型3: 白色的桦树 forest->plan_tree(x, y, \"桦树\", \"白色\", \"\"); } } forest->draw(); delete forest; } %/accordion% 代理模式(Proxy) 让你能够提供对象的替代品或其占位符. 代理控制着对于原对象的访问, 并允许在将请求提交给对象前后进行一些处理. %accordion% 代理模式 %accordion% // 远程服务接口 class video_lib_i { public: virtual std::string get_video_list() = 0;//略缩图列表 virtual std::string get_video_info(int id) = 0;//视频页面 }; // 服务类(请求) class pull_video_t : public video_lib_i { public: std::string get_video_list() override { // 向远程视频后端服务发送一个API请求 return \"video list\"; } ​ std::string get_video_info(int id) override { // 向远程视频后端服务发送一个API请求 return \"video info\"; } }; // 代理类(缓存) ​class video_cache_t : public video_lib_i { public: explicit video_cache_t(video_lib_i* service) : mp_service(service), m_need_reset(false), m_list_cache(\"\"), m_video_cache(\"\") {} void reset() { m_need_reset = true; } ​ std::string get_video_list() override { if (m_list_cache == \"\" || m_need_reset) { m_list_cache = mp_service->get_video_list(); } return m_list_cache; } ​ std::string get_video_info(int id) override { if (m_video_cache == \"\" || m_need_reset) { m_video_cache = mp_service->get_video_info(id); } return m_video_cache; } ​private: video_lib_i* mp_service; std::string m_list_cache; std::string m_video_cache; bool m_need_reset; }; // 管理代理类(渲染) class video_manager_t { public: explicit video_manager_t(video_lib_i* s) : mp_service(s) {} void render_video_page(int id) { std::string video_info = mp_service->get_video_info(id); // 渲染视频页面, 这里忽略实现 printf(\"渲染视频页面: %s\\n\", video_info.c_str()); } void render_list_panel() { std::string video_list = mp_service->get_video_list(); // 渲染视频缩略图列表, 这里忽略实现 printf(\"渲染视频缩略图列表: %s\\n\", videos.c_str()); } ​private: video_lib_i* mp_service; }; int main() { pull_video_t* p_service = new pull_video_t(); video_cache_t* p_cache_proxy = new video_cache_t(p_service); video_manager_t* p_manager = new video_manager_t(p_cache_proxy); ​ p_manager->render_video_page(1); p_manager->render_list_panel(); ​ delete p_service; delete p_cache_proxy; delete p_manager; } %/accordion% 行为型模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化. 行为型模式不仅仅关注类和对象的结构, 而且重点关注它们之间的相互作用. 行为型模式分为类行为型模式和对象行为型模式两种： 类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为, 类行为型模式主要通过多态等方式来分配父类与子类的职责. 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为, 对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责. 根据“合成复用原则”, 系统中要尽量使用关联关系来取代继承关系, 因此大部分行为型设计模式都属于对象行为型设计模式. 责任链模式(Chain of Responsibility) 允许你将请求沿着处理者链进行发送. 收到请求后, 每个处理者可对请求进行处理, 或将其传递给链上的下个处理者. %accordion% 责任链模式 %accordion% // 员工申请处理票据需要上报给上级, 如果上级无权处理就上报给更高的上级 // 抽象处理者 class handler_i { public: // 添加上级 virtual void set_superior(handler_i* superior) = 0; // 处理票据申请, 参数是票据面额 virtual void handle_request(double amount) = 0; }; class base_handler_t : public handler_i { public: base_handler_t(double mpa, std::string n) : m_max_processible_amount(mpa), m_name(n), mp_superior(nullptr) {} // 设置上级 void set_superior(handler_i* superior) override { m_superior = superior; } // 处理票据 void handle_request(double amount) { // 可处理时直接处理即可 if (amount handle_request(amount); return; } // 最上级依然无法处理时报错 printf(\"无人有权限处理该票据, 票据金额:%f\\n\", m_name.c_str(), amount); } ​private: double m_max_processible_amount; // 可处理的最大面额 std::string m_name; handler_i* mp_superior; }; // 具体处理者: 组长(仅处理面额set_superior(p_manager); p_manager->setSuperior(p_boss); ​ // 不同面额的票据统一先交给组长审批（ p_group_leader->handle_request(8); p_group_leader->handle_request(88); p_group_leader->handle_request(888); p_group_leader->handle_request(8888); ​ delete p_group_leader; delete p_manager; delete p_boss; } %/accordion% 命令模式(Command) 它可将请求转换为一个包含与请求相关的所有信息的独立对象. 该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中, 且能实现可撤销操作. %accordion% 命令模式 %accordion% // 用遥控器(Controller)控制电视(TV) // 命令接口 class command_t { public: virtual void execute() = 0; }; // 触发者: 遥控器 class controller_t{ public: // 设置命令 void set_command(std::shared_ptr cmd) { m_cmd = cmd; } // 执行命令 void execute_command() { m_cmd->execute(); } ​private: std::shared_ptr m_cmd; }; ​// 具体命令类: 打开电视 class cmd_tv_open_t : public command_t{ public: explicit cmd_tv_open_t(std::shared_ptr tv) : m_tv(tv) {} void execute() override { tv_->open(); } ​private: std::shared_ptr m_tv; }; // 接受者: 电视 class tv_t{ public: void open() { std::cout tv = std::make_shared(); std::shared_ptr controller = std::make_shared(); std::shared_ptr open_cmd = std::make_shared(tv); ​ controller->setCommand(open_cmd); controller->executeCommand(); } %/accordion% 迭代器模式(Iterator) 让你能在不暴露集合底层表现形式(列表、栈和树等)的情况下遍历集合中所有的元素. %accordion% 迭代器模式 %accordion% // 抽象迭代器 class tv_iterator_i{ public: virtual void set_channel(int i) = 0; virtual void next() = 0; virtual void prev() = 0; virtual bool is_end() = 0; virtual std::string cur() = 0; virtual bool is_begin() = 0; }; ​ // 具体迭代器 class abc_iter_t : public tv_iterator_i{ public: explicit abc_iter_t(std::vector &tvs) : m_tvs(tvs) {} void next() override { if (m_cur 0) { m_cur--; } } void set_channel(int i) override { m_cur = i; } std::string cur() override { return m_tvs[m_cur]; } bool is_end() override { return m_cur == m_tvs.size(); } bool is_begin() override { return m_cur == 0; } ​private: std::vector &m_tvs; int m_cur = 0; }; // 抽象电视机 class tv_i { public: virtual std::shared_ptr create_iterator() = 0; }; // 具体电视机 class abc_tv_t : public tv_i { public: std::shared_ptr create_iterator() override{ return std::make_shared(m_tvs); } void add(std::string item) { m_tvs.push_back(item); } private: std::vector m_tvs; }; int main() { abc_tv_t abc; abc.add(\"CCTV-1\"); abc.add(\"CCTV-2\"); abc.add(\"CCTV-3\"); abc.add(\"CCTV-4\"); abc.add(\"CCTV-5\"); ​ auto iter = abc.create_iterator(); while (!iter->is_end()) { std::cout cur() next(); } } %/accordion% 中介者模式(Mediator) 能让你减少对象之间混乱无序的依赖关系. 该模式会限制对象之间的直接交互, 迫使它们通过一个中介者对象进行合作. %accordion% 中介者模式 %accordion% enum person_e { unknown, landlord, tenant, }; // 组件基类 class colleague_i { public: void set_mediator(mediator_t *m) { mp_mediator = m; } mediator_t* get_mediator() { return mp_mediator; } void set_person_type(person_e pt) { me_person_type = pt; } person_e get_person_type() { return me_person_type; } virtual void ask()=0; virtual void answer()=0; private: mediator_t* mp_mediator; person_e me_person_type; }; ​ // 具体组件1: 房东 class landlord_t : public colleague_i { public: landlord_t() { m_name = \"unknown\"; m_price = -1; m_address = \"unknown\"; m_phone_number = \"unknown\"; set_person_type(person_e::unknown); } landlord_t(std::string name, int price, std::string address, std::string phone_number) { m_name = name; m_price = price; m_address = address; m_phone_number = phone_number; set_person_type(person_e::landlord); } void answer() override { printf(\"房东姓名:%s 房租:%d 地址:%s 电话:%s\\n\", m_name.c_str(), m_price, m_address.c_str(), m_phone_number.c_str()); } void ask() override { printf(\"房东%s查看租客信息: \\n\", m_name.c_str()); this->get_mediator()->operation(this); } private: std::string m_name; int m_price; std::string m_address; std::string m_phone_number; }; ​ // 具体组件2: 租客 class tenant_t : public colleague_i { public: tenant_t():m_name(\"unknown\") {} explicit tenant_t(std::string name) { m_name = name; set_person_type(person_e::tenant); } void ask() { printf(\"租客%s询问房东信息:\\n\", m_name.c_str()); this->get_mediator()->operation(this); } void answer() { printf(\"租客姓名: %s\\n\", m_name.c_str()); } private: std::string m_name; }; // 抽象中介者 class mediator_i { public: // 声明抽象方法 virtual void register_method(colleague_i*) = 0; // 声明抽象方法 virtual void operation(colleague_i*) = 0; }; // 具体中介类: 房产中介 class agency_t : public mediator_i { public: void register_method(colleague_i* person) override { switch (person->get_person_type()) { case person_e::landlord: m_landlords.push_back(reinterpret_cast(person)); break; case person_e::tenant: m_tenants.push_back(reinterpret_cast(person)); break; default: printf(\"wrong person\\n\"); } } ​ void operation(colleague_i* person) { switch (person->get_person_type()) { case person_e::landlord: for (auto iter : m_tenants){ iter->answer(); } break; case person_e::tenant: for (auto iter : m_landlords){ iter->answer(); } break; default: break; } } ​ private: std::vector m_landlords; std::vector m_tenants; }; int main() { // 房产中介 agency_t* p_mediator = new agency_t(); ​ landlord_t *p_l1 = new landlord_t(\"张三\", 1820, \"天津\", \"1333\"); tenant_t *p_t1 = new tenant_t(\"Zhang\"); p_mediator->register_method(p_l1); ​ p_mediator->register_method(p_t1); l1->set_mediator(p_mediator); t1->set_mediator(p_mediator); // 业务逻辑 t1->ask(); std::cout ask(); ​ delete p_mediator; delete p_l1; delete p_t1; } %/accordion% 备忘录模式(Memento) 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态. %accordion% 备忘录模式 %accordion% // 备忘录类保存编辑器的过往状态 class snapshot_t { public: snapshot_t(std::string text, int x, int y, double width) : m_text(text), m_cur_x(x), m_cur_y(y), m_selection_width(width) {} std::string& get_text() { return m_text; } int get_cur_x() { return m_cur_x; } int get_cur_y() { return m_cur_y; } double get_selection_width() { return m_selection_width; } private: const std::string m_text; const int m_cur_x; const int m_cur_y; const double m_selection_width; }; ​ // 原发器中包含了一些可能会随时间变化的重要数据 // 它还定义了在备忘录中保存自身状态的方法, 以及从备忘录中恢复状态的方法 class editor_t { public: void set_text(std::string text) { m_text = text; } void set_cursor(int x, int y) { m_cur_x = x; m_cur_y = y; } void set_selection_width(double width) { m_selection_width = width; } // 在备忘录中保存当前的状态 std::shared_ptr create_snapshot() { // 备忘录是不可变的对象, 因此原发器会将自身状态作为参数传递给备忘录的构造函数 auto res = std::make_shared(m_text, m_cur_x, m_cur_y, m_selection_width); printf(\"创建编辑器快照成功, text:%s x:%d y:%d width:%.2f\\n\", m_text.c_str(), m_cur_x, m_cur_y, m_selection_width); return res; } void resotre(std::shared_ptr p_snapshot) { m_text = p_snapshot->get_text(); m_cur_x = p_snapshot->get_cur_x(); m_cur_y = p_snapshot->get_cur_y(); m_selection_width = p_snapshot->get_selection_width(); printf(\"恢复编辑器状态成功, text:%s x:%d y:%d width:%.2f\\n\", m_text.c_str(), m_cur_x, m_cur_y, m_selection_width); } private: // 文本 std::string m_text; // 光标位置 int m_cur_x; int m_cur_y; // 当前滚动条位置 double m_selection_width; }; class command_t { public: explicit command_t(editor_t* e) : mp_editor(e) {} void make_backup() { mp_backup = mp_editor->create_snapshot(); } void undo() { if (mp_backup) { mp_editor->resotre(mp_backup); } } ​private: editor_t* mp_editor; std::shared_ptr mp_backup; }; int main() { // 创建原发器和负责人 editor_t editor; command_t command(&editor); ​ // 定义初始状态 editor.set_text(\"text1\"); editor.set_cursor(21, 34); editor.set_selection_width(3.4); ​ // 保存状态 command.make_backup(); ​ // 更改编辑器状态 editor.set_text(\"text2\"); editor.set_cursor(111, 222); editor.set_selection_width(111.222); ​ // 撤销 command.undo(); } %/accordion% 观察者模式(Observer) 允许你定义一种订阅机制, 可在对象事件发生时通知多个“观察”该对象的其他对象. %accordion% 观察者模式 %accordion% // 抽象观察者 class observer_i { public: virtual void response() = 0; }; ​ // 具体观察者: 狗 class dog_t : public observer_i { public: void response() override { std::cout response(); } } ​private: std::vector m_observers; }; int main() { // 发布者 cat_t cat; // 观察者 dog_t dog; // 添加订阅关系 cat.attach(&dog); // 发布消息 cat.cry(); } %/accordion% 状态模式(State) 让你能在一个对象的内部状态变化时改变其行为, 使其看上去就像改变了自身所属的类一样. %accordion% 状态模式 %accordion% // 论坛账号 class forum_account_t { public: explicit forum_account_t(std::string name):m_name(name),mp_state(std::make_shared(this)){}; void set_state(std::shared_ptr state) { mp_state = state; } std::shared_ptr get_state() { return mp_state; } std::string& get_name() { return m_name; } void download_file(int score){ mp_state->download_file(score); } void write_note(int score){ mp_state->write_note(score); } void reply_note(int score){ mp_state->write_note(score); } ​private: std::shared_ptr mp_state; std::string m_name; }; // 等级状态 class state_i { public: virtual void check_state() = 0; ​ void set_point(int point) { point_ = point; } int get_point() { return point_; } void set_state_name(std::string name) { m_state_name = name; } std::string get_state_name() { return m_state_name; } forum_account_t* get_account() { return mp_account; } ​ virtual void download_file(int score) { m_point -= score; check_state(); } ​ virtual void write_note(int score) { m_point += score; check_state(); } ​ virtual void reply_note(int score) { m_point += score; check_state(); } ​protected: forum_account_t* mp_account; int m_point; std::string m_state_name; }; ​ // 具体状态类: 新手 class primary_state_t : public state_i { public: explicit primary_state_t(state_i* state) { mp_account = state->get_account(); m_point = state->get_point(); m_state_name = \"新手\"; } explicit primary_state_t(forum_account_t *account) { mp_account = account; m_point = 0; m_state_name = \"新手\"; } void download_file(int score) override { printf(\"对不起, %s没有下载文件的权限!\\n\", mp_account->get_name().c_str()); } void check_state() override{ if (m_point >= 1000){ mp_account->set_state(std::make_shared(this)); } else if (m_point >= 100){ mp_account->set_state(std::make_shared(this)); } }; }; // 具体状态类: 高手 // 具体状态类: 专家 ​int main() { forum_account_t account(\"test\"); account.write_note(20); account.download_file(20); account.reply_note(100); } %/accordion% 策略模式(Strategy) 能让你定义一系列算法, 并将每种算法分别放入独立的类中, 以使算法的对象能够相互替换. %accordion% 策略模式 %accordion% // 抽象策略类: 排序 class sort_i { public: virtual void sort_vector(std::vector &arr) = 0; }; // 具体策略类: 冒泡排序 class bubble_sort_t : public sort_i { public: void sort_vector(std::vector &vi) override { // sort } }; class array_handler_t { public: void sort_vector(std::vector &arr) { return mp_sort->sort_vector(arr); } void set_sort_strategy(sort_i* sort) { mp_sort = sort; } ​private: sort_i* mp_sort; }; int main() { std::vector arr; array_handler_t ah; bubble_sort_t* p_bs = new bubble_sort_t(); ah.set_sort_strategy(p_bs); ah.sort_vector(arr); delete p_bs; } %/accordion% 模板方法模式(Template Method) 在超类中定义一个算法的框架, 允许子类在不修改结构的情况下重写算法的特定步骤. %accordion% 模板方法模式 %accordion% // 抽象类: 银行业务办理流程 class bank_op_i { public: void take_number() { std::cout process(); delete deposit; ​ // 取款 bank_op_i* withdraw = new withdraw_t(); withdraw->process(); delete withdraw; ​ // 转账 bank_op_i* transfer = new transfer_t(); transfer->process(); delete transfer; } %/accordion% 访问者模式(Vistor) 将算法与其所作用的对象隔离开来. %accordion% 访问者模式 %accordion% // 抽象访问者 class vistor_i { public: void set_name(std::string name) { m_name = name; } virtual void visit(apple_t *apple) = 0; virtual void visit(book_t *book) = 0; protected: std::string m_name; }; // 具体访问者类: 顾客 class customer_t : public vistor_i { public: void visit(apple_t *apple) { std::cout visit(this); } }; // 具体产品类: 书籍 class book_t : public product_i { public: void accept(vistor_i *vistor) override { vistor->visit(this); } }; ​// 购物车 class shopping_cart_t { public: void accept(vistor_i *vistor) { for (auto prd : m_product_list) { prd->accept(vistor); } } void add_product(product_i *product) { m_product_list.push_back(product); } void remove_product(product_i *product) { m_product_list.remove(product); } ​private: std::list m_product_list; }; int main() { book_t book; apple_t apple; shopping_cart_t basket; ​ basket.add_product(&book); basket.add_product(&apple); ​ customer_t customer; customer.set_name(\"小张\"); basket.accept(&customer); ​ saler_t saler; saler.set_name(\"小杨\"); basket.accept(&saler); } %/accordion% 模板编程特殊设计模式 奇异递归模板模式(Curiously Recurring Template Pattern) CRTP 的主要作用往往是基类需要获取一些派生类信息，或许是成员，或许是方法，或许是类型本身，再通过在基类中实现方法继承来扩展派生类本身，而且可以避免虚函数、动态分派带来的额外运行时代价的问题。比如 std::enable_shared_from_this 就是获取派生类类型本身来给派生类生成 shared_from_this 方法；而 boost::less_than_comparable 就是获取一个派生类方法 operator 来给派生类生成其它的比较运算符。 %accordion% 奇异递归模板模式 %accordion% template class ...base_i> struct cat_cp: public base_i>... { cat_cp(std::string name) : m_name{std::move(name)}, base_i>{*this}... { } std::string m_name; }; template struct eat_op { eat_op(const derive_tn &self) : m_self{self} { } void eat() { std::cout struct sleep_op { sleep_op(const derive_tn &self) : m_self{self} { } void sleep() { std::cout cat1(\"cat1\"); cat1.eat(); cat1.sleep(); } %/accordion% 扩展 awesome-design-patterns C++ CRTP简介 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-30 03:13:24 "},"posts/网络协议要点及编程方法.html":{"url":"posts/网络协议要点及编程方法.html","title":"网络协议要点及编程方法","keywords":"","body":"网络协议要点及编程方法 [toc] 协议 IP 特点 无状态,无连接,不可靠(丢失、重复、延迟或乱序) IP主要包含三方面内容：IP编址方案、分组封装格式(IP分片)及分组转发规则(IP路由) IP数据报 首部20B最大60B UDP 特点 无连接,适合小数据或流媒体 在IP数据包上增加复用分用和差错检测服务 面向报文,报文不可分割,一次交付一个完整报文,不合并,不拆分 UDP数据包 首部8B 2B(16位) 2B(16位) 源端口号(可为0) 目的端口号 UDP长度(最小值8) UDP校验和(可为0) 校验方式: 添加伪IP首部然后用二进制反码运算求和再取反,对整个发送包都进行了校验.检错能力不强但处理速度快. TCP 特点 可靠性连接,全双工通信(接发缓冲区) 面向字节流,逐个字节传送. TCP报文段 首部20B最大60B 字段 意义 解释 序列号 报文段数据首字节序号 TCP传送是面向字节流的逐字节传送.解决网络包乱序. 确认号 期望收到的下一报文段的首字节序号 确认号之前的字节已收到.解决网络包丢失. 数据偏移 首部长度(4bit) 报文段开头到数据部分开头的长度,步进4B,1111=15=最大4*15=60B UAG 紧急位 配合紧急指针,高优先级传送紧急数据. ACK 确认位 ACK=1,确认号字段有效,连接建立后所有报文段需置1. PSH 推送位 不必等待缓冲区满,第一时间向上交付/发送数据. RST 复位位 连接出错,必须重新建立连接. SYN 同步位 表示连接请求报文(SYN=1,ACK=0),连接接收报文(SYN=1,ACK=1). FIN 终止位 要求释放连接. 窗口 接收窗口大小(2B) 发送方接收窗口大小,单位字节 紧急指针 紧急数据大小(2B) 紧急数据放在本报文段数据部分的开头. 选项 可选字段 例如最大报文段长度MSS(数据字段的最大长度) 填充 0字段 为了使首部长为4B整数倍 TCP连接建立与断开过程 TCP3次握手 连接请求(C->S) 连接接收(S->C) 连接确认(C->S) TCP3次握手的状态转移过程 TCP4次挥手 连接释放请求(C->S) 确认请求(S->C) 连接释放(S->C) 确认连接释放(C->S), 等待完全释放(C) 等2MSL原因: 保证最后的ACK能被S收到, 如果收不到S会重传FIN报文. 确保重新建立连接的时候, 网络中残存的数据包都已丢失. TCP可靠传输 序号 面向字节流,为每个字节编上序号. 确认 发送缓冲区会缓存已发送但未接收到确认的报文段,以便需要时重传. TCP默认使用累积确认,只确认还未收到的第一个字节. 重传 超时重传 对每个发送的报文段计时,到期未收到确认则超时重传. RTTs加权平均往返时间: RTTs = 7/8 * oldRTTs + 1/8 * newRTT RTTd为RTT(Round-trip time)的偏差加权平均值: RTTd= 3/4 * oldRTTd + 1/4 * |RTTs-newRTT| 超时重传时间RTO(Retransmission Time Out): RTO = RTTs + 4 * RTTd 冗余ACK(快速重传) TCP规定,每当比确认号大的失序报文段到达时,就发送一个冗余ACK,重新声明确认号. TCP规定,收到3个冗余ACK,就认为确认号之后的报文段已经丢失,发起快速重传. TCP流量控制 接收方控制发送方,点对点通信量的控制,抑制发送方发送速率以便来得及接收. 滑动窗口 窗口数值单位: 最大报文段长度MSS 根据接收缓冲区大小调整接收窗口rwnd 根据网络拥塞情况(超时)调整拥塞窗口cwnd 发送窗口上限 snd_wnd = min(rwnd,cwnd) TCP拥塞控制 发送方根据拥塞程度自控,让网络能够承受现有的网络负荷,是一个协议全局性的策略. 慢开始 刚开始cwnd=1,每经过一个RTT就加倍(指数增长),直到阈值ssthresh 拥塞避免 每经过一个RTT增加1个MSS(线性增长),出现一次超时就退半避让ssthresh=1/2*cwnd,并且回到慢开始算法置cwnd=1(快恢复改进这点,不再置1) 快重传 收到连续3个重复的ACK时,直接重传对方未收到的报文段,而不必等待超时重传. 快恢复 (Reno)收到连续3个重复的ACK时,跳过慢开始过程,置cwnd为退半避让后的阈值ssthresh=1/2*cwnd,退出快恢复状态进入拥塞避免阶段. (NewReno)收到多组连续3个重复的ACK时,跳过慢开始过程,置cwnd为退半避让后的阈值ssthresh=1/2*cwnd,当所有丢失的包都重传并收到确认后才退出快恢复. TCP版本: Tahoe: 慢开始 拥塞避免 快重传 Reno: 比Tahoe多了快恢复 NewReno: 改进Reno对丢失多个包的快恢复过程(恢复应答判断) KCP 特点 以流量换流速的具有可靠性的协议栈header only.(建议基于UDP) 平均RTT减少30%-40% VS TCP 最大RTT减少3倍 vs TCP KCP分片 首部24B|| +--------+--------+--------+--------+ | conv | conv: 会话序号 +--------+--------+--------+--------+ cmd: 指令类型 | cmd | frg | wnd | frg: 分片序号 +--------+--------+--------+--------+ wnd: 接收窗口大小 | ts | ts: 发送的时间戳 +--------+--------+--------+--------+ | sn | sn: 包序号 +--------+--------+--------+--------+ | una | una: 当前未收到的序号 +--------+--------+--------+--------+ | len | len: 数据段长度 +--------+--------+--------+--------+ 字段 意义 解释 conv 会话序号 标识一段会话连接 cmd 指令类型 数据包IKCP_CMD_PUSH, ACK包IKCP_CMD_ACK, 窗口探测包IKCP_CMD_WASK, 窗口回应包IKCP_CMD_WINS frg 分片倒序号 当输出数据大于MSS时,需要将数据进行分片.收到0时代表接收完毕. wnd 接收窗口大小 用于流控, 也就是rcv_queue的可用大小 ts 发送时间戳 用来估计 RTT. sn 包序号 una unacknowledged 当前未收到的序号: 即代表这个序号之前的包均收到. len 数据段长度 %accordion% ikcp.hpp %accordion% //=====================================================================\r //\r // KCP - A Better ARQ Protocol Implementation\r // 原作者: skywind3000 (at) gmail.com, 2010-2011\r //\r // Features:\r // + Average RTT reduce 30% - 40% vs traditional ARQ like tcp.\r // + Maximum RTT reduce three times vs tcp.\r // + Lightweight, distributed as a single source file.\r //\r // 当前项目地址: https://github.com/Mainvooid/kcp-hpp\r //=====================================================================\r #ifndef __IKCP_H__\r #define __IKCP_H__\r \r #include \r #include \r #include \r #include \r #include \r #include \r \r \r //=====================================================================\r // 32BIT INTEGER DEFINITION\r //=====================================================================\r #ifndef __INTEGER_32_BITS__\r #define __INTEGER_32_BITS__\r #if defined(_WIN64) || defined(WIN64) || defined(__amd64__) || \\\r defined(__x86_64) || defined(__x86_64__) || defined(_M_IA64) || \\\r defined(_M_AMD64)\r typedef unsigned int ISTDUINT32;\r typedef int ISTDINT32;\r #elif defined(_WIN32) || defined(WIN32) || defined(__i386__) || \\\r defined(__i386) || defined(_M_X86)\r typedef unsigned long ISTDUINT32;\r typedef long ISTDINT32;\r #elif defined(__MACOS__)\r typedef UInt32 ISTDUINT32;\r typedef SInt32 ISTDINT32;\r #elif defined(__APPLE__) && defined(__MACH__)\r #include \r typedef u_int32_t ISTDUINT32;\r typedef int32_t ISTDINT32;\r #elif defined(__BEOS__)\r #include \r typedef u_int32_t ISTDUINT32;\r typedef int32_t ISTDINT32;\r #elif (defined(_MSC_VER) || defined(__BORLANDC__)) && (!defined(__MSDOS__))\r typedef unsigned __int32 ISTDUINT32;\r typedef __int32 ISTDINT32;\r #elif defined(__GNUC__)\r #include \r typedef uint32_t ISTDUINT32;\r typedef int32_t ISTDINT32;\r #else\r typedef unsigned long ISTDUINT32;\r typedef long ISTDINT32;\r #endif // platform\r #endif // __INTEGER_32_BITS__\r \r //=====================================================================\r // Integer Definition\r //=====================================================================\r #ifndef __IINT8_DEFINED\r #define __IINT8_DEFINED\r typedef char IINT8;\r #endif\r \r #ifndef __IUINT8_DEFINED\r #define __IUINT8_DEFINED\r typedef unsigned char IUINT8;\r #endif\r \r #ifndef __IUINT16_DEFINED\r #define __IUINT16_DEFINED\r typedef unsigned short IUINT16;\r #endif\r \r #ifndef __IINT16_DEFINED\r #define __IINT16_DEFINED\r typedef short IINT16;\r #endif\r \r #ifndef __IINT32_DEFINED\r #define __IINT32_DEFINED\r typedef ISTDINT32 IINT32;\r #endif\r \r #ifndef __IUINT32_DEFINED\r #define __IUINT32_DEFINED\r typedef ISTDUINT32 IUINT32;\r #endif\r \r #ifndef __IINT64_DEFINED\r #define __IINT64_DEFINED\r #if defined(_MSC_VER) || defined(__BORLANDC__)\r typedef __int64 IINT64;\r #else\r typedef long long IINT64;\r #endif\r #endif\r \r #ifndef __IUINT64_DEFINED\r #define __IUINT64_DEFINED\r #if defined(_MSC_VER) || defined(__BORLANDC__)\r typedef unsigned __int64 IUINT64;\r #else\r typedef unsigned long long IUINT64;\r #endif\r #endif\r \r #ifndef INLINE\r #if defined(__GNUC__)\r #if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))\r #define INLINE __inline__ __attribute__((always_inline))\r #else\r #define INLINE __inline__\r #endif\r #elif (defined(_MSC_VER) || defined(__BORLANDC__) || defined(__WATCOMC__))\r #define INLINE __inline\r #else\r #define INLINE\r #endif // __GNUC__\r #endif // INLINE\r \r #if (!defined(__cplusplus)) && (!defined(inline))\r #define inline INLINE\r #endif\r \r //=====================================================================\r // QUEUE DEFINITION\r //=====================================================================\r #ifndef __IQUEUE_DEF__\r #define __IQUEUE_DEF__\r \r namespace detail {\r /**\r @brief 通用链表实现的队列.\r @note\r 用于管理Segment队列,\r 通用链表可以支持在不同类型的链表中做转移,\r 通用链表实际上管理的就是一个最小的链表节点,\r 具体该链表节点所在的数据块可以通过该数据块在链表中的位置反向解析出来.\r @see IQUEUE_ENTRY\r */\r struct IQUEUEHEAD {\r struct IQUEUEHEAD *next, *prev;\r };\r typedef struct IQUEUEHEAD iqueue_head;\r } // namespace detail\r \r //---------------------------------------------------------------------\r // queue start\r //---------------------------------------------------------------------\r /**\r @def IQUEUE_HEAD_INIT\r @brief 通用链表头初始化列表\r */\r #define IQUEUE_HEAD_INIT(name) { &(name), &(name) }\r \r /**\r @def IQUEUE_HEAD\r @brief 构造通用链表头\r */\r #define IQUEUE_HEAD(name) \\\r struct IQUEUEHEAD name = IQUEUE_HEAD_INIT(name)\r \r /**\r @def IQUEUE_INIT\r @brief 节点初始化,指向自身\r */\r #define IQUEUE_INIT(ptr) ( \\\r (ptr)->next = (ptr), (ptr)->prev = (ptr))\r \r /**\r @def IOFFSETOF\r @brief 取TYPE的MEMBER到该TYPE结构体基地址的偏移字节数\r */\r #define IOFFSETOF(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\r \r /**\r @def IOFFSETOF\r @brief 取结构体地址\r */\r #define ICONTAINEROF(ptr, type, member) ( \\\r (type*)( ((char*)((type*)ptr)) - IOFFSETOF(type, member)) )\r \r /**\r @def IQUEUE_ENTRY\r @brief 通用链表取数据域指针\r @note\r 关于 IQUEUE_ENTRY 宏:\r 1.先看&((type *)0)->member:\r 把\"0\"强制转化为指针类型,则该指针一定指向\"0\"(数据段基址).\r 因为指针是\"type *\"型的,所以可取到以\"0\"为基地址的一个type型变量member域的地址.\r 那么这个地址也就等于member域到结构体基地址的偏移字节数.\r \r 2.再来看( (type *)( (char*)ptr-(size_t)(&((type *)0)->member) ) ):\r (char *)(ptr)使得指针的加减操作步长为一字节,\r (size_t)(&((type *)0)->member)等于ptr指向的member到该member所在结构体基地址的偏移字节数.\r 二者一减便得出该结构体的地址.转换为(type *)型的指针,大功告成.\r \r 比如 ikcp_parse_una 函数中的以下代码:\r @code\r struct IQUEUEHEAD *p, *next;\r for (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = next)\r {\r ikcp_seg *seg = iqueue_entry(p, ikcp_seg, node);\r }\r @endcode\r 其中的 ikcp_seg *seg = iqueue_entry(p, ikcp_seg, node) 展开则为:\r ikcp_seg *seg = ( (ikcp_seg*)( ( (char*)((ikcp_seg*)p) ) - ((size_t) &((ikcp_seg *)0)->node) ) );\r \r 则可达到以下效果 :\r 通过一个 IQUEUEHEAD 指针 p 得到一个指向该链表节点所在的数据块的 ikcp_seg 指针 seg\r \r 要把源代码中的宏展开,其实只要使用gcc进行预处理即可.\r gcc -E source.c > out.txt\r -E 表示只进行预处理,不进行编译.\r 预处理时会把注释当成空格处理掉,如果想保留其中的注释,可以加上 -C选项,即:\r gcc -E -C source.c > out.txt\r */\r #define IQUEUE_ENTRY(ptr, type, member) ICONTAINEROF(ptr, type, member)\r \r \r //---------------------------------------------------------------------\r // queue operation\r //---------------------------------------------------------------------\r \r /**\r @def IQUEUE_ADD\r @brief 插到链表某一元素的后面\r @code\r head(prev=head next=head),node_1(prev=node_1,next=node_1),node_2(prev=node_2,next=node_2)\r IQUEUE_ADD(node_1,head)\r headnode_1\r IQUEUE_ADD(node_2,node_1)\r headnode_1node_2head\r @endcode\r */\r #define IQUEUE_ADD(node, head) (\\\r (node)->prev = (head), (node)->next = (head)->next, \\\r (head)->next->prev = (node), (head)->next = (node))\r \r /**\r @def IQUEUE_ADD_TAIL\r @brief 插到链表头节点的前面,对于通用循环链表,就是尾插\r @code\r head(prev=head,next=head),node_1(prev=node_1,next=node_1),node_2(prev=node_2,next=node_2)\r IQUEUE_ADD_TAIL(node_1,head)\r node_1head\r IQUEUE_ADD_TAIL(node_2,node_1)\r headnode_2node_1head\r @endcode\r */\r #define IQUEUE_ADD_TAIL(node, head) (\\\r (node)->prev = (head)->prev, (node)->next = (head), \\\r (head)->prev->next = (node), (head)->prev = (node))\r \r /**\r @def IQUEUE_DEL_BETWEEN\r @brief 删除俩个节点之间的节点\r */\r #define IQUEUE_DEL_BETWEEN(p, n) ((n)->prev = (p), (p)->next = (n))\r \r /**\r @def IQUEUE_DEL\r @brief 链表中删除节点\r */\r #define IQUEUE_DEL(entry) (\\\r (entry)->next->prev = (entry)->prev, \\\r (entry)->prev->next = (entry)->next, \\\r (entry)->next = 0, (entry)->prev = 0)\r \r /**\r @def IQUEUE_DEL_INIT\r @brief 删除节点并重新初始化\r */\r #define IQUEUE_DEL_INIT(entry) do { \\\r IQUEUE_DEL(entry); IQUEUE_INIT(entry); } while (0)\r \r /**\r @def IQUEUE_IS_EMPTY\r @brief 链表判空\r */\r #define IQUEUE_IS_EMPTY(entry) ((entry) == (entry)->next)\r \r /**\r @def IQUEUE_FOREACH\r @brief 链表遍历(for头)\r */\r #define IQUEUE_FOREACH(pos, head) \\\r for( (pos) = (head)->next; (pos) != (head) ; (pos) = (pos)->next )\r \r /**\r @def IQUEUE_FOREACH_ENTRY\r @brief 链表成员后向遍历(for头)\r */\r #define IQUEUE_FOREACH_ENTRY(iterator, head, TYPE, MEMBER) \\\r for ((iterator) = IQUEUE_ENTRY((head)->next, TYPE, MEMBER); \\\r (!IQUEUE_IS_EMPTY((head))) && ((iterator) != nullptr) && (&((iterator)->MEMBER) != (head)); \\\r (iterator) = IQUEUE_ENTRY((iterator)->MEMBER.next, TYPE, MEMBER))\r \r /**\r @def IQUEUE_FOREACH_ENTRY_PREV\r @brief 链表成员前向遍历(for头)\r */\r #define IQUEUE_FOREACH_ENTRY_PREV(iterator, head, TYPE, MEMBER) \\\r for ((iterator) = IQUEUE_ENTRY((head)->prev, TYPE, MEMBER); \\\r (!IQUEUE_IS_EMPTY((head))) && ((iterator) != nullptr) && (&((iterator)->MEMBER) != (head)); \\\r (iterator) = IQUEUE_ENTRY((iterator)->MEMBER.prev, TYPE, MEMBER))\r \r /**\r @def IQUEUE_SPLICE\r @brief 给list换头\r @code\r head(prev=head,next=head),list(prev=node_2,next=node_1)\r listnode_1node_2list\r IQUEUE_SPLICE(list,head)\r headnode_1node_2head\r @endcode\r */\r #define IQUEUE_SPLICE(list, head) if (!IQUEUE_IS_EMPTY(list)) do { \\\r iqueue_head *first = (list)->next, *last = (list)->prev; \\\r iqueue_head *at = (head)->next; \\\r (first)->prev = (head), (head)->next = (first);\t\t\\\r (last)->next = (at), (at)->prev = (last); }\twhile (0)\r \r /**\r @def IQUEUE_SPLICE_INIT\r @brief 给list换头并重新初始化list头\r */\r #define IQUEUE_SPLICE_INIT(list, head) do {\t\\\r IQUEUE_SPLICE(list, head);\tIQUEUE_INIT(list); } while (0)\r \r #define iqueue_init\t\t IQUEUE_INIT\r #define iqueue_entry\t IQUEUE_ENTRY\r #define iqueue_add\t\t IQUEUE_ADD\r #define iqueue_add_tail\t IQUEUE_ADD_TAIL\r #define iqueue_del\t\t IQUEUE_DEL\r #define iqueue_del_init\t IQUEUE_DEL_INIT\r #define iqueue_is_empty IQUEUE_IS_EMPTY\r #define iqueue_foreach IQUEUE_FOREACH\r #define iqueue_foreach_entry IQUEUE_FOREACH_ENTRY\r #define iqueue_foreach_entry_prev IQUEUE_FOREACH_ENTRY_PREV\r // #define iqueue_splice IQUEUE_SPLICE\r // #define iqueue_splice_init IQUEUE_SPLICE_INIT\r \r #ifdef _MSC_VER\r #pragma warning(disable:4311)\r #pragma warning(disable:4312)\r #pragma warning(disable:4996)\r #endif\r \r #endif // __IQUEUE_DEF__\r \r \r //---------------------------------------------------------------------\r // WORD ORDER\r //---------------------------------------------------------------------\r #ifndef IWORDS_BIG_ENDIAN\r \r #ifdef _BIG_ENDIAN_\r #if _BIG_ENDIAN_\r #define IWORDS_BIG_ENDIAN 1\r #endif\r #endif // _BIG_ENDIAN_\r \r #ifndef IWORDS_BIG_ENDIAN\r #if defined(__hppa__) || \\\r defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \\\r (defined(__MIPS__) && defined(__MIPSEB__)) || \\\r defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \\\r defined(__sparc__) || defined(__powerpc__) || \\\r defined(__mc68000__) || defined(__s390x__) || defined(__s390__)\r #define IWORDS_BIG_ENDIAN 1\r #endif\r #endif // IWORDS_BIG_ENDIAN\r \r #ifndef IWORDS_BIG_ENDIAN\r #define IWORDS_BIG_ENDIAN 0\r #endif\r \r #endif // IWORDS_BIG_ENDIAN\r \r //=====================================================================\r namespace detail {\r /**\r @brief KCP数据包\r @note\r cmd: command,标识Segment的指令类型:\r 1.数据包(IKCP_CMD_PUSH):\r 最基础的Segment,用于发送应用层数据给远端.\r 每个数据包有自己的sn,发送后等远端返回ack包才会从缓存中移除(两端通过sn确认哪些包已收到).\r 2.ACK包(IKCP_CMD_ACK):\r 告诉远端自己已收到了远端发送的哪个编号的数据sn.\r 3.窗口大小探测包(IKCP_CMD_WASK):\r 询问远端的接收窗口大小.\r 本地发送数据时,会根据远端的窗口大小来控制发送的数据量.\r 每个数据包的包头中带有发送方当前的接收窗口大小wnd.\r 当远端的接收窗口大小为0时,本机将不会再向远端发送数据,\r 此时也就不会有远端的回传数据从而导致无法更新远端窗口大小.\r 因此需要单独的一类远端窗口大小探测包,在远端接收窗口大小为0时,\r 隔一段时间询问一次,从而让本地有机会再开始重传数据.\r 4.窗口大小回应包(IKCP_CMD_WINS):\r 回应远端自己的数据接收窗口大小.\r frg: fragment,记录了分片时的倒序序号, 当输出数据大于MSS 时,需要将数据进行分片.\r KCP发送数据时会给加入snd_queue的segment分配序号,\r 接收端在接收到这些segment时(0代表数据包接收完毕),就会根据frg将若干个segment合并成一个,再返回给应用层.\r \r kcp包头,24bytes,包含了一些必要的信息,包的结构可以在函数ikcp_encode_seg函数的编码过程中看出来:\r @code\r ||\r +--------+--------+--------+--------+\r | conv | conv: 会话序号\r +--------+--------+--------+--------+ cmd: 指令类型\r | cmd | frg | wnd | frg: 分片序号\r +--------+--------+--------+--------+ wnd: 接收窗口大小\r | ts | ts: 发送的时间戳\r +--------+--------+--------+--------+\r | sn | sn: 包序号\r +--------+--------+--------+--------+\r | una | una: 当前未收到的序号\r +--------+--------+--------+--------+\r | len | len: 数据段长度\r +--------+--------+--------+--------+\r @endcode\r */\r struct IKCPSEG\r {\r struct IQUEUEHEAD node;/**= max fragment size\r const IUINT32 IKCP_MTU_DEF = 1400;\r const IUINT32 IKCP_ACK_FAST = 3;\r const IUINT32 IKCP_INTERVAL = 100;\r const IUINT32 IKCP_INTERVAL_MIN = 10;\r const IUINT32 IKCP_INTERVAL_LIMIT = 5000;\r const IUINT32 IKCP_OVERHEAD = 24;\t\t// kcp packet header size:24bytes\r const IUINT32 IKCP_DEADLINK = 20; // max resend number\r const IUINT32 IKCP_THRESH_INIT = 2;\r const IUINT32 IKCP_THRESH_MIN = 2;\r const IUINT32 IKCP_PROBE_INIT = 7000;\t// 探查时间间隔 7 secs\r const IUINT32 IKCP_PROBE_LIMIT = 120000;// 探查时间上限 120 secs\r \r //---------------------------------------------------------------------\r // encode / decode\r //---------------------------------------------------------------------\r \r /** @brief encode 8 bits unsigned int */\r static inline char *ikcp_encode8u(char *p, unsigned char c) {\r *(unsigned char*)p++ = c;\r return p;\r }\r \r /** @brief decode 8 bits unsigned int */\r static inline const char *ikcp_decode8u(const char *p, unsigned char *c) {\r *c = *(unsigned char*)p++;\r return p;\r }\r \r /** @brief encode 16 bits unsigned int (lsb) */\r static inline char *ikcp_encode16u(char *p, unsigned short w)\r {\r #if IWORDS_BIG_ENDIAN\r *(unsigned char*)(p + 0) = (w & 255);\r *(unsigned char*)(p + 1) = (w >> 8);\r #else\r *(unsigned short*)(p) = w;\r #endif\r p += 2;\r return p;\r }\r \r /** @brief decode 16 bits unsigned int (lsb) */\r static inline const char *ikcp_decode16u(const char *p, unsigned short *w)\r {\r #if IWORDS_BIG_ENDIAN\r *w = *(const unsigned char*)(p + 1);\r *w = *(const unsigned char*)(p + 0) + (*w > 0) & 0xff);\r *(unsigned char*)(p + 1) = (unsigned char)((l >> 8) & 0xff);\r *(unsigned char*)(p + 2) = (unsigned char)((l >> 16) & 0xff);\r *(unsigned char*)(p + 3) = (unsigned char)((l >> 24) & 0xff);\r #else\r *(IUINT32*)p = l;\r #endif\r p += 4;\r return p;\r }\r \r /** @brief decode 32 bits unsigned int (lsb) */\r static inline const char *ikcp_decode32u(const char *p, IUINT32 *l)\r {\r #if IWORDS_BIG_ENDIAN\r *l = *(const unsigned char*)(p + 3);\r *l = *(const unsigned char*)(p + 2) + (*l = b ? a : b;\r }\r \r /** @brief 范围限制 保证结果值在范围内 */\r static inline IUINT32 _ibound_(IUINT32 lower, IUINT32 middle, IUINT32 upper) {\r return _imin_(_imax_(lower, middle), upper);\r }\r \r static inline long _itimediff(IUINT32 later, IUINT32 earlier) {\r return ((IINT32)(later - earlier));\r }\r \r static void*(*ikcp_malloc_hook)(size_t) = NULL;\r static void(*ikcp_free_hook)(void *) = NULL;\r \r /** @brief internal malloc */\r static void* ikcp_malloc(size_t size) {\r return ikcp_malloc_hook ? ikcp_malloc_hook(size) : malloc(size);\r }\r \r /** @brief internal free */\r static void ikcp_free(void *ptr) {\r ikcp_free_hook ? ikcp_free_hook(ptr) : free(ptr);\r }\r \r /** @brief allocate a new kcp segment */\r static ikcp_seg* ikcp_segment_new(ikcpcb *kcp, int size) {\r return (ikcp_seg*)ikcp_malloc(sizeof(ikcp_seg) + size);\r }\r \r /** @brief delete a segment */\r static void ikcp_segment_delete(ikcpcb *kcp, ikcp_seg *seg) {\r ikcp_free(seg);\r }\r \r /** @brief output segment */\r static int ikcp_output(ikcpcb *kcp, const void *data, int size) {\r assert(kcp);\r assert(kcp->output);\r ikcp_log(kcp, IKCP_LOG_OUTPUT, \"[kcp] output %ld bytes\", (long)size);\r if (size == 0) return 0;\r return kcp->output((const char*)data, size, kcp, kcp->user);\r }\r \r /** @brief 打印队列分片信息sn ts */\r static void ikcp_qprint(const char *name, const iqueue_head *head)\r {\r printf(\": [\", name);\r ikcp_seg *seg = nullptr;\r iqueue_foreach_entry(seg, head, ikcp_seg, node) {\r printf(\"(%lu %d)\", (unsigned long)seg->sn, (int)(seg->ts % 10000));\r }\r printf(\"]\\n\");\r }\r \r /** @brief 根据rtt更新ACK */\r static void ikcp_update_ack(ikcpcb *kcp, IINT32 rtt)\r {\r if (kcp->rx_srtt == 0) {\r kcp->rx_srtt = rtt;\r kcp->rx_rttval = rtt / 2;\r }\r else {\r IINT32 delta = rtt - kcp->rx_srtt;\r if (delta rx_rttval = (3 * kcp->rx_rttval + delta) / 4; // 平均偏差更新权重0.25\r kcp->rx_srtt = (7 * kcp->rx_srtt + rtt) / 8; // 平均时延更新权重0.125\r if (kcp->rx_srtt rx_srtt = 1;\r }\r IINT32 rto = kcp->rx_srtt + _imax_(kcp->interval, 4 * kcp->rx_rttval); // 类似TCP\r kcp->rx_rto = _ibound_(kcp->rx_minrto, rto, IKCP_RTO_MAX); // 范围限制\r }\r \r /** @brief 更新本地snd_una:第一个未确认包序号 */\r static void ikcp_shrink_buf(ikcpcb *kcp)\r {\r if (!iqueue_is_empty(&kcp->snd_buf)) {\r ikcp_seg *seg = iqueue_entry(kcp->snd_buf.next, ikcp_seg, node);\r kcp->snd_una = seg->sn; // snd_una指向snd_buf首端\r }\r else {\r kcp->snd_una = kcp->snd_nxt;// snd_una指向下一个待分配包序号\r }\r }\r \r /** @brief 分析ack的sn,在snd_buf中找到第一个包序号为sn的ikcp_seg删除之 */\r static void ikcp_parse_ack(ikcpcb *kcp, IUINT32 sn)\r {\r if (sn snd_una || sn >= kcp->snd_nxt)\r return;// sn小于snd_una或大于等于snd_nxt,忽略该包,snd_una之前是完备的,snd_nxt之后未发送,不应收到ACK\r \r iqueue_head *p;\r iqueue_foreach(p, &kcp->snd_buf) {\r ikcp_seg *seg = iqueue_entry(p, ikcp_seg, node);\r if (seg->sn == sn) {\r iqueue_del(p);\r ikcp_segment_delete(kcp, seg);\r kcp->nsnd_buf--;\r break;\r }\r if (seg->sn > sn) {\r break;\r }\r }\r }\r \r /** @brief 分析una,删除snd_buf中小于una的segment(都被远端收到了) */\r static void ikcp_parse_una(ikcpcb *kcp, IUINT32 una)\r {\r iqueue_head *p, *next;\r for (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = next) {\r ikcp_seg *seg = iqueue_entry(p, ikcp_seg, node);\r next = p->next;\r if (seg->sn nsnd_buf--;\r }\r else {\r break;\r }\r }\r }\r \r /**\r @brief 处理快速重传\r @note\r 遍历snd_buf更新各个Segment中ACK跳过的次数,\r 若Segment的sn小于接收到的ACK包的sn, 则Segment的fastack++,\r 若fastack超过指定阈值,则启动快速重传.\r */\r static void ikcp_parse_fastack(ikcpcb *kcp, IUINT32 sn)\r {\r if (sn snd_una || sn >= kcp->snd_nxt)\r return;\r \r ikcp_seg *seg = nullptr;\r iqueue_foreach_entry(seg, &kcp->snd_buf, ikcp_seg, node) {\r if (seg->sn fastack++;\r }\r else {\r break;\r }\r }\r }\r \r /**\r @brief 将该报文的确认ACK放入ACK列表acklist中\r push当前包的ACK给远端(会在flush中发送ACK出去)\r */\r static void ikcp_ack_push(ikcpcb *kcp, IUINT32 sn, IUINT32 ts)\r {\r IUINT32 newsize = kcp->ackcount + 1;\r if (newsize > kcp->ackblock) {\r IUINT32 *acklist;\r IUINT32 newblock;\r \r for (newblock = 8; newblock acklist != NULL) {\r IUINT32 i;\r for (i = 0; i ackcount; i++) {\r acklist[i * 2 + 0] = kcp->acklist[i * 2 + 0];\r acklist[i * 2 + 1] = kcp->acklist[i * 2 + 1];\r }\r ikcp_free(kcp->acklist);\r }\r \r kcp->acklist = acklist;\r kcp->ackblock = newblock;\r }\r \r IUINT32 *ptr = &kcp->acklist[kcp->ackcount * 2];\r ptr[0] = sn;\r ptr[1] = ts;\r kcp->ackcount++;\r }\r \r /** @brief 从acklist中取sn和ts */\r static void ikcp_ack_get(const ikcpcb *kcp, int p, IUINT32 *sn, IUINT32 *ts)\r {\r if (sn) sn[0] = kcp->acklist[p * 2 + 0];\r if (ts) ts[0] = kcp->acklist[p * 2 + 1];\r }\r \r /**\r @brief 解析数据\r @note\r 在rcv_buf中遍历一次,判断是否已经接收过这个数据包,\r 如果数据包不存在则添加到rcv_buf中,之后将可用的Segment转移到rcv_queue中\r */\r static void ikcp_parse_data(ikcpcb *kcp, ikcp_seg *newseg)\r {\r assert(kcp);\r assert(newseg);\r \r if (newseg->sn >= (kcp->rcv_nxt + kcp->rcv_wnd)\r || newseg->sn rcv_nxt) {\r ikcp_segment_delete(kcp, newseg);// 超出接收窗口大小或rcv_queue已经接收过这个sn的数据包了\r return;\r }\r \r // rcv_buf 从后往前遍历,判断是否已经接收过这个数据包,并且找到新数据newseg应该插入到 rcv_buf 的位置\r \r int repeat = 0;\r iqueue_head *p, *prev;\r for (p = kcp->rcv_buf.prev; p != &kcp->rcv_buf; p = prev) {\r ikcp_seg *seg = iqueue_entry(p, ikcp_seg, node);\r prev = p->prev;\r \r if (seg->sn == newseg->sn) {\r repeat = 1;//已经接收过\r break;\r }\r if (seg->sn sn) {\r break;//未接收\r }\r }\r \r if (repeat == 0) {\r iqueue_init(&newseg->node);\r iqueue_add(&newseg->node, p);\r kcp->nrcv_buf++;\r }\r else {\r // 如果已经接收过了,则丢弃\r ikcp_segment_delete(kcp, newseg);\r }\r \r #if 0\r ikcp_qprint(\"rcvbuf\", &kcp->rcv_buf);\r printf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\r #endif\r \r //遍历rcv_buf找到与下一个待接收的序号相同的segment,且接收队列还有位置\r //segment移出rcv_buf移入rcv_queue,rcv_nxt的连续性保证rcv_queue的有序\r ikcp_seg *seg = nullptr;\r iqueue_foreach_entry(seg, &kcp->rcv_buf, ikcp_seg, node) {\r if (seg->sn == kcp->rcv_nxt && kcp->nrcv_que rcv_wnd) {\r iqueue_del_init(&seg->node);\r kcp->nrcv_buf--;\r iqueue_add_tail(&seg->node, &kcp->rcv_queue);\r kcp->nrcv_que++;\r kcp->rcv_nxt++;\r }\r else {\r break;\r }\r };\r \r #if 0\r ikcp_qprint(\"queue\", &kcp->rcv_queue);\r printf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\r printf(\"snd(buf=%d, queue=%d)\\n\", kcp->nsnd_buf, kcp->nsnd_que);\r printf(\"rcv(buf=%d, queue=%d)\\n\", kcp->nrcv_buf, kcp->nrcv_que);\r #endif\r }\r \r /** @brief seg内容复制到ptr */\r static char *ikcp_encode_seg(char *ptr, const ikcp_seg *seg)\r {\r ptr = ikcp_encode32u(ptr, seg->conv);\r ptr = ikcp_encode8u(ptr, (IUINT8)seg->cmd);\r ptr = ikcp_encode8u(ptr, (IUINT8)seg->frg);\r ptr = ikcp_encode16u(ptr, (IUINT16)seg->wnd);\r ptr = ikcp_encode32u(ptr, seg->ts);\r ptr = ikcp_encode32u(ptr, seg->sn);\r ptr = ikcp_encode32u(ptr, seg->una);\r ptr = ikcp_encode32u(ptr, seg->len);\r return ptr;\r }\r \r /** @brief 返回剩余接收窗口大小(接收窗口大小-接收队列大小) */\r static inline int ikcp_wnd_unused(const ikcpcb *kcp)\r {\r if (kcp->nrcv_que rcv_wnd) {\r return kcp->rcv_wnd - kcp->nrcv_que; // 剩余接收窗口大小(接收窗口大小-接收队列大小)\r }\r return 0;\r }\r \r } // namespace detail\r \r \r //=====================================================================\r // interface\r //=====================================================================\r \r \r //---------------创建及设置-------------------\r \r /** @brief 可以指定allocator */\r void inline ikcp_allocator(void* (*new_malloc)(size_t), void(*new_free)(void*))\r {\r using namespace detail;\r ikcp_malloc_hook = new_malloc;\r ikcp_free_hook = new_free;\r };\r \r /**\r @brief 从指针获取conv\r @param[in,out] ptr IUINT32*类型,读一个conv后ptr+=4\r */\r IUINT32 ikcp_getconv(const void *ptr)\r {\r using namespace detail;\r IUINT32 conv;\r ikcp_decode32u((const char*)ptr, &conv);\r return conv;\r };\r \r /**\r @brief 创建 kcp上下文\r @param conv 会话标识,俩端必须相同\r @param user 用户数据用于output回调使用\r */\r ikcpcb* ikcp_create(IUINT32 conv, void *user)\r {\r /*---------------------------------------------------------\r create a new kcpcb\r 首先需要创建一个kcp用于管理接下来的工作过程,\r 在创建的时候,默认的发送、接收以及远端的窗口大小均为32,\r mtu大小为1400bytes,mss为1400-24=1376bytes,\r 超时重传时间为200毫秒,最小重传时间为100毫秒,\r kcp内部间隔最小时间为100毫秒(kcp->interval = IKCP_INTERVAL;),\r 最大重发次数 dead_link 为IKCP_DEADLINK即20.\r ------------------------------------------------------------*/\r using namespace detail;\r ikcpcb *kcp = (ikcpcb*)ikcp_malloc(sizeof(ikcpcb));\r if (kcp == NULL) return NULL;\r \r #ifdef KCP_EXTENTION\r kcp->rdc_check_ts = 0;\r kcp->rdc_check_interval = IKCP_RDC_CHK_INTERVAL;\r kcp->rdc_rtt_limit = IKCP_RDC_RTT_LIMIT;\r kcp->is_rdc_on = 0;\r kcp->rdc_close_try_times = 0;\r kcp->rdc_close_try_threshold = IKCP_RDC_CLOSE_TRY_THRESHOLD;\r kcp->snd_cnt = 0;\r kcp->timeout_resnd_cnt = 0;\r kcp->loss_rate = 0;\r kcp->rdc_loss_rate_limit = IKCP_RDC_LOSS_RATE_LIMIT;\r #endif // KCP_EXTENTION\r \r kcp->conv = conv;\r kcp->user = user;\r kcp->snd_una = 0;\r kcp->snd_nxt = 0;\r kcp->rcv_nxt = 0;\r kcp->ts_probe = 0;\r kcp->probe_wait = 0;\r kcp->snd_wnd = IKCP_WND_SND;\r kcp->rcv_wnd = IKCP_WND_RCV;\r kcp->rmt_wnd = IKCP_WND_RCV;\r kcp->cwnd = 0;\r kcp->incr = 0;\r kcp->probe = 0;\r kcp->mtu = IKCP_MTU_DEF;\r kcp->mss = kcp->mtu - IKCP_OVERHEAD;\r kcp->stream = 0;\r \r kcp->buffer = (char*)ikcp_malloc((kcp->mtu + IKCP_OVERHEAD) * 3);\r if (kcp->buffer == NULL) {\r ikcp_free(kcp);\r return NULL;\r }\r \r iqueue_init(&kcp->snd_queue);\r iqueue_init(&kcp->rcv_queue);\r iqueue_init(&kcp->snd_buf);\r iqueue_init(&kcp->rcv_buf);\r kcp->nrcv_buf = 0;\r kcp->nsnd_buf = 0;\r kcp->nrcv_que = 0;\r kcp->nsnd_que = 0;\r kcp->state = 0;\r kcp->acklist = NULL;\r kcp->ackblock = 0;\r kcp->ackcount = 0;\r kcp->rx_srtt = 0;\r kcp->rx_rttval = 0;\r kcp->rx_rto = IKCP_RTO_DEF;\r kcp->rx_minrto = IKCP_RTO_MIN;\r kcp->current = 0;\r kcp->interval = IKCP_INTERVAL;\r kcp->ts_flush = IKCP_INTERVAL;\r kcp->nodelay = 0;\r kcp->updated = 0;\r kcp->logmask = ~0;\r kcp->ssthresh = IKCP_THRESH_INIT;\r kcp->fastresend = 0;\r kcp->nocwnd = 0;\r kcp->dead_link = IKCP_DEADLINK;\r kcp->output = NULL;\r kcp->writelog = NULL;\r \r return kcp;\r };\r \r /** @brief release kcp上下文 */\r void ikcp_release(ikcpcb *kcp)\r {\r using namespace detail;\r assert(kcp);\r if (kcp) {\r ikcp_seg *seg = nullptr;\r iqueue_foreach_entry(seg, &kcp->snd_buf, ikcp_seg, node) {\r iqueue_del(&seg->node);\r ikcp_segment_delete(kcp, seg);\r }\r iqueue_foreach_entry(seg, &kcp->rcv_buf, ikcp_seg, node) {\r iqueue_del(&seg->node);\r ikcp_segment_delete(kcp, seg);\r }\r iqueue_foreach_entry(seg, &kcp->snd_queue, ikcp_seg, node) {\r iqueue_del(&seg->node);\r ikcp_segment_delete(kcp, seg);\r }\r iqueue_foreach_entry(seg, &kcp->rcv_queue, ikcp_seg, node) {\r iqueue_del(&seg->node);\r ikcp_segment_delete(kcp, seg);\r }\r if (kcp->buffer) ikcp_free(kcp->buffer);\r if (kcp->acklist) ikcp_free(kcp->acklist);\r \r kcp->nrcv_buf = 0;\r kcp->nsnd_buf = 0;\r kcp->nrcv_que = 0;\r kcp->nsnd_que = 0;\r kcp->ackcount = 0;\r kcp->buffer = NULL;\r kcp->acklist = NULL;\r ikcp_free(kcp);\r }\r };\r \r /** @brief 设置MTU大小 默认1400 */\r int ikcp_setmtu(ikcpcb *kcp, int mtu)\r {\r using namespace detail;\r assert(kcp);\r if (mtu mtu = mtu;\r kcp->mss = kcp->mtu - IKCP_OVERHEAD;\r \r ikcp_free(kcp->buffer);\r kcp->buffer = buffer;\r return 0;\r };\r \r /** @brief 设置收发窗口大小 */\r int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd)\r {\r using namespace detail;\r assert(kcp);\r if (sndwnd > 0) {\r kcp->snd_wnd = sndwnd;\r }\r if (rcvwnd > 0) { // must >= max fragment size\r kcp->rcv_wnd = _imax_(rcvwnd, IKCP_WND_RCV);\r }\r return 0;\r };\r \r /**\r @brief 快速发送设置\r @param nodelay 是否非退让流控模式,默认false 0\r @param interval 内部刷新间隔ms.默认100ms\r @param resend 是否快速重传,默认false 0,大于0的为快传阈值(ACK跨越几次重传)\r @param nc 0:普通拥塞控制(默认), 1:关闭拥塞控制\r @note\r fastest: ikcp_nodelay(kcp, 1, 20, 2, 1)\r */\r int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)\r {\r using namespace detail;\r assert(kcp);\r if (nodelay >= 0) {\r kcp->nodelay = nodelay;\r if (nodelay) {\r kcp->rx_minrto = IKCP_RTO_NDL; //最小重传超时时间(如果需要可以设置更小)\r }\r else {\r kcp->rx_minrto = IKCP_RTO_MIN;\r }\r }\r if (interval >= 0) {\r if (interval > IKCP_INTERVAL_LIMIT)\r interval = IKCP_INTERVAL_LIMIT;\r else if (interval interval = interval; //内部flush刷新时间\r }\r if (resend >= 0) {// ACK被跳过resend次数后直接重传该包, 而不等待超时\r kcp->fastresend = resend; // fastresend : 触发快速重传的重复ACK个数\r }\r if (nc >= 0) {\r kcp->nocwnd = nc;\r }\r return 0;\r };\r \r /** @brief 设置update内部刷新间隔,默认100ms */\r int ikcp_interval(ikcpcb *kcp, int interval)\r {\r if (interval > 5000) interval = 5000;\r else if (interval interval = interval;\r return 0;\r };\r \r /** @brief 记录日志 */\r void ikcp_log(ikcpcb *kcp, int mask, const char *fmt, ...)\r {\r if ((mask & kcp->logmask) == 0 || kcp->writelog == NULL) return;\r char buffer[1024];\r va_list argptr;\r va_start(argptr, fmt);\r vsprintf(buffer, fmt, argptr);\r va_end(argptr);\r kcp->writelog(buffer, kcp, kcp->user);\r };\r \r //---------------KCP驱动-------------------\r \r /**\r @brief 探测何时需要调用ikcp_update\r @return ms\r @note\r 具体的时间取决于上次update后更新的下次时间,snd_buf中的最小超时重传时间以及update内部更新时间中的最小值\r 如果没有ikcp_input/_send调用,则使用ikcp_check返回的时间调用ikcp_update,以减少不必要的调用\r 用途:实现一个类似epoll的机制,或在处理大量kcp连接时优化ikcp_update.\r */\r IUINT32 ikcp_check(const ikcpcb *kcp, IUINT32 current)\r {\r using namespace detail;\r IUINT32 ts_flush = kcp->ts_flush;\r IINT32 tm_packet = 0x7fffffff;//下一次重传时间差\r \r if (kcp->updated == 0) {\r return current;//如果未调用过update，立马调用\r }\r \r if (_itimediff(current, ts_flush) >= 10000 ||\r _itimediff(current, ts_flush) = 0) {\r return current;\r }\r \r IUINT32 tm_flush = (IUINT32)_itimediff(ts_flush, current);// 下一次刷新时间差，此时ts_flush > current\r \r ikcp_seg *seg;\r iqueue_foreach_entry(seg, &kcp->snd_buf, ikcp_seg, node) {\r IINT32 diff = _itimediff(seg->resendts, current);\r if (diff interval);\r return current + minimal;\r };\r \r /**\r @brief 内部发包\r @note\r 给远端发送ack确认包\r 检查是否需要窗口探测(发送窗口探测包或窗口告知包)\r 进行窗口计算控制，将需要发送的Segment从snd_queue移动到snd_buf中\r 检查snd_buf，处理快速重传与超时重传\r @see ikcp_output\r */\r void ikcp_flush(ikcpcb *kcp)\r {\r using namespace detail;\r //检查 kcp->update 是否更新,未更新直接返回.\r //kcp->update 由 ikcp_update 更新,\r //上层应用需要每隔一段时间(10-100ms)调用 ikcp_update 来驱动 KCP 发送数据;\r if (kcp->updated == 0) return;\r \r IUINT32 current = kcp->current;\r char *buffer = kcp->buffer;\r char *ptr = buffer;\r \r int change = 0; // 标识需要快速重传(ack跳过次数超阈值)\r int lost = 0; // 标识发生报文丢失(超时)\r \r ikcp_seg seg;\r seg.conv = kcp->conv;\r seg.cmd = IKCP_CMD_ACK;\r seg.frg = 0;\r seg.wnd = ikcp_wnd_unused(kcp);\r seg.una = kcp->rcv_nxt;\r seg.len = 0;\r seg.sn = 0;\r seg.ts = 0;\r \r // 准备将acklist中记录的ACK报文发送出去,取acklist中ACK报文的sn和ts字段,填充到待发ack包\r int ackcount = kcp->ackcount;\r for (int i = 0; i (int)kcp->mtu) {\r //1个mtu内无法继续添加ACK包，先发送缓存区内的数据包\r ikcp_output(kcp, buffer, size);\r ptr = buffer;\r }\r ikcp_ack_get(kcp, i, &seg.sn, &seg.ts);\r ptr = ikcp_encode_seg(ptr, &seg);\r }\r kcp->ackcount = 0;\r \r // 如果远端窗口大小为0需要对远端窗口进行探测.\r // 由于 KCP 流量控制依赖于远端通知其可接受窗口的大小,\r // 一旦远端接受窗口 kcp->rmt_wnd 为0,那么本地将不会再向远端发送数据,\r // 因此就没有机会从远端接受 ACK 报文,从而没有机会更新远端窗口大小.\r // 在这种情况下,KCP 需要发送窗口探测报文到远端,待远端回复窗口大小后,后续传输才可以继续\r if (kcp->rmt_wnd == 0) {\r if (kcp->probe_wait == 0) {\r // 初始化探测间隔和下一次探测时间\r kcp->probe_wait = IKCP_PROBE_INIT;\r kcp->ts_probe = kcp->current + kcp->probe_wait;\r }\r else {\r if (_itimediff(kcp->current, kcp->ts_probe) >= 0) { // 当前时间 >= 下一次探查窗口的时间\r if (kcp->probe_wait probe_wait = IKCP_PROBE_INIT;\r kcp->probe_wait += kcp->probe_wait / 2; // 等待时间变为之前的1.5倍\r if (kcp->probe_wait > IKCP_PROBE_LIMIT)\r kcp->probe_wait = IKCP_PROBE_LIMIT; // 若超过上限,设置为上限值\r kcp->ts_probe = kcp->current + kcp->probe_wait; // 计算下次探查窗口的时间戳\r kcp->probe |= IKCP_ASK_SEND; // 设置探查变量.IKCP_ASK_SEND表示请求远端告知窗口大小\r }\r }\r }\r else {\r kcp->ts_probe = 0;\r kcp->probe_wait = 0;\r }\r \r // 发送窗口探测报文\r if (kcp->probe & IKCP_ASK_SEND) {\r seg.cmd = IKCP_CMD_WASK;\r int size = (int)(ptr - buffer);\r if (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\r ikcp_output(kcp, buffer, size);\r ptr = buffer;\r }\r ptr = ikcp_encode_seg(ptr, &seg);\r }\r \r // 发送窗口告知报文\r if (kcp->probe & IKCP_ASK_TELL) {\r seg.cmd = IKCP_CMD_WINS;\r int size = (int)(ptr - buffer);\r if (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\r ikcp_output(kcp, buffer, size);\r ptr = buffer;\r }\r ptr = ikcp_encode_seg(ptr, &seg);\r }\r \r kcp->probe = 0;\r \r // 计算本次发送可用的窗口大小,这里 KCP 采用了可以配置的策略,\r // 正常流控下,KCP 的窗口大小由\r // 发送窗口snd_wnd和远端接收窗口rmt_wnd以及根据拥塞控制计算得到的kcp->cwnd三者共同决定;\r // 但是当开启了nocwnd模式(非退让流控)时,窗口大小仅由前两者决定\r IUINT32 cwnd = _imin_(kcp->snd_wnd, kcp->rmt_wnd);\r if (kcp->nocwnd == 0) cwnd = _imin_(kcp->cwnd, cwnd);\r \r // 将缓存在snd_queue中的数据移到snd_buf中等待发送\r // 移动的包的数量不会超过snd_una + cwnd - snd_nxt,确保发送的数据不会让接收方的接收队列溢出.\r // 该功能类似于TCP协议中的滑动窗口.\r while ((kcp->snd_nxt snd_una + cwnd) && !iqueue_is_empty(&kcp->snd_queue))\r {\r ikcp_seg *newseg = iqueue_entry(kcp->snd_queue.next, ikcp_seg, node);\r iqueue_del(&newseg->node); //从发送消息队列中,删除节点\r iqueue_add_tail(&newseg->node, &kcp->snd_buf); //然后把删除的节点,加入到kcp的发送缓存队列中\r kcp->nsnd_que--;\r kcp->nsnd_buf++;\r \r newseg->conv = kcp->conv; //会话id\r newseg->cmd = IKCP_CMD_PUSH;\r newseg->wnd = seg.wnd;\r newseg->ts = current;\r newseg->sn = kcp->snd_nxt++; //下一个待发包的序号\r newseg->una = kcp->rcv_nxt; //待接收的下一个消息序号\r newseg->resendts = current; //下次超时重传的时间戳\r newseg->rto = kcp->rx_rto; //由ack接收延迟计算出来的重传超时时间\r newseg->fastack = 0; //收到ACK时计算的该分片被跳过的累计次数\r newseg->xmit = 0; //发送分片的次数,每发送一次加一\r }\r \r // 在发送数据之前,先设置快重传的次数和重传间隔;\r // KCP 允许设置快重传的次数,即 fastresend 参数.\r // 例如设置 fastresend 为2,并且发送端发送了1,2,3,4,5几个包,\r // 收到远端的ACK: 1, 3, 4, 5,当收到ACK3时,KCP知道2被跳过1次,\r // 收到ACK4时,知道2被“跳过”了2次,此时可以认为2号丢失,不用等超时,直接重传2号包;\r // 每个报文的 fastack 记录了该报文被跳过了几次,\r // 由函数 ikcp_parse_fastack 更新.于此同时,KCP 也允许设置 nodelay 参数,\r // 当激活该参数时,每个报文的超时重传时间将由 x2 变为 x1.5,即加快报文重传:\r IUINT32 resent = (kcp->fastresend > 0) ? (IUINT32)kcp->fastresend : 0xffffffff; // 快重传次数\r IUINT32 rtomin = (kcp->nodelay == 0) ? (kcp->rx_rto >> 3) : 0; // nodelay模式没有最小rto，否则为rx_rto/8\r \r // 遍历snd_buf处理第一次发送及重传\r ikcp_seg * segment = nullptr;\r iqueue_foreach_entry(segment, &kcp->snd_buf, ikcp_seg, node)\r {\r int needsend = 0;\r if (segment->xmit == 0) {\r // 第一次发送,xmit为0,赋值rto及resendts\r needsend = 1;\r segment->xmit++;\r segment->rto = kcp->rx_rto;\r segment->resendts = current + segment->rto + rtomin;\r }\r else if (_itimediff(current, segment->resendts) >= 0) {\r // 超时重传,超过segment重发时间,却仍在send_buf中,说明长时间未收到ACK,认为丢失,重发\r needsend = 1;\r segment->xmit++;\r #ifdef KCP_EXTENTION\r kcp->timeout_resnd_cnt++;\r #endif // KCP_EXTENTION\r // 更新重传时间,默认rto*2,开启nodelay模式则rto*1.5,并记录lost标志.\r if (kcp->nodelay == 0) {\r segment->rto += kcp->rx_rto; // 以2倍的方式来增长(TCP的RTO默认也是2倍增长)\r }\r else {\r segment->rto += kcp->rx_rto / 2; // 可以以1.5倍的速度增长\r }\r segment->resendts = current + segment->rto;\r lost = 1; // 记录出现了报文丢失\r }\r else if (segment->fastack >= resent) {\r // 快速重传,达到快速重传阈值,重新发送\r needsend = 1;\r segment->xmit++;\r segment->fastack = 0;\r segment->resendts = current + segment->rto;\r change = 1; // 标识快重传发生\r }\r \r if (needsend) {\r segment->ts = current;\r segment->wnd = seg.wnd;\r segment->una = kcp->rcv_nxt;\r \r int size = (int)(ptr - buffer);//缓存kcp包大小\r int need = IKCP_OVERHEAD + segment->len; //seg包头大小 + seg数据段大小\r if (size + need > (int)kcp->mtu) {\r ikcp_output(kcp, buffer, size);//1个mtu内无法继续添加需求大小的数据包，先发送当前缓存区的数据包\r #ifdef KCP_EXTENTION\r kcp->snd_cnt++;\r #endif // KCP_EXTENTION\r ptr = buffer;\r }\r ptr = ikcp_encode_seg(ptr, segment);\r \r if (segment->len > 0) {//复制数据到kcp包头之后(ptr已指向数据段起始点)\r memcpy(ptr, segment->data, segment->len);\r ptr += segment->len;\r }\r \r if (segment->xmit >= kcp->dead_link) {\r //超过最大重传次数,认为连接已断\r //state并未被使用到,仅仅发生lost后调整拥塞窗口为1\r kcp->state = -1;\r }\r }\r }\r \r //发送缓存区内剩余的数据包\r int size = (int)(ptr - buffer);\r if (size > 0) {\r ikcp_output(kcp, buffer, size);\r #ifdef KCP_EXTENTION\r kcp->snd_cnt++;\r #endif // KCP_EXTENTION\r }\r \r if (change) {\r // 如发生了快速重传(ack跳过),进行拥塞控制\r IUINT32 inflight = kcp->snd_nxt - kcp->snd_una;//计算当前发送窗口\r kcp->ssthresh = inflight / 2; // 调整拥塞窗口阈值为当前发送窗口的一半\r if (kcp->ssthresh ssthresh = IKCP_THRESH_MIN;\r kcp->cwnd = kcp->ssthresh + resent;// 调整拥塞窗口大小\r kcp->incr = kcp->cwnd * kcp->mss; // 重置最大可发送数据量\r }\r \r if (lost) {\r // 发生了超时重传,原因是有包丢失了,并且该包之后的包也没有收到,这很有可能是网络死了,\r // 这时候,拥塞窗口直接变为1.\r kcp->ssthresh = cwnd / 2;\r if (kcp->ssthresh ssthresh = IKCP_THRESH_MIN;\r kcp->cwnd = 1;\r kcp->incr = kcp->mss;\r }\r \r if (kcp->cwnd cwnd = 1;\r kcp->incr = kcp->mss;\r }\r };\r \r /**\r @brief 上层调用驱动kcp状态,设置下一次flush刷新时间戳,并调用ikcp_flush函数,每10ms-100ms调用一次\r @param current 当前时间戳ms\r @note\r 使用ikcp_check获取下一次调用时间，减少ikcp_update调用次数\r 可以在ikcp_input/_send后立即调用或者在一个interval后立即调用\r 每次驱动的时间间隔由interval来决定,\r interval可以通过函数ikcp_interval来设置,间隔时间在10毫秒到5秒之间,\r 初始默认值为100毫秒.\r */\r void ikcp_update(ikcpcb *kcp, IUINT32 current)\r {\r using namespace detail;\r kcp->current = current;\r \r if (kcp->updated == 0) {\r kcp->updated = 1;\r kcp->ts_flush = kcp->current; // 设置立马刷新\r }\r \r IINT32 slap = _itimediff(kcp->current, kcp->ts_flush);\r if (slap >= 10000 || slap ts_flush = kcp->current;//超过刷新时间10sec或下一次刷新间隔太长,设置立马刷新\r slap = 0;\r }\r \r if (slap >= 0) {\r kcp->ts_flush += kcp->interval; // 设置下一次flush刷新时间戳\r if (_itimediff(kcp->current, kcp->ts_flush) >= 0) {\r kcp->ts_flush = kcp->current + kcp->interval;\r }\r ikcp_flush(kcp);\r }\r };\r \r /** @brief 获取接收队列下一个包的大小 */\r int ikcp_peeksize(const ikcpcb *kcp)\r {\r using namespace detail;\r ikcp_seg *seg = nullptr;\r int length = 0;\r \r assert(kcp);\r \r if (iqueue_is_empty(&kcp->rcv_queue))\r return -1;\r \r seg = iqueue_entry(kcp->rcv_queue.next, ikcp_seg, node);\r if (seg->frg == 0) return seg->len;\r \r if (kcp->nrcv_que frg + 1)\r return -1;// 包的分片还未完全接收到\r \r //计算分片总长即包大小\r iqueue_foreach_entry(seg, &kcp->rcv_queue, ikcp_seg, node) {\r length += seg->len;\r if (seg->frg == 0) break;\r }\r \r return length;\r };\r \r /** @brief 获取待发送包的数量 */\r inline int ikcp_waitsnd(const ikcpcb *kcp)\r {\r return kcp->nsnd_buf + kcp->nsnd_que;\r };\r \r //---------------KCP下层输入输出-------------------\r \r /**\r @brief 用户接收的来自远端的底层网络数据(udp报文)通过input传入kcp\r 然后把底层网络数据解码成kcp报文进行缓存.\r @note\r 对于用户传入的数据,kcp会先对数据头部进行解包,判断数据包的大小、会话序号等信息,\r 同时更新远端窗口大小.通过调用 parse_una 来确认远端收到的数据包,\r 将远端接收到的数据包从 snd_buf 中移除.然后调用shrink_buf来更新kcp中snd_una信息,\r 用于告诉远端自己已经确认被接收的数据包信息.\r \r 之后根据不同的数据包cmd类型分别处理对应的数据包 :\r IKCP_CMD_ACK : 对应ACK包,\r kcp通过判断当前接收到ACK的时间戳和ACK包内存储的发送时间戳来更新rtt和rto的时间.\r IKCP_CMD_PUSH : 对应数据包,kcp首先会判断sn号是否超出了当前窗口所能接收的范围,\r 如果超出范围将直接丢弃这个数据包,\r 如果是已经确认接收过的重复包也直接丢弃,然后将数据转移到新的Segment中,\r 通过 parse_data 将Segment放入rcv_buf中,\r 在 parse_data 中首先会在rcv_buf中遍历一次,判断是否已经接收过这个数据包,\r 如果数据包不存在则添加到rcv_buf中,之后将可用的Segment再转移到rcv_queue中.\r IKCP_CMD_WASK : 对应远端的窗口探测包,设置probe标志,在之后发送本地窗口大小.\r IKCP_CMD_WINS : 对应远端的窗口更新包,无需做额外的操作.\r \r 然后根据接收到的ACK遍历 snd_buf 队列更新各个Segment中ACK跳过的次数,用于之后判断是否需要快速重传.\r 最后进行窗口慢启动与拥塞控制\r @code\r ||\r +--------+--------+--------+--------+\r | conv | conv: 会话序号\r +--------+--------+--------+--------+ cmd: 指令类型\r | cmd | frg |\t\t\t wnd | frg: 分片序号\r +--------+--------+--------+--------+ wnd: 接收窗口大小\r |\t\t\t\t\t\t\t ts\t| ts: 发送的时间戳\r +--------+--------+--------+--------+\r |\t\t\t\t\t\t\t sn\t| sn: 包序号\r +--------+--------+--------+--------+\r |\t\t\t\t\t\t\t una\t| una: 当前未收到的序号\r +--------+--------+--------+--------+\r |\t\t\t\t\t\t\t len | len: 数据段长度\r +--------+--------+--------+--------+\r @endcode\r */\r int ikcp_input(ikcpcb *kcp, const char *data, long size)\r {\r using namespace detail;\r assert(kcp);\r if (data == NULL || (int)size snd_una; // 缓存一下当前的 snd_una\r IUINT32 maxack = 0;\r int is_first_maxack = 0;\r \r ikcp_log(kcp, IKCP_LOG_INPUT, \"[kcp] input %d bytes\", size);\r \r // 逐步解析data中的数据\r while (1) {\r IUINT32 conv, ts, sn, len;\r IUINT16 wnd;\r IUINT8 cmd, frg;\r ikcp_seg *seg;\r \r // 解析数据中的KCP头部\r if (size conv) return -1;\r \r data = ikcp_decode8u(data, &cmd);\r data = ikcp_decode8u(data, &frg);\r data = ikcp_decode16u(data, &wnd);\r data = ikcp_decode32u(data, &ts);\r data = ikcp_decode32u(data, &sn);\r data = ikcp_decode32u(data, &una);\r data = ikcp_decode32u(data, &len);\r \r // kcp包头一共24个字节, size减去IKCP_OVERHEAD即24个字节应该不小于len\r size -= IKCP_OVERHEAD;\r if ((long)size rmt_wnd = wnd;\r \r // 分析una,删除snd_buf中小于una的segment(都被远端收到了)\r ikcp_parse_una(kcp, una);\r \r // 更新本地 snd_una 数据\r ikcp_shrink_buf(kcp);\r \r if (cmd == IKCP_CMD_ACK) {\r // 如果收到的是远端发来的ACK包\r if (_itimediff(kcp->current, ts) >= 0) {\r // 根据RTT更新ACK\r ikcp_update_ack(kcp, _itimediff(kcp->current, ts));\r }\r \r // 分析sn,在snd_buf中找到第一个包序号为sn的ikcp_seg删除之\r ikcp_parse_ack(kcp, sn);\r \r // 因为snd_buf可能改变了,更新当前的 snd_una\r ikcp_shrink_buf(kcp);\r \r // 记录最大的ACK包的sn值\r if (is_first_maxack == 0) {\r is_first_maxack = 1;\r maxack = sn;\r }\r else {\r if (sn > maxack) {\r maxack = sn;\r }\r }\r \r // 记录sn, rtt, rto\r ikcp_log(kcp, IKCP_LOG_IN_ACK,\r \"[kcp] input ack: [sn]=%lu [rtt]=%lu [rto]=%lu\", sn,\r (long)_itimediff(kcp->current, ts),\r (long)kcp->rx_rto);\r }\r else if (cmd == IKCP_CMD_PUSH)\r {\r // 如果收到的是远端发来的数据包\r ikcp_log(kcp, IKCP_LOG_IN_DATA, \"[kcp] input psh: [sn]=%lu [len]=%lu [ts]=%lu\", sn, len, ts);\r \r // 如果还有足够多的接收窗口\r if (sn rcv_nxt + kcp->rcv_wnd) {\r // 对该报文的确认 ACK 报文放入 ACK 列表acklist中\r // push当前包的ACK给远端(会在flush中发送ACK出去)\r ikcp_ack_push(kcp, sn, ts);\r \r if (sn >= kcp->rcv_nxt) {\r seg = ikcp_segment_new(kcp, len);\r seg->conv = conv;\r seg->cmd = cmd;\r seg->frg = frg;\r seg->wnd = wnd;\r seg->ts = ts;\r seg->sn = sn;\r seg->una = una;\r seg->len = len;\r \r if (len > 0) {\r memcpy(seg->data, data, len);\r }\r \r // 解析data,\r // 在rcv_buf中遍历一次, 判断是否已经接收过这个数据包,\r // 如果数据包不存在则添加到rcv_buf中, 之后将可用的Segment转移到rcv_queue中\r ikcp_parse_data(kcp, seg);\r }\r }\r }\r else if (cmd == IKCP_CMD_WASK) {\r // 如果收到的包是远端发过来询问窗口大小的包\r // 设置探查变量,将在ikcp_flush中发送IKCP_CMD_WINS,告知远端我的接收窗口大小\r kcp->probe |= IKCP_ASK_TELL;\r ikcp_log(kcp, IKCP_LOG_IN_PROBE, \"[kcp] input probe:IKCP_ASK_TELL\");\r }\r else if (cmd == IKCP_CMD_WINS) {\r // 如果收到的包是远端发过来告知窗口大小的包\r // do nothing\r ikcp_log(kcp, IKCP_LOG_IN_WINS, \"[kcp] input wins: %lu\", (IUINT32)(wnd));\r }\r else {\r return -3;\r }\r \r data += len;\r size -= len;\r }\r \r if (is_first_maxack != 0) {\r // 遍历snd_buf更新各个Segment中ACK跳过的次数,\r // 若Segment的sn小于接收到的ACK包的sn, 则Segment的fastack++,\r // 若fastack超过指定阈值, 则启动快速重传.\r ikcp_parse_fastack(kcp, maxack);\r }\r \r // snd_una与之前缓存的 una 比较\r // 若 snd_una>una,说明收到了有效的una或ACK之后已经更新了snd_una了,\r // 接下来要做流量控制和拥塞控制\r if (kcp->snd_una > una) {\r if (kcp->cwnd rmt_wnd) {\r IUINT32 mss = kcp->mss;\r if (kcp->cwnd ssthresh) { // 慢启动阶段\r kcp->cwnd++;\r kcp->incr += mss;\r }\r else { // 拥塞控制阶段\r if (kcp->incr incr = mss;\r kcp->incr += (mss * mss) / kcp->incr + (mss / 16);\r if ((kcp->cwnd + 1) * mss incr)\r kcp->cwnd++;\r }\r if (kcp->cwnd > kcp->rmt_wnd) {\r kcp->cwnd = kcp->rmt_wnd;\r kcp->incr = kcp->rmt_wnd * mss;\r }\r }\r }\r return 0;\r };\r \r /** @brief 设置kcp输出回调 */\r inline void ikcp_setoutput(ikcpcb *kcp, int(*output)(const char *buf, int len,\r ikcpcb *kcp, void *user))\r {\r assert(kcp);\r kcp->output = output;\r };\r \r //---------------KCP上层输入输出-------------------\r \r /**\r @brief 上层调用接收数据(去除kcp头的用户数据)\r @param[in,out] buffer 用户接收数据区\r @param[in] len 准备接收的数据大小rcv_queue))\r return -1;\r \r if (len len)\r return -3;\r \r /*\r 首先检测一下本次接收数据之后,是否需要进行窗口恢复.\r 在前面的内容中解释过,KCP 协议在远端窗口为0的时候将会停止发送数据,\r 此时如果远端调用 ikcp_recv 将数据从 rcv_queue 中移动到应用层 buffer 中之后,\r 表明其可以再次接受数据,为了能够恢复数据的发送,\r 远端可以主动发送 IKCP_ASK_TELL 来告知窗口大小\r */\r if (kcp->nrcv_que >= kcp->rcv_wnd)\r recover = 1; // 当前可用接收窗口为0 标记需要进行窗口恢复\r \r /*\r merge fragment\r 按序拷贝rcv_queue数据到用户buffer,当碰到某个 segment 的 frg 为 0 时跳出循环,表明本次数据接收结束.\r frg 为 0 的数据包标记着完整接收到了一次 send 发送过来的数据;\r */\r iqueue_head *p = nullptr;\r for (len = 0, p = kcp->rcv_queue.next; p != &kcp->rcv_queue; ) {\r seg = iqueue_entry(p, ikcp_seg, node);\r p = p->next;//由于!ispeek seg会被删除,需提前缓存\r \r if (buffer) {\r memcpy(buffer, seg->data, seg->len);\r buffer += seg->len;\r }\r \r len += seg->len;\r \r ikcp_log(kcp, IKCP_LOG_RECV, \"[kcp] recv [sn]=%lu [frg]=%lu [len]=%lu\", seg->sn, seg->frg, seg->len);\r \r if (!ispeek) { // 入参len>=0则peek\r iqueue_del(&seg->node);\r ikcp_segment_delete(kcp, seg);\r kcp->nrcv_que--;\r }\r \r if (seg->frg == 0)\r break;\r }\r assert(len == peeksize);\r \r /*\r 将 rcv_buf 中的数据转移到 rcv_queue 中,\r 这个过程根据报文的 sn 编号来确保转移到 rcv_queue 中的数据一定是按序的\r */\r iqueue_foreach_entry(seg, &kcp->rcv_buf, ikcp_seg, node) {\r if (seg->sn == kcp->rcv_nxt && kcp->nrcv_que rcv_wnd) {\r iqueue_del(&seg->node);\r kcp->nrcv_buf--;\r iqueue_add_tail(&seg->node, &kcp->rcv_queue);\r kcp->nrcv_que++;\r kcp->rcv_nxt++;\r }\r else {\r break;\r }\r }\r \r /*\r fast recover\r 此时如果 recover 标记为1,表明在此次接收之前,可用接收窗口为0,\r 如果经过本次接收之后,可用窗口大于0,需要进行窗口恢复:\r 主动发送 IKCP_ASK_TELL 数据包来通知对方已可以接收数据\r */\r if (kcp->nrcv_que rcv_wnd && recover) {\r //准备在ikcp_flush中发送IKCP_CMD_WINS 以告知远端本地接收窗口大小\r kcp->probe |= IKCP_ASK_TELL;\r }\r \r return len;\r };\r \r /**\r @brief 上层调用发送数据\r @note\r user/upper level send, returns below zero for error\r \r 该函数的功能非常简单,把用户发送的数据根据MSS进行分片.\r 用户发送1900字节的数据,MTU为1400byte.\r 因此,该函数会把1900byte的用户数据分成两个包,一个数据大小为1400,头frg设置为1,\r len设置为1400;第二个包,头frg设置为0,len设置为500.\r 切好KCP包之后,放入到名为snd_queue的待发送队列中.\r 注:\r 包模式下,用户数据%MSS的包,也会作为一个包发送出去.\r 流模式情况下,kcp会把两次发送的数据衔接为一个完整的kcp包.\r \r 当设置好输出函数之后,上层应用可以调用 ikcp_send 来发送数据.\r ikcpcb 中定义了发送相关的缓冲队列和 buf,分别是 snd_queue 和 snd_buf.\r 应用层调用 ikcp_send 后,数据将会进入到 snd_queue 中,\r 而下层函数 ikcp_flush 将会决定将多少数据从 snd_queue 中移到 snd_buf 中进行发送.\r \r 我们首先来看 ikcp_send 的主要功能 :\r kcp发送的数据包分为2种模式,包模式和流模式.\r 以mss为依据对用户数据分segment (即分片过程fragment) :\r 包模式,数据分片赋予独立id,依次放入snd_queue,接收方按照id合并分片数据,分片大小 mss > 0);\r assert(len > 0);\r if (len snd_queue.prev)\r 将其填充到 mss 的长度,并设置其 frg 为 0.\r */\r if (kcp->stream != 0) {\r if (!iqueue_is_empty(&kcp->snd_queue)) {\r ikcp_seg *old = iqueue_entry(kcp->snd_queue.prev, ikcp_seg, node);\r if (old->len mss) {\r int capacity = kcp->mss - old->len; //分片剩余容量\r int extend = (len len + extend);\r assert(seg);\r if (seg == NULL) {\r return -2;\r }\r iqueue_add_tail(&seg->node, &kcp->snd_queue);\r memcpy(seg->data, old->data, old->len);\r if (buffer) {\r memcpy(seg->data + old->len, buffer, extend);\r buffer += extend;\r }\r seg->len = old->len + extend;\r seg->frg = 0;\r len -= extend;\r iqueue_del_init(&old->node);\r ikcp_segment_delete(kcp, old);\r }\r }\r if (len mss ? 1 : (len + kcp->mss - 1) / kcp->mss;\r if ((IUINT32)count >= IKCP_WND_RCV) return -2;\r \r // 为剩下的数据创建 KCP segment并追加到发送队列\r for (int i = 0; i (int)kcp->mss ? (int)kcp->mss : len;\r seg = ikcp_segment_new(kcp, size);\r assert(seg);\r if (seg == NULL) {\r return -2;\r }\r if (buffer && size > 0) {\r memcpy(seg->data, buffer, size);\r buffer += size;\r }\r seg->len = size;\r // frg用来表示被分片的序号,倒序; 流模式下分片编号不用填\r seg->frg = (kcp->stream == 0) ? (count - i - 1) : 0;\r iqueue_init(&seg->node);\r iqueue_add_tail(&seg->node, &kcp->snd_queue);\r kcp->nsnd_que++;\r len -= size;\r }\r \r return 0;\r };\r \r //---------------RDC-------------------\r \r /**\r @def KCP_EXTENTION\r @brief 可靠性数据支持或丢包率数据统计等扩展原始KCP的部分使用此宏包围\r */\r #ifdef KCP_EXTENTION\r /**\r @brief 检查RDC状态,应用层调用此方法检查丢包率和时延是否超限\r @return 丢包率和时延超限时返回1,否则返回0\r */\r int ikcp_rdc_check(ikcpcb *kcp)\r {\r using namespace detail;\r IINT32 slap = _itimediff(kcp->current, kcp->rdc_check_ts);\r if (slap -10000)\r return kcp->is_rdc_on;//未到检查点\r \r kcp->rdc_check_ts = kcp->current + kcp->rdc_check_interval;\r \r if (kcp->snd_cnt > 0)\r kcp->loss_rate = (int)(1.0 * kcp->timeout_resnd_cnt / kcp->snd_cnt * 100);//计算丢包率的值(超时重传次数/数据包发送数)\r ikcp_log(kcp, IKCP_LOG_OUT_DATA, \"[kcp] resend loss rate:%d%%\", kcp->loss_rate);\r ikcp_log(kcp, IKCP_LOG_OUT_DATA, \"[kcp] resend srtt:%d\", kcp->rx_srtt);\r \r kcp->timeout_resnd_cnt = 0;\r kcp->snd_cnt = 0;\r \r if (!kcp->is_rdc_on\r && kcp->loss_rate >= kcp->rdc_loss_rate_limit //5%\r && kcp->rx_srtt >= kcp->rdc_rtt_limit)//111\r kcp->is_rdc_on = 1;//丢包率或平均时延超限\r else if (kcp->is_rdc_on\r && (kcp->loss_rate rdc_loss_rate_limit || kcp->rx_srtt rdc_rtt_limit)//未超限\r /*&& (++kcp->rdc_close_try_times >= kcp->rdc_close_try_threshold)*/)\r {//尝试关闭RDC次数大于阈值,说明网络波动但保持连接,可以阶段性关闭RDC状态了\r kcp->is_rdc_on = 0;\r //kcp->rdc_close_try_times = 0;\r }\r return kcp->is_rdc_on;\r };\r #endif // KCP_EXTENTION\r \r #endif // __IKCP_H__ %/accordion% TCP & KCP 的区别 TCP是为流量设计的(每秒内可以传输多少KB的数据), 讲究的是充分利用带宽.而 KCP是为流速设计的(单个数据包从一端发送到一端需要多少时间), 以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度.KCP有正常模式和快速模式两种, 通过以下策略达到提高流速的结果： RTO翻倍 vs 不翻倍 TCP超时计算是RTOx2, 这样连续丢三次包就变成RTOx8了, 十分恐怖, 而KCP启动快速模式后不x2, 只是x1.5(实验证明1.5这个值相对比较好),提高了传输速度. 选择性重传 vs 全部重传 TCP丢包时会全部重传从丢的那个包开始以后的数据, KCP是选择性重传, 只重传真正丢失的数据包. 快速重传 TCP的快速重传写死了是3次, KCP可以自己设置, 一般是2次. 延迟ACK vs 非延迟ACK TCP为了充分利用带宽, 延迟发送ACK(NODELAY都没用), 这样超时计算会算出较大 RTT时间, 延长了丢包时的判断过程.KCP的ACK是否延迟发送可以调节. UNA vs ACK+UNA ARQ模型响应有两种, UNA(此编号前所有包已收到, 如TCP)和ACK(该编号包已收到), 光用UNA将导致全部重传, 光用ACK则丢失成本太高, 以往协议都是二选其一, 而 KCP协议中, 除去单独的 ACK包外, 所有包都有UNA信息. 公平流控 vs 非退让流控 KCP正常模式同TCP一样使用公平退让法则, 即发送窗口大小由：发送缓存大小、对方接收窗口大小、拥塞窗口大小决定.但传送及时性要求很高的小数据时, 可选择通过配置开启快速模式(nodelay,不计算网络拥塞程度), 仅用前两项来控制发送窗口.无视全局性网络拥塞状况,有失公平,但确实快. 字节流 vs 报文分片流 KCP发送方式有流方式或消息方式, 若要发送的数据量大于MSS则都需要包分片,开启流模式会取出发送队列最后一个报文,将其填充到MSS的长度,充分利用传输空间, TCP/UDP/KCP三用的传输系统 中国的网络情况比较特殊, 会存在有些网络 UDP连接不上的情况, 因此都是先连接 TCP, 然后试图 UDP, UDP不通的情况下, 退回 TCP也能正常服务, 一旦 TCP断开, 则认为 UDP也断开了. 建立TCP连接到UDP连接的映射关系 先TCP连接,而后UDP握手传送UUID.将传送UUID的UDP端口和已知TCP连接绑定.为了保持连接和NAT映射关系, 客户端一般需要每60秒就发送一个UDP心跳, 服务端收到后回复客户端, 在这个UDP保活连接的基础上可以增加调用KCP的逻辑, 实现更快速的可靠传输. ICMP HTTP/HTTPS HTTP 与 HTTPS 有哪些区别？ HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 HTTP 的端口号是 80，HTTPS 的端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式： 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。 采用「混合加密」的方式的原因： 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。 摘要算法 + 数字签名 摘要即通过哈希算法来保证消息的完整性 数字签名就是对内容的哈希值加密，通过「CA私钥加密，客户端公钥解密」的方式，来确认消息的身份 数字证书 通过数字证书的方式保证服务器公钥的身份，解决冒充的风险 SSL/TLS 协议基本流程：4次握手 客户端向服务器索要并验证服务器的公钥。 双方协商生产「会话秘钥」。 双方采用「会话秘钥」进行加密通信。 socket epoll select&epoll高效的本质 减少用户态和内核态之间的文件句柄拷贝,节约掉了大量的进程上下文切换. 减少对可读可写文件句柄的遍历(中断唤醒) epoll_create创建一个epoll对象,一般epollfd = epoll_create() epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//缓冲区内有数据时epoll_wait返回 epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回 epoll_wait(epollfd,...)等待直到注册的事件发生 select kqueue kqueue与epoll非常相似.注册一批socket描述符到 kqueue以后,当其中的描述符状态发生变化时,kqueue 将一次性通知应用程序哪些描述符可读,可写或出错了. kqueue()生成一个内核事件队列,返回该队列的文件描述符. kevent()提供向内核注册/反注册事件和返回就绪事件或错误事件struct kevent { uintptr_t ident; /* 事件 ID */ short filter; /* 事件过滤器 */ u_short flags; /* 行为标识 */ u_int fflags; /* 过滤器标识值 */ intptr_t data; /* 过滤器数据 */ void *udata; /* 应用透传数据 */ }; guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-19 21:16:08 "},"posts/GO语言要点.html":{"url":"posts/GO语言要点.html","title":"GO语言要点","keywords":"","body":"GO语言要点 基于消息并发模型(同步通信),Goroutine之间是共享内存的. GO调度器采用半抢占式的协作调度,只有在当前协程发生阻塞时才会导致调度. 标准库sync.Once的实现 原子操作配合互斥锁 import( \"sync\" \"sync/atomic\" ) type Once struct{ m Mutex done uint32 } func (o *Once)Do(f func()){ if atomic.LoadUint32(&o.done) == 1{ return } o.m.Lock() defer o.m.Unlock() if o.done == 0{ defer atomic.StoreUint32(&o.done,1) } } 基于sync.Once的单例模式 var( instance *singleton once sync.Once ) func Instance() *singleton{ once.Do(func(){ instance = &singleton }) return instance } 原子操作支持: atomic.Value提供了Load()和Store()方法用于加载保存,可用于任意类型 var config atomic.Value 顺序一致性 通过通道chan或者互斥量sync.Mutex来同步 初始化顺序 包只会被导入一次 先执行依赖包和本包的init()(init()不是普通函数,可以被定义多次,但不能被其他函数调用) 最后执行main.main() 阻塞线程 正常退出可以调用os.Exit(0) select{} for{} Ctrl+C退出 sig := make(chan os.Signal,1) signal.Notify(sig,syscall.SIGINT,syscall.SIGTERM) fmt.Printf(\"quit (%v)\",) 等到N个并发操作完成 使用sync.waitGroup func main(){ var wg sync.waitGroup for i:=0 ;i 常见并发模型 生产者/消费者 func Producer(factor int,out chan 发布/订阅 控制并发数 import( \"golang.org/x/tools/godoc/vfs\" \"golang.org/x/tools/godoc/vfs/gatefs\" ) int main(){ //vfs.OS构造一个虚拟文件系统,gatefs.New构建一个并发受控的vfs //不仅可以控制并发数,还可以判断并发率 fs:=gatefs.New(vfs.OS(\"/path\"),make(chan bool,8)) //... } 赢者为王 多协程只获取最先返回的结果 素数筛 并发的安全退出 超时判断 select{ case v:= 通过close()来关闭通道实现广播quit信号 通过sync.WaitGroup来保证清理工作的完成 context包 简化协程间的超时,退出等操作 错误处理 GO库的实现习惯:即使在包内部使用了panic,在导出函数时也会被转化为明确的错误值 用recover()将异常转为内部错误处理/防御性捕获(recover不应该被包装或嵌套调用) defer func(){ if p:= recover();p!=nil{ err=fmt.Errorf(\"error %v\",p) } }() 注意使用defer以防文件不能被正确关闭 获取错误的上下文 定义辅助函数记录原始的错误信息 CGO编程 调用C函数,或者导出GO函数给C调用 需要安装GCC/MinGW,并且环境变量CGO_ENABLED置1 不同GO包引入的虚拟C包中的类型是不同的,不能兼容(哪怕是同一个函数) 启用CGO特性,go build会在编译链接阶段启动GCC编译器 import \"C\" 调用C接口函数 package main /* #include void SayHello(const char* s){ puts(s); } */ import \"C\" func main(){ C.SayHello(C.CString(\"Hello,world\\n\")) } 放在独立的C文件中(当前目录下,以.c结尾,或者通过动态库链接),在CGO部分声明C函数 package main //void SayHello(const char* s); import \"C\" func main(){ C.SayHello(C.CString(\"Hello,world\\n\")) } 将接口函数声明放在.h文件中,实现语言可以是C或C++或汇编或GO语言 //SayHello.go //... //export SayHello func SayHello(s *C.char){ fmt.Print(C.GoString(s)) } 进一步提炼CGO (_GoString_是预定义的C语言类型,表示GO语言字符串) package main // void SayHello(_GoString_ s); import \"fmt\" func main(){ C.SayHello(\"hellow,world\\n\") } //export SayHello func SayHello(s string){ fmt.Print(s) } #cgo语句,在import \"C\"之前用于设置编译链接参数 build标志 条件编译 源文件设置: // +build debug 构建: go build -tags=\"debug\" C调用GO 生成静态库/动态库和头文件 go build -buildmode=c-archive -o sum.a sum.go go build -buildmode=c-shared -o sum.so sum.go GO汇编 优势 跨操作系统 不同CPU用法很相似 支持C语言预处理器 支持模块 RPC和Protobuf net/rpc包(进一步包装更安全高效) RPC规则:方法必须公开,只能有2个可序列化的参数,第二个参数是指针类型,且返回error类型, rpc.RegisterName()注册对象类型(服务)下所有符合RPC规则的方法 type HelloService struct{} func (p *HelloService)Hello(request string,reply *string)error{ *reply = \"hello:\"+request return nil } //服务端 rpc.RegisterName(\"HelloService\",new(HelloService)) listener,err:=net.Listen(\"tcp\",\":1234\") conn,err:=listener.Accept() rpc.ServeConn(conn) //客户端 client,err:=rpc.Dial(\"tcp\",\"localhost:1234\") var reply string err = client.Call(\"HelloService.Hello\",\"hello\",&reply) RPC接口规范 服务名字 服务提供的方法列表 注册该类型服务的函数 跨语言的RPC 基于JSON重新实现RPC服务 用rpc.ServeCodec()替代rpc.ServeConn() HTTP上的RPC 创建HTTP服务 中转jsonrpc服务 Protobuf go get github.com/golang/protobuf/protoc-gen-go protoc --go_out=. hello.proto protoc --go_out=plugins=grpc:. hello.proto使用内置插件生成gRPC代码 可以通过构建模板自动生成完整的RPC代码(PB插件) 证书认证 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-07 01:39:49 "},"posts/Git相关操作.html":{"url":"posts/Git相关操作.html","title":"Git相关操作","keywords":"","body":"git相关操作 [toc] 更多操作教程: git-scm submodule 表示一种依赖关系,项目push到远程仓库不会重复push子模块的文件,而是以引用的形式链接到远程仓库. 第三方库不受本项目管理,更新时可以随时拉取更新.更改时也不影响本地项目的记录. # 在项目内引用第三方远程库 git submodule add https://github.com/user_name/project_name.git /3rdparty # 递归拉取/更新第三方库 git submodule update --init --recursive subtree 表示一种子目录分支关系,子目录可以单独成为一个分支(可用于部署,测试等等) 子目录受本项目管理,项目push到远程仓库包含子目录的文件 # 添加子目录 仅第一次调用 git subtree add --squash --prefix=要拆分的目录 origin 子分支名 # 拆分子目录到新的分支 git subtree split --rejoin --prefix=要拆分的目录 --branch 子分支名 # 合并提交推送子目录 git subtree push --prefix=要拆分的目录 origin 子分支名 --squash # 不应该在远程对子目录的分支进行直接更改,因为更改无法merge回主分支 # 可以删除本地子分支和远程子分支,重新拆分并推送 git branch -D 子分支名 git push origin --delete 子分支名 pull & push # 配置当前fork的仓库的原仓库地址 git remote add upstream # 添加远程仓库 git remote add origin https://github.com/XXX.git # 查看当前仓库的远程仓库地址和原仓库地址 git remote -v # 获取原仓库的更新 git fetch upstream # 合并到本地分支 git merge upstream # git pull = git fetch + git merge FETCH_HEAD # git pull --rebase = git fetch + git rebase FETCH_HEAD # 推送 git push origin master merge & rebase # 合并分支commit到主分支 git merge dev --squash # 如遇冲突就解决冲突 # 或者 git rebase -i master # rebase可以使时间线更简洁线性化 # 解决冲突后继续 git rebase –continue vscode的cmd终端内增加配置git # 查看本地配置邮箱 git config --global --list # 生成公私钥 ssh-keygen -t rsa -C \"这里换上你的邮箱\" # 确认秘钥的保存路径(如果不需要改路径则直接回车) # 如果上一步保存路径下已经有秘钥文件，则需要确认是否覆盖(如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖) # 创建密码(如果不需要密码则直接回车) # 确认密码 # 打开github 进入setting页面添加ssh key # 粘贴以.pub结尾的文件内的公钥内容 # win系统需要确认OpenSSH..开头的服务已启用 # linux使用ssh-agent ssh-agent bash # OpenSSH服务/ssh-agent添加私钥文件 ssh-add /path_to_rsa # 查看注册的私钥 ssh-add -l # 测试是否配置成功 ssh -T git@github.com # 要测试通过HTTPS端口的SSH是否可行,运行以下SSH命令 ssh-T -p 443 git@ssh.github.com # 若出现 git@github.com：Permission denied(publickey). # 在.ssh目录下新建config touch ~/.ssh/config # 输入以下内容,明确认证方式 Host github.com Port 443 HostName ssh.github.com User git IdentityFile /path_to_rsa # 如果出现 LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 #尝试取消代理 git config --global --unset http.proxy git config --global --unset https.proxy # 如果取消代理 问题依旧 大概率是ssh配置不正确 # 在.ssh目录下新建config,明确认证方式,即可解决 清除所有历史提交记录,使其为历史干净的库 # 比如静态blog对版本控制没什么要求,维护静态文件记录很占空间,必要时清理可以大大降低空间占用 # 将本地最新记录作为latest分支并检出 git checkout --orphan latest # 添加记录 git add . git commit -m \"first commit\" # 删除master分支 git branch -D master # 将latest分支重命名为master git branch -m master # 覆盖远程项目,需要在项目设置里面添加分支保护规则,打开允许强制push和delete git push -f origin master # 更新远程分支信息 git pull # 查看提交日志 git log --pretty=oneline # 查看本地分支 git branch -a # 查看本地标签 git tag # 查看远程标签 git ls-remote --tags guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-07 18:27:20 "},"posts/信息节点备忘录.html":{"url":"posts/信息节点备忘录.html","title":"信息节点备忘录","keywords":"","body":"信息节点备忘录 信息站 buzzing.cc 国外新闻网站聚合信息流 [need proxy] 熊猫搜书 书籍搜索聚合站 colorhunt 色彩组合板 电鸭 远程工作网站 天空之城 专注航拍的摄影网站,世界各地航拍摄影师优秀航拍作品与航拍攻略。 必应壁纸 知乎Top1000高票回答 GitHub Trending GitHub上当前最受欢迎的开源项目 今日热榜 国内各大平台热榜信息聚合 quickref 开发人员快速参考备忘清单,速查表 工具项目 查找网站IP地址 图像文件格式互转站 在线免费,综合且强大 小鹿快传 简单安全高效的P2P文件传输服务.deershare开源地址 Gitea 自托管git服务 带web stash GO写的自托管视频站 mastodon 基于ActivityPub去中心化的免费开源社交网络服务器 act 在本地运行 GitHub Actions bigjpg AI图像放大 owncloud 开源自托管网盘项目,有移动应用支持 mediapipe 谷歌开源的为流媒体提供跨平台、可定制的 ML 解决方案 material-design-icons 来自谷歌的两个不同的官方图标集 cubox 一站式信息收集、阅读、管理和回顾 善用网络碎片构建个人知识库 ChatGPT OpenAI超级对话模型,ChatGPT 学习资料 TopList go爬虫爬取榜单示例项目 HelloGitHub 分享 GitHub 上有趣、入门级的开源项目(有同名公众号) free-programming-books 免费编程资料合集 free-programming-books-zh_CN 免费编程资料合集 中文版资料 C++参考手册 GO语言标准库示例代码合集 GO语言设计模式 GO语言高级编程 同名书籍的开源版 命令行艺术 各种命令行工具命令用法介绍 算法可视化 JS写的算法动画项目 示例站 cmake-examples TheAlgorithms 跟语言有关的所有算法的实现 Cirq Python库,用于编写、操作和优化量子电路,并在量子计算机和模拟器上运行它们. cub CUDA C++的协作原语 sveltejs 新一代前端框架 CPP库 yalantinglibs C++20库的集合 struct_pack 基于泛型的高性能序列化库 比protobuf快10-50倍,header only struct_json 基于泛型的json/struct互转库,header only coro_rpc 基于协程的高性能C++20 rpc框架,header only async_simple 一个简单、轻量级的异步C++框架 async_simple C++20协程库 提供的组件包括Lazy(基于C++20 stackless协程)、Uthread(基于stackful协程)和传统的Future/Promise. asio2 Header only c++ network library, based on asio,support tcp,udp,http,websocket,rpc,ssl,icmp,serial_port. llhttp HTTP解析库 网站设计不错 cubox 一站式信息收集、阅读、管理和回顾 善用网络碎片构建个人知识库 远程工作文化 xmind 深圳 cubox 苏州 Nomura IT 上海 不错的软件 有些可能需要在Google Play商店/官网才能找到 TED 英语视频演讲 1SE 每日一秒,创作你的人生电影 iDaily 每日环球视野 xmind 思维导图 阅读清单 小镇喧嚣 沧浪之水 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-20 19:57:47 "},"posts/面试问题总结.html":{"url":"posts/面试问题总结.html","title":"面试问题总结","keywords":"","body":"面试问题总结 [toc] 内卷环境之下,岗位的专业分工程度越来越高,综合研发能力比较强的人真的有点水土不服.表面上视野广阔一个顶两,实际上任一方向都有比较强的可替代性. 由于之前工作涉及的领域比较多,大多在项目期间的时候深入过,退出项目栈之后又容易忘,领域知识很难迁移,找工作的时候就很麻烦,一边需要复习语言细节,一边需要复习项目细节,一边需要复习理论相关内容,一边还要复习常用工具命令用法,还要刷算法题和手撕实现细节等等,短时间复习很难覆盖全面,长时间又很容易遗忘. 特别是面试问什么的都有,问八股文背诵记忆力,问API细节甚至入参是啥,简历上任何一个点都有可能是人家感兴趣的会深入问下去的. 普通面试官考察实现细节,技术大佬会试探性问技术边界,两者都很难应对,可能曾经深入了80%,过了很长时间也只能回答出10%.工作的时候非常投入,应聘时却很难体现,就非常吃亏. 然后匹配的方向也蛮难找的,螺丝钉岗有螺丝钉岗的烦恼,研发岗有研发岗的郁闷,之前的打法有点类似深度优先遍历,快速深入快速退出然后清空记忆栈,继续遍历,锻炼出了不少解决复杂问题的能力,唯独没锻炼出记忆力. 未来还是需要在专业领域方向有更多沉淀.考虑简历上更多地剪枝以提高匹配专业度和降低面试准备难度. 把曾经涉及过的相关问题做个记录,随遇而安吧. 小细节 一些平时不需要关心或者很少使用的用法 没测试过就没有印象的小细节 过于底层的内容 CPP 关于C++类空间大小的计算(以下以32位编译器为例|gcc) #include using namespace std; // 空类的大小 // 所谓类的实例化就是在内存中分配一块地址,每个实例在内存中都有独一无二的地址.同样空类也会被实例化, 所以编译器会给空类隐式地添加一个字节, 这样空类实例化之后就有了独一无二的地址了. =1 class Stu1{ }; // 非空类的存储空间以包含变量的存储大小为准 =1 class Stu2{ char a; }; // 非空类,包含函数不占用存储空间 // 类的大小与它的构造函数、析构函数和其他成员函数无关, 只已它的数据成员有关 // 数据成员会自动与最大宽度的成员对齐,4+2+2(补)+8+1+7(补)=24 class Stu3{ public: ~Stu3(){}; void fun(){}; int a; //4 short b; //2 double c; //8 char d; //1 }; // 非空类,包含虚函数, 会因为多一个虚函数指针(vptr)指向虚函数表 // 4(vptr指针)+4+2+6(补)+8+1+7(补)=32 class Stu4{ public: virtual ~Stu4(){};//4 int a; //4 short b; //2 double c; //8 char d; //1 }; // 4(vptr指针) +4(int) +1(char)+3(补齐) =12 class Stu5{ public: virtual ~Stu5(){};//4 int a; //4 char b; //1 }; // 有虚函数的继承, 子类的存储是父类的存储+子类的存储 // 所以存储是4(vptr指针)+4 +2+6(补) +8 +1+1(char)+6(补)=32 class Stu6 :public Stu4 { public: virtual ~Stu6(){}; char c; }; // 存储是4(vptr指针)+4 +2+6(补) +8 +1+7(补) +4(int)+1(char)+3(补)=40 class Stu7 :public Stu4 { public: virtual ~Stu7(){}; int c; char d; }; // 存储是4(vptr指针)+4 +2+6(补) +8 +1(char)+1(char)+4(int)+2(补)=32 class Stu8 :public Stu4 { public: virtual ~Stu8(){}; char d; int c; }; // 静态变量不占用实例的存储空间 = 4(int) class Stu9{ public: int a; static int b; }; int main(){ std::cout 总结 类大小只跟成员变量有关,空类大小=1 静态变量空间不计算在实例空间内 继承时的空间大小: 计算子类和父类空间,虚函数指针只有一个 自动补齐:与最大宽度的数据成员依次对齐(注意stu7和stu8的特殊区别,有点不合常规,可能是编译器实现不一样) 继承关系中虚函数及其默认值 #include using namespace std; struct A{ virtual int fun(int a = 10){return a;}; }; struct B : public A{ int fun(int a = 20)override{return a;}; }; struct C : public A{ int fun(int a = 30)override{return a+a;}; }; int main(){ B b; C c; A* a=&b; coutfun()fun() 总结 默认值在编译期就已经确定下来了,若调用时缺省参数,子类定义的默认值会被无视,然后才会调用子类方法 一般来说应该避免在虚函数中使用默认值 因为还有一个点是,声明时定义了默认值,实现函数的签名内不能包含默认值,否则编译报错. 规范的注释方式是在子类实现有默认值的虚方法时,在形参列表内如下注释上默认值. struct B : public A{ int fun(int a/*=10*/)override{return a;}; }; 在构造函数和析构函数中调用虚函数 #include \"iostream\" using namespace std; class Base{ public: Base(){ cout 在C++编码规范-实用增强细节版 这篇文章中有个建议是构造和析构函数应该只处理成员变量初始化相关的工作,为了减少记忆负担经常会有许多经验总结,但也因此会忽略掉背后的许多细节,会导致你大概知道是什么原因,但是又讲不完整. 总结: 看其他文章的理由说:由于构造/析构时对象是不完整/不安全的,故而无法完成动态联编会丧失多态性. 其实多态性并没有消失,依然会动态联编,只不过找不到还未构造或已经被析构的对象时调用了自身方法而已,基类/派生类在构造/析构函数中调用虚方法会调用自身实现,delete基类指针时也能正确调用子类的覆盖方法,行为一致性并未被破坏. 毕竟除非使用奇异模板递归模式,基类内是操作不到也不应该操作到派生类的. 如果清楚构造/析构顺序,其实这个问题并不存在.如果面试官以这个角度提问大概率只是想考察构造和析构顺序罢了. int类型的-1 左移右移的值 #include #include #include using namespace std; int main() { // 32位及以上操作系统上, int型数据的十进制表示范围是: -2^31 到 2^31-1 cout (-std::pow(2, 31)) (std::pow(2, 31) - 1) (-std::pow(2, 31)).to_ulong() (std::pow(2, 31) - 1).to_ulong() (1) (-1) 原码 cout (-1 (-1 >> 1) > 1 : \" > 1) > 1 : -1 总结 int类型在计算机中是以补码存储的(4字节*8bit=32bit),首位标志位,范围-2^31 ~ 2^31-1 补码原码 负数左移补0,右移补1 引用和指针的区别 简单来说主要区别有: 初始化: 引用定义时必须初始化,指针没有要求 指向性: 引用是变量的别名,初始化后不能指向其他实体,指针可以任意指向 空值: 不存在空引用但是可以存在空指针 sizeof: sizeof中引用就是变量的大小,指针就是指针占用的大小(4/8) 自加: 引用自加就是变量自加,指针自加会偏移类型的大小 多级: 有多级指针但没有多级引用 访问: 指针需要解引用显式取值,引用由编译器自己处理. 底层实现:引用是通过指针实现的,可以认为是固化版指针 引用具有指针的效率和变量的方便直观性 memcpy memmove区别 2者都是将N个字节的源地址的内容拷贝到目标地址中. 当源内存和目标内存存在重叠时, memcpy会出现错误, 而memmove能正确地实施拷贝 memcpy实现 void * memcpy (void* dest,const void* src,size_t n){ char* d = (char*)dest; const char s = (const char*) src; while (n-–) *d++ = *s++; return dest; } memmove实现 void* memmove (void* dest,const void* src,size_t n){ char* d = (char*)dest; const char* s = (const char*) src; if(s>d){//正向拷贝 与memcpy相同 while (n--) *d++ = *s++; } else if(s 各种各样 大小端编码 网络字节序是大端编码 大端编码：高位数字存放在低地址字节中, 将0x1234转化为1字节的char, 高地址字节被丢弃, 剩余低地址字节, 即12. 小端编码：高位数字存放在高地址字节中, 如0x1234, 小端编码机器将12存放在高位地址字节, 34存放在低地址字节中, 将其转化为1字节的char时, 高地址字节被丢弃, 剩余低地址字节, 就是34. grep 文件中查找匹配内容及行号grep -n Linux信号 信号 值 描述 组合键/命令 1 SIGHUP 挂起 2 SIGINT 终止 Ctrl+C 3 SIGQUIT 停止 9 SIGKILL 无条件终止 kill -9 15 SIGTERM 尽可能终止 17 SIGSTOP 无条件停止 18 SIGTSTP 暂停 CTRL+Z 19 SIGCONT 继续 bash shell默认忽略SIGQUIT和SIGTERM信号(必要时在脚本中捕获处理),会处理SIGHUP和SIGINT信号. trap捕获信号并处理(可用于.sh文件内) trap trap \"echo 'trepped ctrl+c'\" SIGINT # 捕获命令 trap \"echo 'goodbye'\" EXIT # 捕获shell脚本的退出 trap -- SIGINT # 移除要捕获的信号 后台运行shell 在命令后加&符即可 ./test.sh & 不同主机间传送文件 scp 远端用户名@IP地址:文件的绝对路径 指定本地保存的路径 (-r传送文件夹) scp root@192.168.1.12:/tmp/test.txt ./temp/test.txt 通识类 AI相关 池化层 实施池化的目的 降低信息冗余 提升模型的尺度不变性、旋转不变性 防止过拟合 常见操作 最大值池化 均值池化 随机池化 中值池化 组合池化(同时利用最大值与均值池化两种的优势) GPU/CUDA相关 并行处理的类型 基于任务的并行处理 操作系统与进程 基于数据的并行处理 SIMD,单指令多数据 常用并行模式 循环并行展开 图像处理算法中,沿X轴处理时内循环,沿Y轴处理时外循环. 循环并行化是OpenMP的基础 派生/汇集模式 比如OpenMP中,用编译指令语句定义可并行区,并行区中的代码被分成N个线程,随后再汇聚成单个线程 MapReduce 大规模分布式并行计算框架 分条/分块 使用CUDA解决问题需要将问题分条分块(CUDA提供的是简单二维网格模型) 分而治之 体系结构 GPU设备包括一组SM, 每个SM由包括一组SP或CUDA核(并行) GPU性能由SP数量, 全局内存带宽, 程序员利用并行架构的充分程度 解决时空局部性问题-> 多级缓存:一级缓存 二级缓存 全局内存 缓存一致性 保证所有处理核的内存视图一样(CPU要求, GPU不要求) GPU通过PCI-E总线与CPU或其他GPU连接 纹理内存和常量内存是全局内存的特殊视图,每个SM都设置独立访问它们的总线,纹理内存用于存储插值计算所需的数据,常量内存缓存只读数据. CUDA CUDA的SPMD模型：每个线程执行的代码一样但是数据不同 CUDA结构类型 SIMT-单指令多线程 CUDA将问题分解成线程块的网格,每块包含多个线程束,块可以按任意顺序执行 线程块(可以任意顺序执行,调度到SM上时执行不中断) 线程束 分块的数量一般为SM的8-16倍 全局内存 纹理内存 常量内存 __global__ 内核函数 指示生成GPU代码 __host__ 主机函数 __device__ 设备函数 用于在设备上调用该设备函数 __constand__ 指示常量内存 __shared__ 指示共享内存 调试工具 Nsight,cuda-gdb等 编译器 NVCCthreadIdx 线程索引 blockIdx 线程块索引 blockDim.x 每个线程块启动的线程数量 gridDim 线程网格上的线程块数量 const unsigned int idx = (blockIdx.x*blockDim.x)+threadIdx.x const unsigned int idy = (blockIdx.y*blockDim.y)+threadIdx.y 绝对线程索引 thraad_idx=((gridDim.x*blockDim.x)*idy)+idx; 网络相关 网络协议要点及编程方法 Git相关 Git相关操作 小测验 线程间通信 两个进程中的线程间通信方式 信号量, socket, 共享内存 ,管道,共享文件 一个进程中的线程间通信方式 条件变量 condition_variable 配合互斥锁可以避免忙等 比起普通方法bool值的轮询,通过唤醒来替代不必要的轮询 存在信号丢失和虚假唤醒的问题,通过增加条件判断来规避 条件变量为什么要和mutex搭配, 不能单独使用吗? 条件变量通信相当于操作公共变量,需要加锁 信号量(PV操作) #include #include #include using namespace std; std::counting_semaphore seamp(1); // 生产者信号量 std::counting_semaphore seams(0); // 消费者信号量 int num(0); void producer_thread(){ while (num 原子操作 atomic 可以取代mutex和lock 同步原语：future and async/packaged_task/promise thread promise 低级接口 #include #include #include #include using namespace std; void thread_set_promise(std::promise& pm) { cout pm; future fu = pm.get_future(); thread t(&thread_set_promise, ref(pm)); cout async() future 高级接口 #include #include #include #include #include using namespace std; int work(char c){ default_random_engine e(c); uniform_int_distribution id(10,100); for(int i=0;i r1(async(f1)); // async启动异步线程(不保证) //future r1(async(launch::async, f1)); // async启动异步线程(保证) //future r1(async(launch::deferred, f1)); // async启动异步线程(延迟到get) auto ret = r1.wait_for(10ms); switch (ret){ case future_status::ready:{ cout packaged_task, future packaged_task和function的区别在于前者返回值以future返回 #include #include #include using namespace std; int func (int x){ return x; } int main() { std::packaged_task t(func); std::thread t1(std::ref(t), 1); std::future fu = t.get_future(); std::shared_future fus = fu.share(); cout 锁 互斥锁 mutex & Lock_guard | unique_lock recursive_mutex 允许同一线程多次调用 timed_mutex 可以 try_lock_for等待一段时间 尝试/同时锁定多个锁 std::lock(m1,m2); std::try_lock(m1,m2); // 注意需要过继给lock_guard std::lock_guard lg_m1(m1,std::adopt_lock); std::lock_guard lg_m2(m2,std::adopt_lock); 读写锁 解决多线程同时读 共享锁std::shared_lock 独占锁std::unique_lock #include //C++17 #include #include #include using namespace std; shared_mutex mu; vector vec; bool is_run = 1; void read(){ while(is_run){ shared_lock sl(mu); if(!vec.empty()){ cout 多线程条件变量+互斥锁 生产者消费者模型 #include #include #include #include #include using namespace std; mutex mu; condition_variable cv; vector vec; bool is_run=true; void productor(){ static int num =1; while (is_run){ unique_lock ul(mu); cv.wait(ul, []() { return (vec.size() ul(mu); cv.wait(ul,[](){return (vec.size()>=1);});// 小于1等待 cout guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-20 20:27:49 "},"posts/GitBook简明教程.html":{"url":"posts/GitBook简明教程.html","title":"GitBook简明教程","keywords":"","body":"GitBook简明教程 [toc] 安装 使用 编辑器建议 GitBook.com Git管理 配置书籍 绑定域名 个性化配置 插件 发布到 GitHub Pages 原仓库子目录部署 使用actions workflow自动部署 推送到分支部署 Gitbook文档 安装 下载安装node.js 安装gitbook命令行工具 npm install gitbook-cli -g 使用 gitbook init 初始化目录 生成两个必要的文件README.md(介绍)和SUMMARY.md(结构) 编辑SUMMARY.md后可以再次执行该命令生成文件结构(2级) gitbook build编译为HTML 生成一个_book文件夹,包含静态HTML文件 文件名不能包含括号不然无法识别解析 gitbook serve启动本地web服务器 http://localhost:4000 预览电子书效果 SUMMARY.md可以通过使用 标题 或者 水平分割线 将 GitBook 分为几个不同的部分,如下所示： # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) --- * [Last part without title](part3/title.md) 编辑器建议 vscode 中安装插件Markdown Preview Enhanced所见即所得 GitBook.com GitBook.com 是一个围绕 gitbook 发行书籍的社区,于 2014 年初创,GitBook.com 提供免费和付费的服务,而且免费账户就可以享受诸多服务,包括： 1 本私有书籍 托管不限数量的公开书籍 售卖不限数量的书籍,并分享 80% 的书籍收入 不限数量的协作者 免费的在线书籍编辑器 Git管理 GitBook.com 上的每本书都使用Git来管理,使用Git提交到书籍的远程项目,当然,提交前,最好在本地使用 gitbook 预览效果. git clone https://git.gitbook.com/testuser/test.git 克隆 git commit -m \"..\" 提交 git push 推送发布 书籍地址https://git.gitbook.com/test_user/test 配置书籍 GitBook.com上的书籍,进入书籍的属性页面 可以设置,书籍主题,GitHub集成,绑定域名. GitHub上创建项目 书籍导入到GitHub上的项目 书籍目录下git remote add github https://github.com/testuser/test.git git push -u github master git push 命令中的 -u 表示将本地 master 分支的上游分支设置为github/master. git push 将推送到 github 上,而非原来的 https://git.gitbook.com/testuser/test.git 与此同时原来gitbook上的项目应该会同步拉取/显示github上的更新. 绑定域名 除了可以使用类似http://test_user.gitbooks.io/test/content/index.html地址访问用户的书籍外,还可以为每本书另外绑定域名. 只能绑定一个合法的域名,不能是域名下的某个地址. 域名服务商处为域名添加CNAME记录,指向到该书籍地址. 可以使用nslookup test.testuser.cn来验证是否解析成功. 书籍内容类似http://content.test.test_user.cn 个性化配置 gitbook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json. %accordion%本站的book.json可供参考%accordion% {\r \"title\": \"iPanda\",\r \"author\": \"Mainvooid\",\r \"description\": \"万古长空，一朝风月\",\r \"language\": \"zh-hans\",\r \"gitbook\": \"3.2.3\",\r \"styles\": {\r \"website\": \"styles/website.css\",\r \"ebook\": \"styles/ebook.css\",\r \"pdf\": \"styles/pdf.css\",\r \"mobi\": \"styles/mobi.css\",\r \"epub\": \"styles/epub.css\"\r },\r \"structure\": {\r \"readme\": \"README.md\"\r },\r \"links\": {\r \"sidebar\": {\r \"Github\": \"https://github.com/Mainvooid\"\r }\r },\r \"plugins\": [\r \"-sharing\",\r \"-search\",\r \"-lunr\",\r \"search-pro\",\r \"highlight\",\r \"livereload\",\r \"splitter\",\r \"expandable-chapters-small\",\r \"anchors\",\r \"github\",\r \"github-buttons\",\r \"donate\",\r \"sharing-plus\",\r \"anchor-navigation-ex\",\r \"favicon\",\r \"tbfed-pagefooter\",\r \"disqus\",\r \"code\",\r \"todos\",\r \"advanced-emoji\",\r \"klipse\",\r \"flexible-alerts\",\r \"site-count\",\r \"accordion\",\r \"hide-element\",\r \"codesnippet\",\r \"atoc\"\r ],\r \"pluginsConfig\": {\r \"site-count\": {\r \"host\": \"https://mainvooid.github.io/\"\r },\r \"hide-element\": {\r \"elements\": [\".gitbook-link\"]\r },\r \"flexible-alerts\": {\r \"style\": \"flat\",\r \"note\": {\r \"label\": \"Note\"\r },\r \"tip\": {\r \"label\": \"Tip\"\r },\r \"warning\": {\r \"label\": \"Warning\"\r },\r \"danger\": {\r \"label\": \"Attention\"\r }\r },\r \"code\": {\r \"copyButtons\": true\r },\r \"github\": {\r \"url\": \"https://github.com/Mainvooid\"\r },\r \"github-buttons\": {\r \"buttons\": [\r {\r \"user\": \"Mainvooid\",\r \"repo\": \"Mainvooid.github.io\",\r \"type\": \"star\",\r \"size\": \"small\",\r \"count\": true\r }\r ]\r },\r \"donate\": {\r \"wechat\": \"./assets/donate-wechat.png\",\r \"alipay\": \"./assets/donate-alipay.jpg\",\r \"title\": \"\",\r \"button\": \"赞赏\",\r \"alipayText\": \"支付宝打赏\",\r \"wechatText\": \"微信打赏\"\r },\r \"disqus\": {\r \"shortName\": \"ipandar\"\r },\r \"sharing\": {\r \"douban\": false,\r \"facebook\": false,\r \"google\": false,\r \"hatenaBookmark\": false,\r \"instapaper\": false,\r \"line\": false,\r \"linkedin\": false,\r \"messenger\": false,\r \"pocket\": false,\r \"qq\": false,\r \"qzone\": false,\r \"stumbleupon\": false,\r \"twitter\": true,\r \"viber\": false,\r \"vk\": false,\r \"weibo\": true,\r \"whatsapp\": false,\r \"all\": [\r \"douban\",\r \"facebook\",\r \"google\",\r \"hatenaBookmark\",\r \"instapaper\",\r \"line\",\r \"linkedin\",\r \"messenger\",\r \"qq\",\r \"qzone\",\r \"stumbleupon\",\r \"twitter\",\r \"viber\",\r \"vk\",\r \"weibo\",\r \"whatsapp\"\r ]\r },\r \"anchor-navigation-ex\": {\r \"showLevel\": false\r },\r \"favicon\": {\r \"shortcut\": \"./assets/favicon.jpg\",\r \"bookmark\": \"./assets/favicon.jpg\",\r \"appleTouch\": \"./assets/favicon.jpg\",\r \"appleTouchMore\": {\r \"120x120\": \"./assets/favicon.jpg\",\r \"180x180\": \"./assets/favicon.jpg\"\r }\r },\r \"tbfed-pagefooter\": {\r \"copyright\":\"guobao.v@gmail.com \",\r \"modify_label\": \"最后编辑时间:\",\r \"modify_format\": \"YYYY-MM-DD HH:mm:ss\"\r }\r }\r } %/accordion% (插件accordion+codesnippet可以实现上面那样从文件读取代码并折叠) 插件 可以在npmjs.com 上搜索gitbook-plugin来查找插件 GitBook默认带有 5 个插件,highlight、search、sharing、font-settings、livereload,如果要去除自带的插件, 可以在插件名称前面加\"-\",比如： \"plugins\": [ \"-search\" ] 如果要配置使用的插件可以在book.json文件中加入即可,比如我们添加plugin-github,我们在book.json中加入配置如下即可： { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/your/repo\" } } } 然后在终端输入 gitbook install ./ 安装配置中的插件. 手动安装方式为npm install gitbook-plugin-插件名 livereload 自带实时重载 ComScore 是一个彩色主题,默认的 gitbook 主题是黑白的,也就是标题和正文都是黑色的,而 ComScore 可以为各级标题添加不同的颜色,更容易区分各级标题. Disqus 是一个非常流行的为网站集成评论系统的工具,同样,gitbook 也可以集成 disqus 以便可以和读者交流. 首先,需要在 disqus 上注册一个账号,然后添加一个 website,这会获得一个关键字,然后在集成时配置这个关键字即可. npm install gitbook-plugin-disqus -g 修改 book.json 配置文件,添加插件的配置内容：{ \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"获取的唯一key\" } } } gitbook不支持 [toc],好在有插件可以曲线救国。 在book.json中添加插件atoc,运行gitbook install 安装完成后，在使用[toc]命令的地方使用代替(XXX替换为toc)。即可自动生成文档目录。 还有一种补充方式是安装anchor-navigation-ex添加Toc到侧边悬浮导航以及回到顶部按钮. \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false } } expandable-chapters-small可扩展导航章节 search-pro 高级搜索(支持中文) 在使用此插件之前，需要将默认的search和lunr插件去掉. splitter 侧边栏宽度可调节 sharing-plus分享当前页面，比默认的 sharing 插件多了一些分享方式. \"all\"中代表点击分享符号可以显示出来的. tbfed-pagefooter 页面添加页脚(简单的) page-copyright 页面页脚版权(内容多) klipse 嵌入类似IDE的功能,嵌入一块功能，可在代码段中实时交互,即输入代码 > 执行结果 donate 打赏插件 文章最下面的按钮，点击可弹出图片 change_girls 可自动切换的背景图片，time单位秒,url只能使用绝对地址 { \"plugins\":[\"change_girls\"], \"pluginsConfig\": { \"change_girls\" : { \"time\" : 10, \"urls\" : [ \"girlUrl1\", \"girlUrl2\",...\"\" ] } } } code 为代码块添加行号和复制按钮 \"pluginsConfig\": { \"code\": { \"copyButtons\": true } } codesnippet 从文件导入代码并显示(url链接的文件也可以e.g. https://raw.githubusercontent.com/..cpp) //指定语言 指定显示的文件行数 {@ codesnippet \"./assets/test.cpp\", lines=\"2:5\",language=\"cpp\" @}{@ endcodesnippet @} #include \r using namespace std;\r int main(){\r return 0;\r } todos添加checkbox功能 [ ] write some articles [x] drink a cup of tea advanced-emoji支持Emoji表情 Emoji表情列表 klipse 嵌入一块功能，可在代码段中实时交互，即输入代码 > 执行结果 %accordion% klipse详情 %accordion% klipse源码 , klipse插件地址 插件支持的语言eval-js for javascript eval-clojure for clojurescript eval-scheme for scheme eval-ruby for ruby eval-python for python ctrl+enter执行```eval-python print [x + 1 for x in range(10)] ``` eval-pythonprint [x + 1 for x in range(10)] eval-js var x = 1; x + Math.random(); eval-sql CREATE TABLE play (game, points, day); INSERT INTO play VALUES (\"go\", 500, \"monday\"), (\"go\", 300, \"tuesday\"), (\"chess\", 1250, \"tuesday\"); SELECT * FROM play; %/accordion% flexible-alerts 块增强，4级提示卡片 %accordion% flexible-alerts卡片详情 %accordion% [!NOTE|style:flat] [!NOTE|style:flat] 测试 [!TIP|style:flat] [!TIP|style:flat] 测试 [!WARNING|style:flat] [!WARNING|style:flat] 测试 [!DANGER|style:flat] [!DANGER|style:flat] 测试 [!NOTE|style:callout] [!NOTE|style:callout] 测试 [!TIP|style:callout] [!TIP|style:callout] 测试 [!WARNING|style:callout] [!WARNING|style:callout] 测试 [!DANGER|style:callout] [!DANGER|style:callout] 测试 %/accordion% site-count 文章左上角显示阅读量计数 accordion 折叠模块,放最外层不可缩进。可嵌套，内部可以加代码块，引用，标题等 %accordion%标题%accordion% //需要空一行 任意内容 //需要空一行 %/accordion% spoiler 给片段覆盖一层黑色蒙版 刮刮乐 {@s%}Hello World.{@ends%} //@改为% hide-element可以隐藏不想看到的元素，比如导航栏中Published by GitBook \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } 参考：GitBook插件整理 发布到 GitHub Pages 由于 gitbook 书籍可以本地构建出静态HTML格式,所以可以直接将构建好的书籍直接放到GitHub Pages中托管,之后可以通过如下地址访问书籍： .github.io/ 原仓库子目录部署 直接在项目设置的pages设定下面选择默认构建,并设置分支为master,目录为_book. gitbook build 在_book子目录下生成静态文件 git push origin master推送整个项目到远程 使用actions workflow自动部署 github pages的默认构建方式是jekyll,使用某些gitbook插件时可能会构建失败，从而导致无法继续部署.比如使用codesnippet时无法成功构建.这个时候可以通过自定义静态文件构建的方式完成部署.actions文档 在master分支下新建.github/workflows/static.yml(在push事件触发时执行静态文件部署工作流--检出子目录_book并上传到静态页面服务器.) gitbook build 在_book子目录下生成静态文件 git push origin master推送整个项目到远程 %accordion%.github/workflows/static.yml%accordion% # Simple workflow for deploying static content to GitHub Pages\r name: Deploy static content to Pages\r \r on:\r # Runs on pushes targeting the default branch\r push:\r branches: [\"master\"]\r \r # Allows you to run this workflow manually from the Actions tab\r workflow_dispatch:\r \r # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\r permissions:\r contents: read\r pages: write\r id-token: write\r \r # Allow one concurrent deployment\r concurrency:\r group: \"pages\"\r cancel-in-progress: true\r \r jobs:\r # Single deploy job since we're just deploying\r deploy:\r environment:\r name: github-pages\r url: ${{ steps.deployment.outputs.page_url }}\r runs-on: ubuntu-latest\r steps:\r - name: Checkout\r uses: actions/checkout@v3\r - name: Setup Pages\r uses: actions/configure-pages@v2\r - name: Upload artifact\r uses: actions/upload-pages-artifact@v1\r with:\r # Upload static HTML repository\r path: './_book'\r - name: Deploy to GitHub Pages\r id: deployment\r uses: actions/deploy-pages@v1 %/accordion% 推送到分支部署 推送到分支意义不大,actions也可以完成推送到分支部署的任务,这边仅保留方案记录. 只需要4步即可将静态HTML文件发布到gh-pages分支: gitbook build 在_book子目录下生成静态文件 git subtree split --rejoin --prefix=_book --branch gh-pages拆分子目录到新的分支gh-pages git subtree push --squash --prefix=_book origin gh-pages 推送到远程仓库 在该github仓库的settings->pages中做下图所示修改然后直接通过.github.io访问就可以访问到gh-pages,即_book目录下构建的静态文件 维护这个库的所有命令都在仓库根目录的Makefile里面定义了，可以参考 guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-02 11:50:28 "},"posts/Blog实践markdown+gitbook+vscode.html":{"url":"posts/Blog实践markdown+gitbook+vscode.html","title":"Blog实践markdown+gitbook+vscode","keywords":"","body":"Blog 实践 markdown + gitbook + vscode [toc] 当前影响Blog持久维护的因素有哪些? 一个好的Blog实践最好应该满足哪些条件? 当前常见方案有哪些缺点? 原先建的基于wordpress的博客总觉得很臃肿,对markdown的支持有限,或者说写作体验一言难尽,所以现在已经废弃了. 随着阅历的增长,精力的分散,对事物的追求逐渐朝着极简的方向走去,另一方面自感当前自身的主要矛盾在于信息的大量输入与总结和深度思考之间的不平衡,本身有用onenote+xmind做知识库的习惯,一直没有时间整理输出,本质是拖延症导致的输出不力,所以希望能简单地及时地输出一些技术文章或心得总结,在此过程中满足好奇心,整理知识体系,有所进益. 对于一个严谨的技术宅来说,如何长期维护好一个Blog是一件值得好好研究的事情.想清楚以下2个问题,那么问题就解决了一半. 当前影响Blog持久维护的因素有哪些? 国内访问不良,如果自建站的云虚机在国外的服务商,容易导域名污染等问题.特别是往往同一个VPS还要挂载自己的代理服务，更容易被BAN。 VPS维护不良,每年的域名,HTTPS管理,还有大量脚本小子喜欢扫描漏洞,对小虚机来说跟DDOS一样,容易崩. 搜索引擎索引不良,流量可以产生正向反馈,如果没人看的话持续写作的积极性会受到影响, MSDN类博客占搜索引擎权重较高流量较好但是写作及阅读体验不够简洁. 写作体验不良,网页编辑器不友好,对markdown的支持不佳特别是md的高阶功能,流程图等等. 阅读体验不佳,自建站需要易用的md渲染器.Wordpress上有插件，但WP本身不够简洁. 图像资源管理麻烦,一般需要先上传到OSS再插入网络链接,为了方便迁移,转载,一般不放网站本地. 文章管理不方便,如果需要移动或者重新分类的话,点来点去实在不够方便. 一个好的Blog实践最好应该满足哪些条件? 省时省心省资源 一切不让人省时省心的方案都应该Pass掉,让Blog回归写作与分享 使用托管而非自建站 网页静态构建 良好的文本编辑体验 跨平台(迁移性) 富文本(描述性) 社群支持丰富(扩展性) 所见即所得 良好的可维护性 足够简洁,满足基础Blog功能 项目直接管理图像资源 良好的可阅读性 结构化书籍模式,文章分层分类,一目了然 代码高亮 搜索引擎索引良好 当前常见方案有哪些缺点? wordpress 臃肿,不适合技术写作 github project + issue 可迁移性差,issue放文章简直反人类 github jkeyll jkeyll学习成本相对较高 首先需要找个好的静态模板,挑个模板得调试半天 不够简洁 各博客网站 辅助传播可以,不够技术范 综上,经过一番探索,当前比较适合我的方案是: 写作载体: markdown 内容载体: gitbook 编辑载体: vscode 这三者的搭配是一脉相承,全面且是更加md-style的. markdown 不必细说,除了原生语法,高阶语法/特性需要平台或编辑器能够支持:科学公式LaTeX,文章目录TOC,流程图,时序图,甘特图,思维导图(xmind支持使用markdown来写导图)等等. vscode 宇宙第一编辑器,安装扩展插件Markdown Preview Enhanced,支持大量功能特性，建议查看MPE官方文档。 gitbook 基于markdown,可以构建静态页面放到GitHub Pages中托管并且自动和Github仓库同步,支持社交分享评论,代码高亮等等各类丰富的插件,且插件及其容易集成配置,能够满足许多增强性扩展性的要求.关于gitbook的更多细节可以参看gitbook简明教程. Github pages和Gitbook设置完成后可以通过 https://mainvooid.github.io/ 或 https://ipanda.gitbook.io/blog 访问到同一个Blog. 事实上我首先考虑的是用jekyll做内容载体,更丰富的网站模板与功能,但是我发现在开始使用jekyll之前,我需要首先找到一个符合我风格的足够合适的模板,毕竟我不是前端,琳琅满目的模板实在没有让我满意的,我累了,这不够naive and simple,我放弃了,所以我选择另寻出路,直到我意识到gitbook可以完美担此重任. 而且使用gitbook还有一个好处是,可以像写书一样写Blog,更有层次感也更容易建立分类体系,对Blog结构和内容的控制是一体化的,不需要涉及HTML,而且构建出来的网页是左目录右内容的形式,更加有md-style的感觉,最重要的是——简洁. 影响Blog持久维护的本质其实就是写作以外的事情占用了过多的精力.比如设计调整Blog风格,需要过多考虑博文分类,甚至自建站需要考虑更多东西例如网站安全或SEO,写到后期会发现Blog越来越臃肿而难以管理,但凡写Blog的人多少有点完美主义,这种事情注定是难以持续的. 所以,如果你正好看见了我的这篇博文,正在考虑如何持久维护一个Blog,比如五年起步,那么,我给你的建议就是——\"越简单越好,回归写作本身\". 关于什么叫md-style,我的个人理解是: 简洁但不简单 语法简单,同时支持大量高级特性与富文本扩展 左右对称 语法块大多是闭合体 编辑时,左编辑右预览 英文符号 标点符号使用英文字符,删除所有尾随空格,与md统一风格的话输入法可以设置中文时使用英文标点. 扩展: 其他类似gitbook的框架: vuepress Blog分发平台: 语雀 : 足够小白,并且个人主页有类似Github的活跃度呈现 知乎 : 对markdown的支持不够好 CSDN 简书 博客园 掘金 gitbook自由度高有许多文本增强插件,想要迁移分发写的东西可能需要费点心思. guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-12-01 17:16:28 "},"posts/基于Windows文本服务框架TSF的输入法实现.html":{"url":"posts/基于Windows文本服务框架TSF的输入法实现.html","title":"基于Windows文本服务框架TSF的输入法实现","keywords":"","body":"基于Windows文本服务框架TSF的输入法实现 [toc] 背景 TSF的构成和基本工作过程 基本概念 什么是TSF? TSF 体系结构 与应用程序的交互 输入法的设计与具体实现 主要接口函数的实现 输入法的基本实现步骤 创建空白的动态链接库项目 文本服务模块的设计 完成按键的映射 输入组合与候选列表的处理 把文本服务注册为标准COM进程服务项 输入法的安装要点 总结 背景 输入法是指为将各种按键序列转化为字符,输入计算机或其他设备(如手机,平板)而采用的编码方案,因此输入法的研究是信息处理的一个重要课题.Windows提供了两套输入法框架: 在Windows XP及之前,是IMM(Input Method Manager),即输入法引擎,基于纯函数API; Windows XP及以后,提供了新的输入法框架TSF(Text Service Framework),是基于COM(组件对象 模型)的. 目前现有的各个版本输入法大多采用输入法管理器-输入法生成器(IMM-IME)框架进行开发,然而在 Windows 8 系统中 Metro 风格的应用是不支持该框架的,在这些应用下进行输入,需要使用文本服务框架(TSF)开发的输入法. 本文将主要介绍TSF框架的基本构成,输入法的设计以及安装要点. TSF的构成和基本工作过程 基本概念 什么是TSF? TSF为高级文本和自然语言输入技术提供了一个简单,可扩展的框架,是一项从 Windows XP 开始提供的设备无关,语言无关的系统服务.TSF与传统 IME 相比虽然对键盘输入法的作用没有太大区别,但是支持 TSF 的应用程序可以从任何支持TSF的文本服务中接收文本输入(例如手写,语音输入),而不用考虑有关文本来源的具体细节. TSF 体系结构 TSF 主要由应用程序,文本服务和TSF管理器三个部分组成,其结构如图所示: 应用程序(Applications):应用程序的任务一般包括显示, 直接编辑以及文本存储,通过实现 COM 服务来提供文本访问的能力. TSF管理器(TSF Manager):作为文本服务与应用程序之间中间层,TSF管理器支持一个应用程序同时建立多个与文本服务之间的联系,共享文本内容.其功能是由操作系统实现的. 文本服务(Text Services):向应用程序提供文本,同样用COM实现,内置了注册为TSF的服务过程.多个文本服务允许同时被注册,可以包含文本的输入与输出,还可以作为一段文本的数据和属性的关联体.也可以称为TIP(Text Input Processor),比如输入法提供语音,手写,键盘,翻译输入,那就是4个Tip. 与应用程序的交互 TSF的优点在于其设备无关,语言无关,并且可扩展的特性,同时能够给用户提供一致的输入体验.任何 TSF-enabled 的应用程序都能从任何 Text Service 接收文本,同时可以输出文本,而不需要知道文本来源的详细信息.同时,文本服务也不需要考虑各种不同应用之间的差别.TSF是应用与IME之间的中介,TSF将输入事件传递给IME并在用户选择字符后接收从IME返回的输入字符. 输入法的设计与具体实现 主要接口函数的实现 与传统 IME 必须要实现的 ImeInquire,ImeConfigure, ImeProcessKey,ImeToAsciiEx等接口函数不同,文本服务框架包含了一组新的接口函数,具体实现方法也有所不同.其中一些重要的接口如下: 文本输入处理(ITfTextInputProcessor):是创建文本服务需要实现的第一个接口,继承自 IUnknown 接口,由TSF管理器调用来实现文本服务的Activate与Deactivate. 线程管理器事件接收器(ITfThreadMgrEventSink):该接口允许文本服务来接收与响应事件焦点的变化.在 TSF 中,事件通知由被称之为事件接收器的 COM 对象收取,因此,客户端需要实现一个 ITfThreadMgrEventSink 对象,并安装事件接收器, 从而获得线程管理器发送的事件通知.在TSF中,应用程序和文本服务被定义为客户端. 文档管理器(ITfDocumentMgr):文档管理器的作用是管理编辑的内容,每个文档管理器都维护着一个后进先出的缓冲区,通常称之为内容栈,用来存储对应的文档管理器所管理的编辑内容列表. 语言栏按钮项目信息(ITfLangBarItemButton):该接口也继承自 IUnknown 接口,实现一些语言栏上按钮项的信息,例如图标,文本,点击弹出的菜单项等. 编辑会话(ITfEditSession):编辑会话由文本服务实现并由TSF管理器调用来读取或者修改文本和属性的上下文. 输入组合(ITfComposition):输入组合接口由TSF管理器实现,同样继承自IUnknown接口.应用程序显示什么样的文本,以及是否显示文本,需要获取输入组合的显示属性信息,通过判断输入组合是否存在,将其状态显示给用户. 编辑内容查看对象(ITfContextView):文本服务为候选列表创建新的内容后,ITfContextView接口的GetTextExt方法可返回文本边界框的屏幕坐标.除了以上接口,TSF还有线程管理器(ITfThreadMgr),客户端标识符(ITfClientId),键盘事件接收器(ITfKeyEventSink),属性设置(ITfProperty)等一些重要接口需要实现,此处不再一一赘述. 输入法的基本实现步骤 创建空白的动态链接库项目 输入法程序实际上就是一个动态链接库程序 ,只是这个动态链接库较特殊,文件名的后缀是.ime而不是.dll. 在DLL_PROCESS_ATTACH事件中,使用RegisterClass注册用户界面窗口类.可根据个人喜好设计的状态窗口,编码窗口以及候选窗口的属性. 在DLL_PROCESS_DETACH事件中,注销上述注册的窗口对象并释放该对象使用的所有系统资源. 文本服务模块的设计 用户可使用语言栏或键盘来与文本服务进行交互,因此首先要创建一个文本服务并将其注册.要使文本服务被应用程序所使用,需要将其注册为标准COM嵌入进程服务项,即注册到文本服务框架中.TSF通过ITfInputProcessorProfiles与 ITfCategoryMgr两个接口来提供简单的注册过程支持. 线程管理器(ITfThreadMgr)是TSF Manager的基本组成部分,完成应用程序与客户端之间进行联系的公共任务,包括跟踪输入焦点的改变.同时线程管理器还负责向客户端发送事件通知,客户端通过实现ITfThreadMgrEventSink对象,并使用 ITfSource::AdviseSink方法安装事件接收器,获得事件通知. 文本服务使用文档管理器获取编辑内容,ITfTextEditSink接口允许文本服务接收与响应焦点变化事件,对于一个文本服务或者应用程序来说,这个接口的实现是可选的. 需要注意的是,IME必须与系统任务栏兼容.任务栏仅为兼容的IME显示其图标,对于不兼容的则无法显示.我们需要将IME图标存储在DLL或EXE文件中,而不是独立的.ico文件中. 完成按键的映射 除了语言,手写识别,最常用的仍然是键盘的识别.按键的映射是输入法设计的一个重要部分,顾名思义,也是我们最熟悉的一个部分,这里通过虚键实现对一般按键与功能按键的响应,来完成输入过程. 首先需要使用Windows宏MAKELANGID创建语言标识符,它包含一个主要语言标识符与一个从语言标识符,返回值同样也是语言标识符,通过 ITfInputProcessorProfileMgr的RegisterProfile方法来实现注册.对于拼音输入法,使用MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED) 即可. 按键事件的处理受到几个因素的影响:键盘可用状态,键盘开启状态,输入状态,空闲状态,中英文状态等等,在TSF中, 公共缓冲池为数据共享提供了数据存储和消息处理的机制,以支持客户端程序之间的数据共享.对于键盘来说,公共缓冲池 GUID_COMPARTMENT_KEYBOARD_DISABLED针对的是编辑内容,是预定义的,如果它的值为非零值,那么键盘不可用;而GUID_COMPARTMENT_KEYBOARD_OPENCLOSE针对 的是线程管理器,如果它为非零值,那么键盘处于开启状态. 我们通过 ITfCompartmentMgr接口的GetCompartment方法来检查键盘是否可用. 关于按键的处理如图所示: 接下来实现ITfKeyEventSink接口来处理击键事件,该接口包含了OnKeyDowm,OnKeyUp,OnSetFocus等方法分别处理按键按下,按键弹起与一个TSF文本服务接收或者失去键盘焦点时的事件.同时,ITfKeystrokeMgr接口也同样重要,它允许文本服务与键盘管理器的交互. 输入组合与候选列表的处理 文本服务通过调用ITfContextComposition::StartComposition方法创建输入组合,并通过创建ITfCompositionSink对象接收输入组合的事件消息,使用 ITfContextComposition::EndComposition方法来结束输入组合. 在创建输入组合的同时,文本服务需要提供在应用程序中区别组合输入文本与常规文本的显示属性支持,通过在TF_DISPLAYATTRIBUTE结构中定义文本前景色,背景色,下 划线的样式,色彩,粗细等,来实现显示属性的提供.首先需要调用 ITfCategoryMgr::RegisterCategory方法,把文本服务注册为服务提供者,然后实现ITfDisplayAttributeProvider与IEumTfDisplayAttributeInfo接口并使它们可用,最后为文本服务提供的每种显示属性实现一个 ITfDisplayAttributeInfo对象. 接下来是关于候选列表的处理,用户输入字符后,输入法需要提供一个合适的候选列表以便用户从中选择结果串.创建一个候选列表首先要实现候选窗口的创建与注册,然后完成事件的处理部分,如翻页,选择等,最后实现窗口的销毁和隐藏.需要通过ITfTextLayoutSink,ITfIntegratableCandidtateListUIElement等接口一一实现. 把文本服务注册为标准COM进程服务项 基于TSF框架的输入法实际上是一个COM程序,也就是说微软为我们提供了很多的虚基类,然后我们需要实现一个COM程序.CClassFactory类需要能够创建实现ITfTextInputProcessor接口的对象,所有进程内COM服务器(InProcess COM Server)输出四个标准函数: DllRegisterServer : 用Windows注册表来注册COM对象 DllUnRegisterServer : 解注册 DllGetClassObject : 返回CClassFactory类的实例 DllCanUnloadNow : COM调用,检查是否可以从内存中卸载COM服务器. 我们需要在模块定义文件.def中导出这四个接口函数,这样才能够将输入法在系统中注册. 输入法的安装要点 关于输入法ime有两种安装方式: 使用第三方安装程序,导入自己的词库与所生成的ime文件,创建一个 Setup.exe文件,从而可以让用户安装自己编写的IME. 使用Regsvr32命令.Regsvr32命令用于注册COM组件,是Windows系统提供的用来向系统注册或者卸载控件的命令,以命令行方式运行.具体步骤是将所生成的输入法.ime文件拷贝到系统System文件夹下,然后在cmd下运行Regsvr32 输入法.ime即可.但是这种方式会有一些问题,输入法的图标无法使用,不过不影响测试. 检查是否注册成功.win10系统下,设置->语言->选项->添加键盘,可以查看是否功能正常 总结 作为新一代输入法框架,TSF是一个允许进行高级的,来源无关的文本输入的应用编程接口,它为高级文本和自然语言输入技术提供了一个简单和可扩展的框架.关于图标不能显示的问题还有待解决,另外, 对于一个完整的输入法来说还有软键盘,鼠标输入,系统图标, 菜单设置,输入法皮肤等方面需要一一实现,同时,输入效率也是一个不容忽视的部分,有关输入转换算法还需要进一步的研究. Github上有一些开源输入法例如跨平台的RIME可做参考. guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:52 "},"posts/Android-NDK-Camera双摄接入方案.html":{"url":"posts/Android-NDK-Camera双摄接入方案.html","title":"Android-NDK-Camera双摄接入方案","keywords":"","body":"Android-NDK-Camera双摄接入方案 官方文档: Camera 官方NDK 相机示例：ndk-samples 官方示例里面有俩个module可以参考，主要为单摄，包含preview与snapshot： basic suface 表面对象为ANativeWindow 使用了android_app_glue, 在android_main中循环调用DrawFrame绘制从camera2取到的image CameraEngine 类 处理android_app，相机对象与UI交互 //主要API ANativeWindow_setBuffersGeometry //DrawFrame ANativeWindow_acquire // window surface ANativeWindow_Buffer ANativeWindow_lock //Aimage对象数据处理后输出到buf ANativeWindow_unlockAndPost ANativeWindow_release NDKCamera类 相机管理 //主要API ACameraManager //相机管理 ACaptureRequest //请求对象 ACameraCaptureSession //请求的会话 ACaptureSessionOutputContainer ACameraManager_create // 创建ACameraManager ACameraManager_getCameraIdList//获逻辑相机ID列表 ACameraManager_getCameraCharacteristics//由ACameraMetadata接收属性 ACameraMetadata_getAllTags//获取相机标签 ACameraMetadata_getConstEntry//解析属性 获知前摄还是背摄，旋转状态等等 ACameraManager_openCamera //打开一个相机 ACameraManager_registerAvailabilityCallback //注册相机状态回调 CameraDevice_createCaptureSession //创建会话 ACameraCaptureSession_setRepeatingRequest//设置会话请求，会被循环处理 ACameraCaptureSession_stopRepeating//暂停会话请求 ACameraCaptureSession_capture//截屏 ACaptureRequest_setEntry_...//设置相机参数 通过请求传递 //从ANativeWindow创建会话输出容器与目标 ANativeWindow_acquire ACaptureSessionOutputContainer_create ACaptureSessionOutputContainer_add ACameraOutputTarget_create ACameraDevice_createCaptureRequest ACaptureRequest_addTarget ImageReader类 控制转码，旋转，获取底层数据帧，获取显示到ANativeWindow //主要API AImageReader AImage AImageCropRect AImageReader_new //创建 AImageReader_setImageListener //设置监听器 AImageReader_getFormat //获取图片格式 AImageReader_getWindow //get ANativeWindow AImageReader_acquireNextImage //获取下一帧 没有帧会被跳过 AImageReader_acquireLatestImage //获取最新帧 获取后删除 更实时一些 AImage_getNumberOfPlanes //yuv格式获取plane数 AImage_getPlaneRowStride //用于解析YUV格式 AImage_getPlanePixelStride //用于解析YUV格式 AImage_getPlaneData // 获取plane数据 转码 写文件需要 AImage_getWidth AImage_getHeight AImage_getCropRect 对象基本都要手动调用相应方法析构/解注册 // 析构/解注册方法 ACaptureRequest_free ACameraOutputTarget_free ACaptureSessionOutput_free ACaptureSessionOutputContainer_free ACameraMetadata_free ACameraManager_deleteCameraIdList ANativeWindow_release ACameraManager_unregisterAvailabilityCallback ACameraManager_delete ACameraCaptureSession_close 包装了请求结构体 struct CaptureRequestInfo { ANativeWindow* outputNativeWindow_;//示例项目的输出窗口对象 ACaptureSessionOutput* sessionOutput_; ACameraOutputTarget* target_; ACaptureRequest* request_; ACameraDevice_request_template template_;//请求flag int sessionSequenceId_; }; 包装了相机结构体 // helper classes to hold enumerated camera class CameraId { public: ACameraDevice* device_; std::string id_; acamera_metadata_enum_android_lens_facing_t facing_; bool available_; // free to use ( no other apps are using bool owner_; // we are the owner of the camera explicit CameraId(const char* id) : device_(nullptr), facing_(ACAMERA_LENS_FACING_FRONT), available_(false), owner_(false) { id_ = id; } explicit CameraId(void) { CameraId(\"\"); } }; 其他 有2个ImageReader，分别处理yuv(preview)和jpg(capture)数据,在初始化时需要分别获取各自的ANativeWindow并各自在创建会话时绑定到会话的输出容器与目标中 texture-view 结构类似basic //主要API ANativeWindow_fromSurface //从Surface获取ANativeWindow 总结： 主要流程: 添加权限 指定draw与buffer对象 preview应用于ANativeWindow 可以从Surface或者ANativeWindow_Buffer获取buffer对象 获取相机ID列表 初始化并打开指定相机 初始化会话并开启请求 取下层图像帧输出到buf显示 帧率： 下层BufferQueueProducer显示的帧率为30FPS左右， 应用层循环取数据draw，频率大概50FPS AImageReader_acquireLatestImage//实时 AImageReader_acquireNextImage//低端机上会导致preview的fps低 上层消费者取buf的速度比生产者快，所以帧率是同步的 格式： 当前preview格式为AIMAGE_FORMAT_YUV_420_888 snapshot格式为AIMAGE_FORMAT_JPEG 应该能支持其他格式，这边以示例为准并未进一步测试 preview保存的YUV数据以NV21方式可以解 YUV2RGB之后才会输出到buf里面再显示，具体YUV2RGB转换可以参考 ImageReader::PresentImage 分辨率： // 参考 CameraEngine::CreateCamera NDKCamera::MatchCaptureSizeRequest struct ImageFormat { int32_t width; int32_t height; int32_t format; // Through out this demo, the format is fixed to // YUV_420 format }; ImageFormat view{0, 0, 0}, capture{0, 0, 0}; //传输给函数处理进行初始值判断设置 //获取相机支持的分辨率 ACameraMetadata_getConstEntry(metadata, ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS, &entry)); //手动设置分辨率 e.g. view.width=3584; view.height=2240; //同步设置接收窗口大小 ANativeWindow_setBuffersGeometry //ImageFormat初始化后传递给ImageReader构造 AImageReader_new //创建相应分辨率的reader，也可以在此手动指定分辨率但要符合相机支持 双摄目测流程: 分别准备好buffer对象 分别打开相机并初始化 2个ImageReader分别处理相机数据流 创建一个会话并一系列初始化后开启请求 注意事项： ACameraCaptureSession 这个对象似乎只能创建一个，新建的会close掉前面的 测试结果 晋兴微 (1280,800) queueBuffer 显示fps=20左右 (3584,2240) queueBuffer 显示fps=9.75左右 也就是说由于此设备硬件性能原因，分辨率大，内存CPU等跟不上，HAL生产数据帧的帧率就会降低 java api 和C++ api性能 前端窗口显示的大小也会影响实际性能，测试需要控制变量，目前C++ api测试程序前端窗口是满屏的，JAVA api测试程序窗口略小一些。 总体上来看 关于java和C++ api 的性能——并没有显著区别 扩展 关于Camera2有人总结的比较好 Android NDK Camera2小结 google基于Camera2封装了一层更友好的相机接口CameraX CameraX 官方文档 对理解框架有帮助 Android Camera2 HAL3 学习文档 %accordion% 设备存在问题：消费者消费速度跟不上生产者 %accordion% (3584,2240) 分辨率下 JAVA api queueBuffer显示帧率20FPS 而应用层显示只有10FPS左右 初步怀疑: 系统性能瓶颈，对高分辨率图像处理不过来，2边API应用层调用的都是acquireLatestImage，实时性是比较好的，如果还有性能瓶颈，主要原因是设备性能太差。 应用层回调while循环做的事情较多,导致循环/回调的FPS小于下层生产者的速度，成为应用层FPS制约的瓶颈之一. 考虑数据出HAL层到应用层之间有没有可能在晋兴微的设备的中间层被衰减处理了，但是小分辨率图测试下，queueBuffer和应用层显示的FPS是同步的，所以，基本可以排除这种情况。 那么更有可能是应用层消费者吃饭速度太慢，太慢的原因可能是上述说的在大分辨率图的情况下回调的FPS跟不上生产者，处理太耗时之类的，或者系统性能瓶颈导致确实处理不过来,后者的可能性更大一些。但是前者需要进行测试排除或优化，检查处理大分辨率图时的耗时情况，或者另起线程处理，回调中不做耗时操作。 queueBufferProducer作为安卓底层,它发出的log,数据是可信的,它生产速度是多少就是多少. 关于为什么queueBufferProducer显示的FPS和应用层实际不一致的情况，很显然原因是因为应用层处理过慢.至于过慢的原因，上面也已经做了说明. 目前cpp api测试正常性能的设备，只要消费者速度能跟上生产者，大分辨率下应用层和底层的preview帧率也是同步的。 综上所述，主要晋兴微的设备自身的性能问题导致FPS上不去 %/accordion% guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:31 "},"posts/CI&CD相关模块的共享方案.html":{"url":"posts/CI&CD相关模块的共享方案.html","title":"CI&CD相关模块的共享方案","keywords":"","body":"CI&CD相关模块的共享方案 [toc] 需求： 满足不同成员与不同项目对公共配置/构建文件等的代码复用 情景1 统一各类配置库管理 情景： 用于不同项目的build.py的公共逻辑/函数方法,及一系列用于构建的其他python辅助方法 用于*.cmake的公共函数function macro 未来兼容其他配置，统一管理的扩展性 作为构建代码也需要版本管理 为便于管理应该组织在一个库中 此库包含一般通用方法，也包含项目内部可能特有的公共方法 这些公共辅助方法应该能较方便按文件/目录拉取到项目目录下 为了避免对依赖方的影响，接口/函数命名同样需要前向兼容保持稳定 此情景下有以下方式： 基于git的sparse clone 在项目中配置此库需要拉取的文件，本地使用，而不加入项目的版本管理. 实现方案： 初始化# 创建用于本地仓库的文件夹 mkdir localdir # 进入文件夹 cd localdir # 在本地指定文件夹内执行此命令设置为git仓库 git init 拉取remote all objects信息# 添加远程仓库地址，实现拉取remote的all objects信息 git remote add -f origin https://.../.git 开启sparse clone # 用于控制是否允许设置pull指定文件/夹，适用于Git1.7.0以后版本，本质是开启sparse git config core.sparsecheckout true # 本地目录的.git文件夹下，如果没有sparse-checkout文件则创建，在其中添加指定的文件/夹fileName，就是需要拉取的那个特定文件/夹。*表示所有，！表示匹配相反 echo \"build.py\" >> .git/info/sparse-checkout # 查看 cat .git/info/sparse-chechout 拉取指定目录/文件 # 拉取命令是一样的，只是已经通过配置文件sparse-chechout指定了目标文件/夹 git pull origin master 这样就只拉取了\"build.py\"下来,这样拉取下来会保留有原来的目录结构. 优点： 可以支持仅拉取需要的文件/目录 缺点： 每个项目都得本地配置一遍上述流程 2.通过git的submodule 优点： 直接的子模块依赖，子模块的版本控制与当前项目是分离的 与项目直接依赖，在git初始化时自动拉取该依赖 子模块更新时拉取更新也很方便 缺点： 会拉取子项目所有文件 情景2 仅python情景,通过Python脚本控制全流程配置 希望依赖的时候基于package版本，而不是源码（事实上保证接口前向兼容，完全可以基于最新源码） 通过pypi 源代码仓库结构： /src README.md requirement.txt setup.py 其中setup.py: from setuptools import find_packages, setup setup( name='build_utils', version='1.0.0', description='utils for build', author='xxx', author_email='XXX@xxx', url='https://github.com/build_utils/', #packages=find_packages(), packages=['src'], #install_requires=['requests'], ) 自定义pypi源 用户目录$HOME/.pypirc 下添加 : [distutils] index-servers = [] repository: username: password: MacOS / Linux 在 $HOME/.pip/pip.conf 文件添加以下配置。 [global] index-url = https:///script/simple #推送 twine upload -r dist/* #拉取 pip3 install -i pypi.org源 [distutils] index-servers=pypi [pypi] repository = https://upload.pypi.org/legacy/ username: 注册的pypi账号 password: 注册的pypi密码 上传仓库到github上 执行 python setup.py sdist #setup.py 同级目录生成一个dist文件夹,里面是 sdk1.0.tar.gz 解压安装: python setup.py install # 注:使用 setup.py没有卸载功能,如果需要卸载则要手动删除 # 也可使用: -- record 记录安装文件的目录 python setup.py install --record file.txt # 卸载时可以使用脚本去实现自动安装和卸载 #推送 twine upload dist/* #拉取 pip3 install guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-27 03:06:14 "},"posts/嵌入式设备调试总结.html":{"url":"posts/嵌入式设备调试总结.html","title":"嵌入式设备调试总结.md","keywords":"","body":"嵌入式设备调试总结 [toc] 包含SDK开发中的常用命令及调试工具 工具 网络测试工具 wiresharke Wireshark网络抓包(一)——数据包、着色规则和提示 tcpdump chmod 777 ./tcpdump # -w写入文件cap用于分析 ,-C指定文件大小100MB,host过滤主机url ./tcpdump -w /sdcard/test.cap -C 100 host 串口调试 picocom sudo apt-get install picocom sudo picocom -b 115200 /dev/ttyUSB0 #进入Picocom终端模式 # Ctrl+a进入转义模式，然后Ctrl+h 可以获取当前版本支持的命令 查看依赖库 objdump objdump -x libxxx.so | grep NEEDED NEEDED libcurl.so.4 NEEDED libz.so.1 NEEDED libssl.so.1.0.0 NEEDED libcrypto.so.1.0.0 NEEDED libopencv_core.so.3.2 NEEDED libopencv_imgproc.so.3.2 NEEDED libopencv_imgcodecs.so.3.2 NEEDED libturbojpeg.so.0 NEEDED libstdc++.so.6 NEEDED libm.so.6 NEEDED libgcc_s.so.1 NEEDED libc.so.6 刷机工具 pkgburn 选择好固件，关机状态，按住串口线的按钮,电源数据线接入电脑,识别成功后就会自动烧录 刷完需要重新配置一遍设备环境 文件传输 通过TF卡拷贝 cp /mnt/ /tmp 通过smb smb://192.168.1.100/... 通过adb # 支持通配符 adb push adb pull 通过nfs 1. 设备是NFS的客户端，PC作为Server端，PC需要先安装nts-server。 # 安装nfs-server sudo apt install nfs-kernel-server 2. 创建PC共享文件夹(以/home/dell/ez为例)。 sudo mkdir -p /home/dell/ez sudo chown nobody:nogroup /home/dell/ez sudo chmod 777 /home/dell/ez 3. 设备连接局域网，查看设备的IP。 # 使用picocom打开串口，进入设备shell环境 sudo picocom -b 115200 /dev/ttyUSB0 # 设备环境下查看设备IP ifconfig 4. PC添加设备IP访问权限(替换下面命令中的实际IP)。 sudo nano /etc/exports /home/dell/ez IP(rw,sync,no_subtree_check) # Ctrl+X, entering Y, and then hitting Enter. 5. 启动nts-server。 sudo exportfs -a sudo systemctl restart nfs-kernel-server 6. 关闭PC防火墙。 # 查看防火墙状态 sudo ufw status # 如果是active状态，使用以下命令关闭，否则跳过。 sudo ufw disable 7. remount设备rootfs分区。 # 使用picocom打开串口，进入设备shell环境 sudo picocom -b 115200 /dev/ttyUSB0 # remount rootfs mount -o remount, rw / # 同步PC文件夹/home/dell/ez至设备的/mnt/nfs文件夹, 这里的IP为PC的IP地址。如果mount出现问题，可以ping PC的IP地址查看是否能访问 mount -t nfs -o nolock 192.168.1.31:/home/dell/ez /mnt/nfs export LD_LIBRARY_PATH=.:$PATH 8. 将文件拷贝至PC的/home/dell/ez下，可以同步到设备的/mnt/nfs目录，反之同理 一般命令 时间同步 # 指定时间源 ntpd -p ntp.ntsc.ac.cn # 检测是否更新ok date # 或者手动更新, 把系统软件时间同步到硬件,防止系统重启后时间被还原(ntpd不需要) date -s \"2020-07-01 11:25:00\" && hwclock -w 修改权限 chmod 777 /dir adb adb shell exit adb reboot 若程序执行错误打印返回值 echo './run_cmd echo $?'|sh 网络模拟测试 Linux模拟复杂网络环境下的传输(netem和tc) 基于TC和netem实现网络异常情况的模拟 # 第一次调用change改为add，后面都change # 设置wlan0端口的丢包率为30% tc qdisc change dev wlan0 root netem loss 30% # 发送的报文有 0.3% ~ 25% 的丢包率 tc qdisc change dev wlan0 root netem loss 0.3% 25% # 随机产生 2% 损坏的报文（在报文的随机位置造成一个比特的错误） tc qdisc add dev wlan0 root netem corrupt 2% # 网卡延迟增加100ms tc qdisc change dev wlan0 root netem delay 100ms # 报文延迟的时间在 100ms ± 20ms 之间（90ms - 110ms） tc qdisc change dev wlan0 root netem delay 100ms 20ms # 因为网络状况是平滑变化的，短时间里相邻报文的延迟应该是近似的而不是完全随机的。这个值是个百分比，如果为 100%，就退化到固定延迟的情况；如果是 0% 则退化到随机延迟的情况 tc qdisc change dev wlan0 root netem delay 100ms 20ms 50% # distribution 参数来限制它的延迟分布模型。比如让报文延迟时间满足正态分布 tc qdisc change dev wlan0 root netem delay 100ms 20ms distribution normal # 清除wlan0端口的模拟状态 tc qdisc del dev wlan0 root # 查看端口的限制状态 tc qdisc show WIFI配置 # 修改/查看wifi配置 /home/conf/wpa_supplicant.conf /etc/wpa_supplicant.conf ##### wpa_supplicant configuration file template update_config=1 ctrl_interface=/var/run/wpa_supplicant eapol_version=1 ap_scan=1 fast_reauth=1 wowlan_triggers=any network={ ssid=\"ssid\" psk=\"password\" key_mgmt=WPA-PSK } # 关闭 killall wpa_supplicant # -D驱动程序名称(可以是多个驱动程序：nl80211，wext) # -i接口名称 -c配置文件 -B在后台运行守护进程 wpa_supplicant -D nl80211 -i wlan0 -c /home/conf/wpa_supplicant.conf -B # 动态主机配置(可省略) udhcpc -i wlan0 -s /etc/udhcpc.script wpa_cli -i wlan0 scan #搜索附件wifi热点 wpa_cli -i wlan0 scan_result 　#显示搜索wifi热点 wpa_cli -i wlan0 status #当前WPA/EAPOL/EAP通讯状态 wpa_cli -i wlan0 ping #pings wpa_supplicant wpa_cli -i wlan0 add_network #添加一个网络连接,会返回 wpa_cli set_network 11 ssid '\"iPanda-mi8\"' #ssid名称 wpa_cli set_network 11 psk '\"123456\"'　　 #密码 wpa_cli set_network 11 scan_ssid 1 wpa_cli set_network 11 priority 1 #优先级 wpa_cli -i wlan0 list_network #列举保存过的连接 wpa_cli -i wlan0 select_network #连接指定的ssid wpa_cli -i wlan0 enable_network #使能制定的ssid #保存连接 wpa_cli -i wlan0 save_config #信息保存到默认的配置文件中 #断开连接 wpa_cli -i wlan0 disable_network 网卡配置 1. 设置开发板的IP(配置IP地址、网络掩码、广播地址的同时，激活网卡eth0) ifconfig eth0 192.168.1.37 broadcast 192.168.1.255 netmask 255.255.255.0 up 2. 配置网关 route add default gw 192.168.1.1 3. 配置DNS解析 echo \"nameserver 114.114.114.114\" > /etc/resolv.conf 4. 设置一下系统时间 date -s \"2020-08-05 17:40:00\" (当前时间，这里是示例) guobao.v@gmail.com all right reserved，powered by Gitbook最后编辑时间: 2022-11-29 14:59:32 "}}